(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["AVTranscoder"] = factory();
	else
		root["AVTranscoder"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/audioresample/Resampler.ts":
/*!****************************************!*\
  !*** ./src/audioresample/Resampler.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Resampler)
/* harmony export */ });
/* harmony import */ var cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/webassembly/WebAssemblyRunner */ "./src/cheap/webassembly/WebAssemblyRunner.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/audioresample/Resampler.ts";


class Resampler {
    resampler;
    options;
    inputParameters;
    outputParameters;
    constructor(options) {
        this.options = options;
        this.resampler = new cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__["default"](this.options.resource);
    }
    async open(input, output) {
        this.inputParameters = input;
        this.outputParameters = output;
        await this.resampler.run();
        this.resampler.call('resample_set_input_parameters', input.sampleRate, input.channels, input.format, input.layout || 0);
        this.resampler.call('resample_set_output_parameters', output.sampleRate, output.channels, output.format, output.layout || 0);
        let ret = this.resampler.call('resample_init');
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal(`open resampler failed, ret: ${ret}`, cheap__fileName__0, 84);
        }
    }
    resample(input, output, numberOfFrames) {
        return this.resampler.call('resample_process', input, output, numberOfFrames);
    }
    getOutputSampleCount(numberOfFrames) {
        return this.resampler.call('resample_nb_sample', numberOfFrames);
    }
    close() {
        this.resampler.call('resample_destroy');
        this.resampler.destroy();
        this.resampler = null;
    }
    getInputPCMParameters() {
        return this.inputParameters;
    }
    getOutputPCMParameters() {
        return this.outputParameters;
    }
}


/***/ }),

/***/ "./src/avcodec/codec/codec.ts":
/*!************************************!*\
  !*** ./src/avcodec/codec/codec.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CodecId2String: () => (/* binding */ CodecId2String)
/* harmony export */ });
/*
 * libmedia  codec string map
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const CodecId2String = {
    [86017 /* AVCodecID.AV_CODEC_ID_MP3 */]: 'mp3',
    [86018 /* AVCodecID.AV_CODEC_ID_AAC */]: 'mp4a.40',
    [86021 /* AVCodecID.AV_CODEC_ID_VORBIS */]: 'vorbis',
    [86028 /* AVCodecID.AV_CODEC_ID_FLAC */]: 'flac',
    [86076 /* AVCodecID.AV_CODEC_ID_OPUS */]: 'opus',
    [65542 /* AVCodecID.AV_CODEC_ID_PCM_MULAW */]: 'ulaw',
    [65543 /* AVCodecID.AV_CODEC_ID_PCM_ALAW */]: 'alaw',
    [225 /* AVCodecID.AV_CODEC_ID_AV1 */]: 'av01',
    [27 /* AVCodecID.AV_CODEC_ID_H264 */]: 'avc1',
    [173 /* AVCodecID.AV_CODEC_ID_HEVC */]: 'hev1',
    [196 /* AVCodecID.AV_CODEC_ID_VVC */]: 'vvc1',
    [139 /* AVCodecID.AV_CODEC_ID_VP8 */]: 'vp8',
    [167 /* AVCodecID.AV_CODEC_ID_VP9 */]: 'vp09',
    [12 /* AVCodecID.AV_CODEC_ID_MPEG4 */]: 'mp4v'
};


/***/ }),

/***/ "./src/avcodec/function/getAudioCodec.ts":
/*!***********************************************!*\
  !*** ./src/avcodec/function/getAudioCodec.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getAudioCodec)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _codec_codec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../codec/codec */ "./src/avcodec/codec/codec.ts");


function getAudioCodec(codecpar) {
    const codecId = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 4);
    let profile = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 48);
    let codec = _codec_codec__WEBPACK_IMPORTED_MODULE_1__.CodecId2String[codecId];
    if (codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */) {
        /*
         * mp4a.40.profile
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#iso_base_media_file_format_mp4_quicktime_and_3gp
         */
        codec = `${codec}.${profile}`;
    }
    return codec || 'unknown';
}


/***/ }),

/***/ "./src/avcodec/function/getHardwarePreference.ts":
/*!*******************************************************!*\
  !*** ./src/avcodec/function/getHardwarePreference.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getHardwarePreference: () => (/* binding */ getHardwarePreference)
/* harmony export */ });
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/*
 * libmedia webcodec hardware preference different chrome version
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function getHardwarePreference(enable) {
    if (enable) {
        if (!common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].chrome || common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '94', true)) {
            return 'prefer-hardware';
        }
        else {
            return 'allow';
        }
    }
    else {
        if (!common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].chrome || common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '94', true)) {
            return 'prefer-software';
        }
        else {
            return 'deny';
        }
    }
}


/***/ }),

/***/ "./src/avcodec/function/getVideoCodec.ts":
/*!***********************************************!*\
  !*** ./src/avcodec/function/getVideoCodec.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getVideoCodec)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _codec_codec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../codec/codec */ "./src/avcodec/codec/codec.ts");
/* harmony import */ var avformat_codecs_av1__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avformat/codecs/av1 */ "./src/avformat/codecs/av1.ts");
/* harmony import */ var avformat_codecs_vp8__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avformat/codecs/vp8 */ "./src/avformat/codecs/vp8.ts");
/* harmony import */ var avformat_codecs_vp9__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avformat/codecs/vp9 */ "./src/avformat/codecs/vp9.ts");
/* harmony import */ var avformat_codecs_vvc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avformat/codecs/vvc */ "./src/avformat/codecs/vvc.ts");
/* harmony import */ var common_util_string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/string */ "./src/common/util/string.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_base32__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/base32 */ "./src/common/util/base32.ts");










function getVideoCodec(codecpar, extradata) {
    const codecId = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 4);
    let profile = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 48);
    let level = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 52);
    if (!extradata && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](codecpar + 12) !== 0) {
        extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](codecpar + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](codecpar + 16));
    }
    let entry = _codec_codec__WEBPACK_IMPORTED_MODULE_2__.CodecId2String[codecId];
    let codec = '';
    if (codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */) {
        /*
         * avc1.profile_idc.constraint_set.level_idc
         * 每个参数 1 个字节压缩成 16 进制
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#iso_base_media_file_format_mp4_quicktime_and_3gp
         */
        // High 10 Profile 会提示不支持，但是能解码出来
        if (profile === 110 /* H264Profile.kHigh10 */) {
            profile = 100 /* H264Profile.kHigh */;
        }
        codec = common_util_string__WEBPACK_IMPORTED_MODULE_3__.format('%s.%02x00%02x', entry, profile & 0xff, level & 0xff);
    }
    else if (codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */) {
        /**
         *
         * hev1.[general_profile_space?general_profile_idc].[general_profile_compatibility_flags( 十六进制）][general_tier_flag general_level_idc][constraint_flags( 十六进制）]
         * general_profile_space:
         *  A -> 1
         *  B -> 2
         *  C -> 3
         * empty -> 0
         *
         * general_tier_flag:
         *  L -> 0
         *  H -> 1
         *
         */
        let generalProfileSpace = 0;
        let generalProfileCompatibilityFlags = 0;
        let generalTierFlag = 0;
        let constraintFlags = 0;
        if (extradata?.length > 13) {
            generalProfileSpace = (extradata[1] >>> 6) & 0x03;
            generalTierFlag = (extradata[1] >>> 5) & 0x01;
            generalProfileCompatibilityFlags = extradata[2] | (extradata[3] << 8) | (extradata[4] << 16) | (extradata[5] << 24);
            // constraintFlags 目前只能使用 4 个 bit
            constraintFlags = extradata[6] & 0xf0;
        }
        const generalProfileSpaceMap = {
            0: '',
            1: 'A',
            2: 'B',
            3: 'C'
        };
        codec = common_util_string__WEBPACK_IMPORTED_MODULE_3__.format('%s.%s%d.%x.%s%d.%x', entry, generalProfileSpaceMap[generalProfileSpace], profile, generalProfileCompatibilityFlags, generalTierFlag === 0 ? 'L' : 'H', level, constraintFlags);
    }
    else if (codecId === 196 /* AVCodecID.AV_CODEC_ID_VVC */) {
        /**
         *
         * vvc1.<sample entry 4CC>.<general_profile_idc>.[LH]<op_level_idc>{.C<general_constraint_info>}{.S<general_sub_profile_idc>}{.O{<OlsIdx>}{+<MaxTid>}}
         */
        let generalTierFlag = 0;
        if (extradata?.length > 13) {
            generalTierFlag = extradata[5] & 0x01;
        }
        codec = common_util_string__WEBPACK_IMPORTED_MODULE_3__.format('%s.%d.%s%d', entry, profile, generalTierFlag === 0 ? 'L' : 'H', level);
        if (extradata) {
            const params = avformat_codecs_vvc__WEBPACK_IMPORTED_MODULE_4__.parseExtraData(extradata);
            if (params.generalConstraintInfo.length) {
                let index = params.generalConstraintInfo.length - 1;
                while (index > 0 && params.generalConstraintInfo[index] === 0) {
                    index--;
                }
                const generalConstraintInfo = params.generalConstraintInfo.slice(0, index + 1);
                if (generalConstraintInfo.length) {
                    codec += `.C${common_util_base32__WEBPACK_IMPORTED_MODULE_5__.encode(new Uint8Array(generalConstraintInfo), false)}`;
                }
            }
            if (params.generalSubProfileIdc.length) {
                codec += `.S${params.generalSubProfileIdc.map((profile) => profile.toString(16)).join('+')}`;
            }
            codec += `.O${params.olsIdx}+${params.numSublayers}`;
        }
    }
    else if (codecId === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
        /*
         * av01.profile.level+seqTier.bitDepth[.monochrome[.chromaSubsampling[.colorPrimaries[.colorPrimaries[.matrixCoefficients]]]]]
         * url: https://aomediacodec.github.io/av1-isobmff/#codecsparam
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#av1
         */
        if (extradata) {
            const params = avformat_codecs_av1__WEBPACK_IMPORTED_MODULE_6__.parseExtraData(extradata);
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_3__.format('%s.%d.%02d%s.%02d.%d.%d%d%d', entry, params.profile, params.level, params.tier ? 'H' : 'M', params.bitDepth, params.monochrome, params.chromaSubsamplingX, params.chromaSubsamplingY, params.chromaSamplePosition);
        }
        else {
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_3__.format('%s.%d.%02dM.08', entry, profile, level);
        }
    }
    else if (codecId === 139 /* AVCodecID.AV_CODEC_ID_VP8 */) {
        /*
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#videowebmcodecsvp08.00.41.08vorbis
         */
        if (extradata) {
            const params = avformat_codecs_vp8__WEBPACK_IMPORTED_MODULE_7__.parseExtraData(extradata);
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_3__.format('%s.%02d.%02d.%02d', entry, params.profile, params.level, params.bitDepth);
        }
        else if (profile !== avutil_constant__WEBPACK_IMPORTED_MODULE_8__.NOPTS_VALUE && level !== avutil_constant__WEBPACK_IMPORTED_MODULE_8__.NOPTS_VALUE) {
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_3__.format('%s.%02d.%02d.08', entry, profile, level);
        }
        else {
            codec = entry;
        }
    }
    else if (codecId === 167 /* AVCodecID.AV_CODEC_ID_VP9 */) {
        /*
         * vp09.profile.level.colorDepth.chromaSubsampling[.colorPrimaries[.transferCharacteristics[.matrixCoefficients[.blackLevel and color range]]]]
         * url: https://www.webmproject.org/vp9/mp4/#CodecsParameterString
         * url: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter#webm
         */
        if (extradata) {
            const params = avformat_codecs_vp9__WEBPACK_IMPORTED_MODULE_9__.parseExtraData(extradata);
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_3__.format('%s.%02d.%02d.%02d.%02d.%02d.%02d.%02d.%02d', entry, params.profile, params.level, params.bitDepth, params.chromaSubsampling, params.colorPrimaries, params.colorTrc, params.colorSpace, params.fullRangeFlag);
        }
        else if (profile !== avutil_constant__WEBPACK_IMPORTED_MODULE_8__.NOPTS_VALUE && level !== avutil_constant__WEBPACK_IMPORTED_MODULE_8__.NOPTS_VALUE) {
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_3__.format('%s.%02d.%02d.08.00', entry, profile, level);
        }
        else {
            codec = common_util_string__WEBPACK_IMPORTED_MODULE_3__.format('%s.%02d.%02d.08.00', entry, 0, 40);
        }
    }
    else {
        codec = entry || 'unknown';
    }
    return codec;
}


/***/ }),

/***/ "./src/avcodec/wasmcodec/AudioDecoder.ts":
/*!***********************************************!*\
  !*** ./src/avcodec/wasmcodec/AudioDecoder.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WasmAudioDecoder)
/* harmony export */ });
/* harmony import */ var cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/webassembly/WebAssemblyRunner */ "./src/cheap/webassembly/WebAssemblyRunner.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avcodec/wasmcodec/AudioDecoder.ts";



class WasmAudioDecoder {
    options;
    decoder;
    frame;
    constructor(options) {
        this.options = options;
        this.decoder = new cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__["default"](options.resource);
    }
    getAVFrame() {
        if (this.frame) {
            return this.frame;
        }
        return this.frame = this.options.avframePool ? this.options.avframePool.alloc() : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_1__.createAVFrame)();
    }
    outputAVFrame() {
        if (this.frame) {
            if (this.options.onReceiveFrame) {
                this.options.onReceiveFrame(this.frame);
            }
            else {
                this.options.avframePool ? this.options.avframePool.release(this.frame) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_1__.destroyAVFrame)(this.frame);
            }
            this.frame = 0;
        }
    }
    receiveAVFrame() {
        return this.decoder.call('decoder_receive', this.getAVFrame());
    }
    async open(parameters) {
        await this.decoder.run();
        let ret = this.decoder.call('decoder_open', parameters, 0, 1);
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal(`open audio decoder failed, ret: ${ret}`, cheap__fileName__0, 82);
        }
    }
    decode(avpacket) {
        let ret = this.decoder.call('decoder_decode', avpacket);
        if (ret) {
            return ret;
        }
        while (true) {
            ret = this.receiveAVFrame();
            if (ret === 1) {
                this.outputAVFrame();
            }
            else if (ret < 0) {
                return ret;
            }
            else {
                break;
            }
        }
        return 0;
    }
    async flush() {
        this.decoder.call('decoder_flush');
        while (1) {
            const ret = this.receiveAVFrame();
            if (ret < 1) {
                return;
            }
            this.outputAVFrame();
        }
    }
    close() {
        this.decoder.call('decoder_close');
        this.decoder.destroy();
        this.decoder = null;
        if (this.frame) {
            this.options.avframePool ? this.options.avframePool.release(this.frame) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_1__.destroyAVFrame)(this.frame);
            this.frame = 0;
        }
    }
}


/***/ }),

/***/ "./src/avcodec/wasmcodec/AudioEncoder.ts":
/*!***********************************************!*\
  !*** ./src/avcodec/wasmcodec/AudioEncoder.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WasmAudioEncoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/webassembly/WebAssemblyRunner */ "./src/cheap/webassembly/WebAssemblyRunner.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var avutil_function_audioData2AVFrame__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/function/audioData2AVFrame */ "./src/avutil/function/audioData2AVFrame.ts");
/* harmony import */ var cheap_stack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/stack */ "./src/cheap/stack.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
var cheap__fileName__4 = "src/avcodec/wasmcodec/AudioEncoder.ts";











class WasmAudioEncoder {
    options;
    encoder;
    parameters;
    timeBase;
    avpacket;
    avframe;
    constructor(options) {
        this.options = options;
        this.encoder = new cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__["default"](this.options.resource);
    }
    getAVPacket() {
        if (this.avpacket) {
            return this.avpacket;
        }
        return this.avpacket = this.options.avpacketPool ? this.options.avpacketPool.alloc() : (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_1__.createAVPacket)();
    }
    outputAVPacket() {
        if (this.avpacket) {
            this.options.onReceiveAVPacket(this.avpacket);
            this.avpacket = 0;
        }
    }
    receiveAVPacket() {
        return this.encoder.call('encoder_receive', this.getAVPacket());
    }
    async open(parameters, timeBase) {
        await this.encoder.run();
        const timeBaseP = cheap_stack__WEBPACK_IMPORTED_MODULE_2__.malloc(8);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](timeBaseP, timeBase.num);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](timeBaseP + 4, timeBase.den);
        let ret = this.encoder.call('encoder_open', parameters, timeBaseP, 1);
        cheap_stack__WEBPACK_IMPORTED_MODULE_2__.free(8);
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal(`open video decoder failed, ret: ${ret}`, cheap__fileName__4, 96);
        }
        await this.encoder.childrenThreadReady();
        this.parameters = parameters;
        this.timeBase = timeBase;
    }
    encode(frame) {
        if (!common_util_is__WEBPACK_IMPORTED_MODULE_5__.number(frame)) {
            if (this.avframe) {
                (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_6__.unrefAVFrame)(this.avframe);
            }
            else {
                this.avframe = (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_6__.createAVFrame)();
            }
            frame = (0,avutil_function_audioData2AVFrame__WEBPACK_IMPORTED_MODULE_7__.audioData2AVFrame)(frame, this.avframe);
        }
        let ret = this.encoder.call('encoder_encode', frame);
        if (ret) {
            return ret;
        }
        while (true) {
            ret = this.receiveAVPacket();
            if (ret === 1) {
                this.outputAVPacket();
            }
            else if (ret < 0) {
                return ret;
            }
            else {
                break;
            }
        }
        return 0;
    }
    async flush() {
        this.encoder.call('encoder_flush');
        while (1) {
            const ret = this.receiveAVPacket();
            if (ret < 1) {
                return;
            }
            this.outputAVPacket();
        }
    }
    getExtraData() {
        const pointer = this.encoder.call('encoder_get_extradata');
        const size = this.encoder.call('encoder_get_extradata_size');
        if (pointer && size) {
            return (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_8__.mapUint8Array)(pointer, size).slice();
        }
        return null;
    }
    close() {
        this.encoder.call('encoder_close');
        this.encoder.destroy();
        this.encoder = null;
        if (this.avpacket) {
            this.options.avpacketPool
                ? this.options.avpacketPool.release(this.avpacket)
                : (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_1__.destroyAVPacket)(this.avpacket);
            this.avpacket = 0;
        }
        if (this.avframe) {
            (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_6__.destroyAVFrame)(this.avframe);
            this.avframe = 0;
        }
    }
}


/***/ }),

/***/ "./src/avcodec/wasmcodec/VideoDecoder.ts":
/*!***********************************************!*\
  !*** ./src/avcodec/wasmcodec/VideoDecoder.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WasmVideoDecoder)
/* harmony export */ });
/* harmony import */ var cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/webassembly/WebAssemblyRunner */ "./src/cheap/webassembly/WebAssemblyRunner.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avcodec/wasmcodec/VideoDecoder.ts";



class WasmVideoDecoder {
    options;
    decoder;
    frame;
    parameters;
    constructor(options) {
        this.options = options;
        this.decoder = new cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__["default"](this.options.resource);
    }
    getAVFrame() {
        if (this.frame) {
            return this.frame;
        }
        return this.frame = this.options.avframePool ? this.options.avframePool.alloc() : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_1__.createAVFrame)();
    }
    outputAVFrame() {
        if (this.frame) {
            if (this.options.onReceiveFrame) {
                this.options.onReceiveFrame(this.frame);
            }
            else {
                this.options.avframePool ? this.options.avframePool.release(this.frame) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_1__.destroyAVFrame)(this.frame);
            }
            this.frame = 0;
        }
    }
    receiveAVFrame() {
        return this.decoder.call('decoder_receive', this.getAVFrame());
    }
    async open(parameters, threadCount = 1) {
        await this.decoder.run();
        let ret = this.decoder.call('decoder_open', parameters, 0, threadCount);
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal(`open video decoder failed, ret: ${ret}`, cheap__fileName__0, 119);
        }
        this.parameters = parameters;
        await this.decoder.childrenThreadReady();
    }
    decode(avpacket) {
        let ret = this.decoder.call('decoder_decode', avpacket);
        if (ret) {
            return ret;
        }
        while (true) {
            ret = this.receiveAVFrame();
            if (ret === 1) {
                this.outputAVFrame();
            }
            else if (ret < 0) {
                return ret;
            }
            else {
                break;
            }
        }
        return 0;
    }
    async flush() {
        this.decoder.call('decoder_flush');
        while (1) {
            const ret = this.receiveAVFrame();
            if (ret < 1) {
                return;
            }
            this.outputAVFrame();
        }
    }
    close() {
        this.decoder.call('decoder_close');
        this.decoder.destroy();
        this.decoder = null;
        if (this.frame) {
            this.options.avframePool ? this.options.avframePool.release(this.frame) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_1__.destroyAVFrame)(this.frame);
            this.frame = 0;
        }
        this.parameters = 0;
    }
    setSkipFrameDiscard(discard) {
        this.decoder.call('decoder_discard', discard);
    }
}


/***/ }),

/***/ "./src/avcodec/wasmcodec/VideoEncoder.ts":
/*!***********************************************!*\
  !*** ./src/avcodec/wasmcodec/VideoEncoder.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WasmVideoEncoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/webassembly/WebAssemblyRunner */ "./src/cheap/webassembly/WebAssemblyRunner.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var cheap_stack__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/stack */ "./src/cheap/stack.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var avutil_function_videoFrame2AVFrame__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/function/videoFrame2AVFrame */ "./src/avutil/function/videoFrame2AVFrame.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
var cheap__fileName__13 = "src/avcodec/wasmcodec/VideoEncoder.ts";











class WasmVideoEncoder {
    options;
    encoder;
    parameters;
    timeBase;
    avpacket;
    avframe;
    constructor(options) {
        this.options = options;
        this.encoder = new cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__["default"](this.options.resource);
    }
    getAVPacket() {
        if (this.avpacket) {
            return this.avpacket;
        }
        return this.avpacket = this.options.avpacketPool ? this.options.avpacketPool.alloc() : (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_1__.createAVPacket)();
    }
    outputAVPacket() {
        if (this.avpacket) {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](this.parameters + 4) === 27 /* AVCodecID.AV_CODEC_ID_H264 */
                || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](this.parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](this.parameters + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](this.avpacket + 80, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](this.parameters + 160));
            }
            this.options.onReceiveAVPacket(this.avpacket);
            this.avpacket = 0;
        }
    }
    receiveAVPacket() {
        return this.encoder.call('encoder_receive', this.getAVPacket());
    }
    async open(parameters, timeBase, threadCount = 1) {
        await this.encoder.run();
        const timeBaseP = cheap_stack__WEBPACK_IMPORTED_MODULE_4__.malloc(8);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](timeBaseP, timeBase.num);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](timeBaseP + 4, timeBase.den);
        let ret = this.encoder.call('encoder_open', parameters, timeBaseP, threadCount);
        cheap_stack__WEBPACK_IMPORTED_MODULE_4__.free(8);
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](parameters + 160) === 1 /* BitFormat.AVCC */) {
            this.encoder.call('encoder_set_flags', 4194304);
        }
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](parameters + 104)) {
            this.encoder.call('encoder_set_max_b_frame', cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](parameters + 104));
        }
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`open video decoder failed, ret: ${ret}`, cheap__fileName__13, 111);
        }
        await this.encoder.childrenThreadReady();
        this.parameters = parameters;
        this.timeBase = timeBase;
    }
    encode(frame, key) {
        if (!common_util_is__WEBPACK_IMPORTED_MODULE_6__.number(frame)) {
            if (this.avframe) {
                (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_7__.unrefAVFrame)(this.avframe);
            }
            else {
                this.avframe = (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_7__.createAVFrame)();
            }
            frame = (0,avutil_function_videoFrame2AVFrame__WEBPACK_IMPORTED_MODULE_8__.videoFrame2AVFrame)(frame, this.avframe);
        }
        if (key) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](frame + 88, 1 /* AVPictureType.AV_PICTURE_TYPE_I */);
        }
        let ret = this.encoder.call('encoder_encode', frame);
        if (ret) {
            return ret;
        }
        while (true) {
            ret = this.receiveAVPacket();
            if (ret === 1) {
                this.outputAVPacket();
            }
            else if (ret < 0) {
                return ret;
            }
            else {
                break;
            }
        }
        return 0;
    }
    async flush() {
        this.encoder.call('encoder_flush');
        while (1) {
            const ret = this.receiveAVPacket();
            if (ret < 1) {
                return;
            }
            this.outputAVPacket();
        }
    }
    getExtraData() {
        const pointer = this.encoder.call('encoder_get_extradata');
        const size = this.encoder.call('encoder_get_extradata_size');
        if (pointer && size) {
            return (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_9__.mapUint8Array)(pointer, size).slice();
        }
        return null;
    }
    getColorSpace() {
        return {
            colorSpace: this.encoder.call('encoder_get_color_space'),
            colorPrimaries: this.encoder.call('encoder_get_color_primaries'),
            colorTrc: this.encoder.call('encoder_get_color_trc')
        };
    }
    close() {
        this.encoder.call('encoder_close');
        this.encoder.destroy();
        this.encoder = null;
        if (this.avpacket) {
            this.options.avpacketPool
                ? this.options.avpacketPool.release(this.avpacket)
                : (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_1__.destroyAVPacket)(this.avpacket);
            this.avpacket = 0;
        }
        if (this.avframe) {
            (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_7__.destroyAVFrame)(this.avframe);
            this.avframe = 0;
        }
    }
}


/***/ }),

/***/ "./src/avcodec/webcodec/AudioDecoder.ts":
/*!**********************************************!*\
  !*** ./src/avcodec/webcodec/AudioDecoder.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebAudioDecoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _function_getAudioCodec__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/getAudioCodec */ "./src/avcodec/function/getAudioCodec.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_function_avpacket2EncodedAudioChunk__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/function/avpacket2EncodedAudioChunk */ "./src/avutil/function/avpacket2EncodedAudioChunk.ts");





class WebAudioDecoder {
    options;
    decoder;
    parameters;
    extradata;
    currentError;
    constructor(options) {
        this.options = options;
    }
    output(frame) {
        if (this.options.onReceiveFrame) {
            this.options.onReceiveFrame(frame);
        }
        else {
            frame.close();
        }
    }
    error(error) {
        this.currentError = error;
        this.options.onError(error);
    }
    async open(parameters) {
        this.currentError = null;
        this.parameters = parameters;
        this.extradata = null;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](parameters + 12) !== 0) {
            this.extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](parameters + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 16)).slice();
        }
        const config = {
            codec: (0,_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_2__["default"])(this.parameters),
            sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 136),
            numberOfChannels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](parameters + 116),
            description: this.extradata
        };
        if (!config.description) {
            // description 不是 arraybuffer 会抛错
            delete config.description;
        }
        const support = await AudioDecoder.isConfigSupported(config);
        if (!support.supported) {
            throw new Error('not support');
        }
        if (this.decoder && this.decoder.state !== 'closed') {
            this.decoder.close();
        }
        this.decoder = new AudioDecoder({
            output: this.output.bind(this),
            error: this.error.bind(this)
        });
        this.decoder.reset();
        this.decoder.configure(config);
        if (this.currentError) {
            throw this.currentError;
        }
    }
    changeExtraData(buffer) {
        if (buffer.length === this.extradata.length) {
            let same = true;
            for (let i = 0; i < buffer.length; i++) {
                if (buffer[i] !== this.extradata[i]) {
                    same = false;
                    break;
                }
            }
            if (same) {
                return;
            }
        }
        this.extradata = buffer.slice();
        this.decoder.reset();
        this.decoder.configure({
            codec: (0,_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_2__["default"])(this.parameters),
            sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.parameters + 136),
            numberOfChannels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](this.parameters + 116),
            description: this.extradata
        });
        if (this.currentError) {
            throw this.currentError;
        }
    }
    decode(avpacket, pts) {
        const element = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.getAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */);
        if (element !== 0) {
            this.changeExtraData((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](element), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](element + 4)));
        }
        const audioChunk = (0,avutil_function_avpacket2EncodedAudioChunk__WEBPACK_IMPORTED_MODULE_4__["default"])(avpacket, pts);
        try {
            this.decoder.decode(audioChunk);
        }
        catch (error) {
            return -1;
        }
        return 0;
    }
    async flush() {
        await this.decoder.flush();
    }
    close() {
        if (this.decoder.state !== 'closed') {
            this.decoder.close();
        }
        this.decoder = null;
    }
    getQueueLength() {
        return this.decoder.decodeQueueSize;
    }
}


/***/ }),

/***/ "./src/avcodec/webcodec/AudioEncoder.ts":
/*!**********************************************!*\
  !*** ./src/avcodec/webcodec/AudioEncoder.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebAudioEncoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var avcodec_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avcodec/function/getAudioCodec */ "./src/avcodec/function/getAudioCodec.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var avutil_function_avframe2AudioData__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/function/avframe2AudioData */ "./src/avutil/function/avframe2AudioData.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var avutil_function_encodedAudioChunk2AVPacket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/function/encodedAudioChunk2AVPacket */ "./src/avutil/function/encodedAudioChunk2AVPacket.ts");








class WebAudioEncoder {
    encoder;
    options;
    parameters;
    timeBase;
    currentError;
    pts;
    avframeCache;
    extradata;
    constructor(options) {
        this.options = options;
        this.avframeCache = [];
    }
    async output(chunk, metadata) {
        const avpacket = this.options.avpacketPool ? this.options.avpacketPool.alloc() : (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_0__.createAVPacket)();
        if (!this.extradata) {
            if (metadata?.decoderConfig?.description) {
                let buffer;
                if (metadata.decoderConfig.description instanceof ArrayBuffer) {
                    buffer = new Uint8Array(metadata.decoderConfig.description);
                }
                else {
                    buffer = new Uint8Array(metadata.decoderConfig.description.buffer);
                }
                this.extradata = buffer;
            }
            (0,avutil_function_encodedAudioChunk2AVPacket__WEBPACK_IMPORTED_MODULE_1__["default"])(chunk, avpacket);
        }
        else {
            (0,avutil_function_encodedAudioChunk2AVPacket__WEBPACK_IMPORTED_MODULE_1__["default"])(chunk, avpacket, metadata);
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avpacket + 8, this.pts);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avpacket + 16, this.pts);
        this.pts += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 48);
        const avframe = this.avframeCache.shift();
        this.options.onReceivePacket(avpacket, avframe);
    }
    error(error) {
        this.options.onError(error);
    }
    async open(parameters, timeBase) {
        this.currentError = null;
        const config = {
            codec: (0,avcodec_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_4__["default"])(parameters),
            sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](parameters + 136),
            numberOfChannels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](parameters + 116),
            bitrate: Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](parameters + 32)),
            bitrateMode: 'constant'
        };
        const support = await AudioEncoder.isConfigSupported(config);
        if (!support.supported) {
            throw new Error('not support');
        }
        if (this.encoder && this.encoder.state !== 'closed') {
            this.encoder.close();
        }
        this.encoder = new AudioEncoder({
            output: this.output.bind(this),
            error: this.error.bind(this)
        });
        this.encoder.reset();
        this.encoder.configure(config);
        if (this.currentError) {
            throw this.currentError;
        }
        this.pts = BigInt(0);
        this.parameters = parameters;
        this.timeBase = timeBase;
    }
    encode(frame) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_5__.number(frame)) {
            const cache = this.options.avframePool ? this.options.avframePool.alloc() : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_6__.createAVFrame)();
            (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_6__.refAVFrame)(cache, frame);
            this.avframeCache.push(cache);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](cache + 104, BigInt(0));
            frame = (0,avutil_function_avframe2AudioData__WEBPACK_IMPORTED_MODULE_7__.avframe2AudioData)(cache);
        }
        try {
            this.encoder.encode(frame);
            return 0;
        }
        catch (error) {
            return -1;
        }
    }
    async flush() {
        await this.encoder.flush();
    }
    close() {
        if (this.encoder) {
            if (this.encoder.state !== 'closed') {
                this.encoder.close();
            }
        }
        this.encoder = null;
    }
    getExtraData() {
        return this.extradata;
    }
    getQueueLength() {
        return this.encoder.encodeQueueSize;
    }
}


/***/ }),

/***/ "./src/avcodec/webcodec/VideoDecoder.ts":
/*!**********************************************!*\
  !*** ./src/avcodec/webcodec/VideoDecoder.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebVideoDecoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/* harmony import */ var _function_getVideoCodec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/getVideoCodec */ "./src/avcodec/function/getVideoCodec.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/getHardwarePreference */ "./src/avcodec/function/getHardwarePreference.ts");
/* harmony import */ var avutil_function_avpacket2EncodedVideoChunk__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/function/avpacket2EncodedVideoChunk */ "./src/avutil/function/avpacket2EncodedVideoChunk.ts");







class WebVideoDecoder {
    decoder;
    options;
    parameters;
    extradata;
    currentError;
    inputQueue;
    outputQueue;
    sort;
    keyframeRequire;
    constructor(options) {
        this.options = options;
        this.inputQueue = [];
        this.outputQueue = [];
        this.sort = common_util_browser__WEBPACK_IMPORTED_MODULE_0__["default"].safari;
    }
    async output(frame) {
        if (this.sort) {
            let i = 0;
            for (; i < this.outputQueue.length; i++) {
                if (this.outputQueue[i].timestamp > frame.timestamp) {
                    this.outputQueue.splice(i, 0, frame);
                    break;
                }
            }
            if (i === this.outputQueue.length) {
                this.outputQueue.push(frame);
            }
            while (this.outputQueue.length > 2
                && this.outputQueue[0].timestamp === this.inputQueue[0]) {
                const output = this.outputQueue.shift();
                if (this.options.onReceiveFrame) {
                    this.options.onReceiveFrame(output);
                }
                else {
                    output.close();
                }
                this.inputQueue.shift();
            }
        }
        else {
            if (this.options.onReceiveFrame) {
                this.options.onReceiveFrame(frame);
            }
            else {
                frame.close();
            }
        }
    }
    error(error) {
        this.currentError = error;
        this.options.onError(error);
    }
    changeExtraData(buffer) {
        if (buffer.length === this.extradata.length) {
            let same = true;
            for (let i = 0; i < buffer.length; i++) {
                if (buffer[i] !== this.extradata[i]) {
                    same = false;
                    break;
                }
            }
            if (same) {
                return;
            }
        }
        this.extradata = buffer.slice();
        this.decoder.reset();
        this.decoder.configure({
            codec: (0,_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_1__["default"])(this.parameters, buffer),
            description: this.extradata,
            hardwareAcceleration: (0,_function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_2__.getHardwarePreference)(this.options.enableHardwareAcceleration ?? true)
        });
        this.keyframeRequire = true;
    }
    async open(parameters) {
        this.currentError = null;
        this.extradata = null;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](parameters + 12) !== 0) {
            this.extradata = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](parameters + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](parameters + 16)).slice();
        }
        this.parameters = parameters;
        const config = {
            codec: (0,_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_1__["default"])(parameters),
            codedWidth: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](parameters + 56),
            codedHeight: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](parameters + 60),
            description: (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](parameters + 160) !== 2 /* BitFormat.ANNEXB */) ? this.extradata : undefined,
            hardwareAcceleration: (0,_function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_2__.getHardwarePreference)(this.options.enableHardwareAcceleration ?? true)
        };
        if (!config.description) {
            // description 不是 arraybuffer 会抛错
            delete config.description;
        }
        const support = await VideoDecoder.isConfigSupported(config);
        if (!support.supported) {
            throw new Error('not support');
        }
        if (this.decoder && this.decoder.state !== 'closed') {
            this.decoder.close();
        }
        this.decoder = new VideoDecoder({
            output: this.output.bind(this),
            error: this.error.bind(this)
        });
        this.decoder.reset();
        this.decoder.configure(config);
        if (this.currentError) {
            throw this.currentError;
        }
        this.keyframeRequire = true;
        this.inputQueue.length = 0;
        this.outputQueue.length = 0;
    }
    decode(avpacket) {
        const element = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_5__.getAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */);
        if (element !== 0) {
            this.changeExtraData((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](element), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](element + 4)));
        }
        const key = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */;
        if (this.keyframeRequire && !key) {
            return;
        }
        const timestamp = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](avpacket + 8));
        const videoChunk = (0,avutil_function_avpacket2EncodedVideoChunk__WEBPACK_IMPORTED_MODULE_6__["default"])(avpacket);
        if (this.sort) {
            let i = 0;
            for (; i < this.inputQueue.length; i++) {
                if (this.inputQueue[i] > timestamp) {
                    this.inputQueue.splice(i, 0, timestamp);
                    break;
                }
            }
            if (i === this.inputQueue.length) {
                this.inputQueue.push(timestamp);
            }
        }
        try {
            this.decoder.decode(videoChunk);
        }
        catch (error) {
            return -1;
        }
        if (key) {
            this.keyframeRequire = false;
        }
        return 0;
    }
    async flush() {
        await this.decoder.flush();
        if (this.sort) {
            while (this.outputQueue.length) {
                const frame = this.outputQueue.shift();
                if (this.options.onReceiveFrame) {
                    this.options.onReceiveFrame(frame);
                }
                else {
                    frame.close();
                }
            }
        }
        this.keyframeRequire = true;
    }
    close() {
        if (this.decoder && this.decoder.state !== 'closed') {
            this.decoder.close();
        }
        this.decoder = null;
        this.currentError = null;
        if (this.outputQueue?.length) {
            this.outputQueue.forEach((frame) => {
                frame.close();
            });
        }
        this.inputQueue = null;
        this.outputQueue = null;
    }
    getQueueLength() {
        return this.decoder.decodeQueueSize;
    }
    setSkipFrameDiscard(discard) {
    }
}


/***/ }),

/***/ "./src/avcodec/webcodec/VideoEncoder.ts":
/*!**********************************************!*\
  !*** ./src/avcodec/webcodec/VideoEncoder.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebVideoEncoder)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../avutil/struct/rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _function_getVideoCodec__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../function/getVideoCodec */ "./src/avcodec/function/getVideoCodec.ts");
/* harmony import */ var _function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../function/getHardwarePreference */ "./src/avcodec/function/getHardwarePreference.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var avutil_function_avframe2VideoFrame__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! avutil/function/avframe2VideoFrame */ "./src/avutil/function/avframe2VideoFrame.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var avutil_function_encodedVideoChunk2AVPacket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/function/encodedVideoChunk2AVPacket */ "./src/avutil/function/encodedVideoChunk2AVPacket.ts");
/* harmony import */ var avutil_function_videoFrame2AVFrame__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/function/videoFrame2AVFrame */ "./src/avutil/function/videoFrame2AVFrame.ts");
/* harmony import */ var avformat_codecs_av1__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avformat/codecs/av1 */ "./src/avformat/codecs/av1.ts");
/* harmony import */ var avformat_codecs_vp9__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avformat/codecs/vp9 */ "./src/avformat/codecs/vp9.ts");

















class WebVideoEncoder {
    encoder;
    options;
    parameters;
    timeBase;
    currentError;
    avframeMap;
    framerate;
    inputCounter;
    outputCounter;
    extradata;
    constructor(options) {
        this.options = options;
        this.avframeMap = new Map();
    }
    async output(chunk, metadata) {
        const inputCounter = BigInt(Math.floor(chunk.timestamp));
        const pts = inputCounter * BigInt(1000000) / this.framerate;
        const dts = BigInt.asIntN(64, this.outputCounter++) * BigInt(1000000) / this.framerate;
        const avpacket = this.options.avpacketPool ? this.options.avpacketPool.alloc() : (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_0__.createAVPacket)();
        if (!this.extradata) {
            if (metadata?.decoderConfig?.description) {
                let buffer;
                if (metadata.decoderConfig.description instanceof ArrayBuffer) {
                    buffer = new Uint8Array(metadata.decoderConfig.description);
                }
                else {
                    buffer = new Uint8Array(metadata.decoderConfig.description.buffer);
                }
                this.extradata = buffer;
            }
            if (metadata?.decoderConfig?.colorSpace) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.parameters + 96, (0,avutil_function_videoFrame2AVFrame__WEBPACK_IMPORTED_MODULE_2__.mapColorSpace)(metadata.decoderConfig.colorSpace.matrix));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.parameters + 88, (0,avutil_function_videoFrame2AVFrame__WEBPACK_IMPORTED_MODULE_2__.mapColorPrimaries)(metadata.decoderConfig.colorSpace.primaries));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](this.parameters + 92, (0,avutil_function_videoFrame2AVFrame__WEBPACK_IMPORTED_MODULE_2__.mapColorTrc)(metadata.decoderConfig.colorSpace.transfer));
            }
            (0,avutil_function_encodedVideoChunk2AVPacket__WEBPACK_IMPORTED_MODULE_3__["default"])(chunk, avpacket);
            if (!this.extradata) {
                let extradata;
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](this.parameters + 4) === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                    extradata = avformat_codecs_av1__WEBPACK_IMPORTED_MODULE_5__.generateExtradata(this.parameters, (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_0__.getAVPacketData)(avpacket));
                }
                else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](this.parameters + 4) === 167 /* AVCodecID.AV_CODEC_ID_VP9 */) {
                    extradata = avformat_codecs_vp9__WEBPACK_IMPORTED_MODULE_6__.generateExtradata(this.parameters);
                }
                if (extradata) {
                    this.extradata = extradata;
                }
            }
        }
        else {
            (0,avutil_function_encodedVideoChunk2AVPacket__WEBPACK_IMPORTED_MODULE_3__["default"])(chunk, avpacket, metadata);
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avpacket + 8, pts);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avpacket + 16, dts);
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](this.parameters + 4) === 27 /* AVCodecID.AV_CODEC_ID_H264 */
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](this.parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](this.parameters + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avpacket + 80, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](this.parameters + 160));
        }
        const avframe = this.avframeMap.get(inputCounter);
        this.options.onReceivePacket(avpacket, avframe);
        this.avframeMap.delete(inputCounter);
    }
    error(error) {
        this.currentError = error;
        this.options.onError(error);
    }
    async open(parameters, timeBase) {
        this.currentError = null;
        const descriptor = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_7__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 28)];
        const config = {
            codec: (0,_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_8__["default"])(parameters),
            width: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 56),
            height: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 60),
            bitrate: Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](parameters + 32)),
            framerate: (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_9__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_10__["default"])(parameters + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_11__.Rational)),
            hardwareAcceleration: (0,_function_getHardwarePreference__WEBPACK_IMPORTED_MODULE_12__.getHardwarePreference)(this.options.enableHardwareAcceleration ?? true),
            latencyMode: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 104) ? 'quality' : 'realtime',
            alpha: descriptor && (descriptor.flags & 128 /* PixelFormatFlags.ALPHA */) ? 'keep' : 'discard'
        };
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 27 /* AVCodecID.AV_CODEC_ID_H264 */
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */) {
            config.avc = {
                format: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 160) === 1 /* BitFormat.AVCC */ ? 'avc' : 'annexb'
            };
        }
        const support = await VideoEncoder.isConfigSupported(config);
        if (!support.supported) {
            throw new Error('not support');
        }
        if (this.encoder && this.encoder.state !== 'closed') {
            this.encoder.close();
        }
        this.encoder = new VideoEncoder({
            output: this.output.bind(this),
            error: this.error.bind(this)
        });
        this.encoder.reset();
        this.encoder.configure(config);
        if (this.currentError) {
            throw this.currentError;
        }
        this.parameters = parameters;
        this.timeBase = timeBase;
        this.inputCounter = BigInt(0);
        this.outputCounter = BigInt(0);
        this.framerate = BigInt(Math.floor((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_9__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_10__["default"])(parameters + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_11__.Rational))));
    }
    encode(frame, key) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(frame)) {
            const cache = this.options.avframePool ? this.options.avframePool.alloc() : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_14__.createAVFrame)();
            (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_14__.refAVFrame)(cache, frame);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](cache + 104, this.inputCounter);
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](cache + 312)) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](cache + 312, (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_9__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](cache + 312), this.timeBase, avutil_constant__WEBPACK_IMPORTED_MODULE_15__.AV_TIME_BASE_Q));
            }
            else {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](cache + 312, BigInt(1000000) / this.framerate);
            }
            this.avframeMap.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](cache + 104), cache);
            frame = (0,avutil_function_avframe2VideoFrame__WEBPACK_IMPORTED_MODULE_16__.avframe2VideoFrame)(cache);
        }
        else {
            frame = new VideoFrame(frame, {
                timestamp: Number(this.inputCounter),
                duration: Number(BigInt(1000000) / this.framerate)
            });
        }
        try {
            this.encoder.encode(frame, {
                keyFrame: key
            });
            frame.close();
            this.inputCounter++;
            return 0;
        }
        catch (error) {
            return -1;
        }
    }
    async flush() {
        await this.encoder.flush();
    }
    close() {
        if (this.encoder) {
            if (this.encoder.state !== 'closed') {
                this.encoder.close();
            }
        }
        this.encoder = null;
    }
    getExtraData() {
        return this.extradata;
    }
    getColorSpace() {
        return {
            colorSpace: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](this.parameters + 96),
            colorPrimaries: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](this.parameters + 88),
            colorTrc: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](this.parameters + 92),
        };
    }
    getQueueLength() {
        return this.encoder.encodeQueueSize;
    }
}


/***/ }),

/***/ "./src/avfilter/AVFilterNode.ts":
/*!**************************************!*\
  !*** ./src/avfilter/AVFilterNode.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVFilterNodePort: () => (/* binding */ AVFilterNodePort),
/* harmony export */   "default": () => (/* binding */ AVFilterNode)
/* harmony export */ });
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/*
 * libmedia AVFilter
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




class AVFilterNodePort extends common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"] {
    channel;
    next;
    constructor(channel) {
        super(channel instanceof MessageChannel ? channel.port1 : channel);
        this.channel = channel;
    }
    connect(port) {
        this.off();
        port.off();
        this.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.REQUEST, async (request) => {
            try {
                const result = await port.request(request.method, request.params);
                this.reply(request, result, null, (common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(result) || request.method !== 'pull') ? null : [result]);
            }
            catch (error) {
                this.reply(request, null, error);
            }
        });
        this.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.NOTIFY, (message) => {
            port.notify(message.method, message.params);
        });
        port.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.REQUEST, async (request) => {
            try {
                const result = await this.request(request.method, request.params);
                port.reply(request, result, null, (common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(result) || request.method !== 'pull') ? null : [result]);
            }
            catch (error) {
                port.reply(request, null, error);
            }
        });
        port.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.NOTIFY, (message) => {
            this.notify(message.method, message.params);
        });
        this.next = port;
    }
    disconnect() {
        this.off();
        if (this.next) {
            this.next.off();
        }
        this.next = null;
    }
    getInnerPort() {
        if (this.channel instanceof MessageChannel) {
            return this.channel.port2;
        }
    }
}
class AVFilterNode {
    options;
    inputAVFilterNodePort;
    outputAVFilterNodePort;
    inputInnerNodePort;
    outputInnerNodePort;
    currentOutput;
    consumedCount;
    pending;
    inputCount;
    outputCount;
    inputConnectedMap;
    outputConnectedMap;
    constructor(options, inputCount, outputCount) {
        this.options = options;
        this.inputCount = inputCount;
        this.outputCount = outputCount;
        this.inputAVFilterNodePort = [];
        this.outputAVFilterNodePort = [];
        this.inputInnerNodePort = [];
        this.outputInnerNodePort = [];
        for (let i = 0; i < this.inputCount; i++) {
            const port = new AVFilterNodePort(new MessageChannel());
            this.inputAVFilterNodePort.push(port);
            this.inputInnerNodePort.push(new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](port.getInnerPort()));
        }
        for (let i = 0; i < this.outputCount; i++) {
            const port = new AVFilterNodePort(new MessageChannel());
            this.outputAVFilterNodePort.push(port);
            this.outputInnerNodePort.push(new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__["default"](port.getInnerPort()));
        }
        this.consumedCount = 0;
        this.pending = [];
        this.currentOutput = [];
        for (let i = 0; i < this.outputCount; i++) {
            this.handlePull(this.outputInnerNodePort[i], i);
        }
        this.inputConnectedMap = new Map();
        this.outputConnectedMap = new Map();
    }
    handlePull(port, index) {
        port.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_0__.REQUEST, async (request) => {
            switch (request.method) {
                case 'pull': {
                    if (this.consumedCount === 0) {
                        const input = [];
                        this.currentOutput.length = 0;
                        for (let i = 0; i < this.inputCount; i++) {
                            input.push(await this.inputInnerNodePort[i].request('pull'));
                        }
                        await this.process(input, this.currentOutput);
                        input.forEach((frame) => {
                            if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(frame)) {
                                if (frame > 0) {
                                    this.options.avframePool ? this.options.avframePool.release(frame) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_2__.destroyAVFrame)(frame);
                                }
                            }
                            else {
                                frame.close();
                            }
                        });
                        port.reply(request, this.currentOutput[index], null, common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(this.currentOutput[index]) ? null : [this.currentOutput[index]]);
                        this.consumedCount++;
                        if (this.pending.length) {
                            this.pending.forEach((item) => {
                                item.resolve();
                            });
                            this.pending.length = 0;
                        }
                        if (this.consumedCount === this.outputCount) {
                            this.consumedCount = 0;
                            this.currentOutput.length = 0;
                        }
                    }
                    else if (this.consumedCount === this.outputCount - 1) {
                        port.reply(request, this.currentOutput[index], null, common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(this.currentOutput[index]) ? null : [this.currentOutput[index]]);
                        this.consumedCount = 0;
                        this.currentOutput.length = 0;
                    }
                    else {
                        await new Promise((resolve, reject) => {
                            this.pending.push({
                                resolve,
                                reject
                            });
                        });
                        port.reply(request, this.currentOutput[index], null, common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(this.currentOutput[index]) ? null : [this.currentOutput[index]]);
                        this.consumedCount++;
                    }
                }
            }
        });
    }
    getInputNodePort(index) {
        return this.inputAVFilterNodePort[index];
    }
    getOutputNodePort(index) {
        return this.outputAVFilterNodePort[index];
    }
    getInputCount() {
        return this.inputCount;
    }
    getOutputCount() {
        return this.outputCount;
    }
    getFreeInputNodePort() {
        const used = [];
        this.inputConnectedMap.forEach((index, node) => {
            used.push(index);
        });
        for (let i = 0; i < this.inputCount; i++) {
            if (!common_util_array__WEBPACK_IMPORTED_MODULE_3__.has(used, i)) {
                return {
                    index: i,
                    port: this.getInputNodePort(i)
                };
            }
        }
    }
    getFreeOutputNodePort() {
        const used = [];
        this.outputConnectedMap.forEach((index, node) => {
            used.push(index);
        });
        for (let i = 0; i < this.outputCount; i++) {
            if (!common_util_array__WEBPACK_IMPORTED_MODULE_3__.has(used, i)) {
                return {
                    index: i,
                    port: this.getOutputNodePort(i)
                };
            }
        }
    }
    addInputPeer(node, index) {
        this.inputConnectedMap.set(node, index);
    }
    removeInputPeer(node) {
        this.inputConnectedMap.delete(node);
    }
    addOutputPeer(node, index) {
        this.outputConnectedMap.set(node, index);
    }
    removeOutputPeer(node) {
        this.outputConnectedMap.delete(node);
    }
    connect(node) {
        if (this.outputConnectedMap.size === this.outputCount) {
            throw new Error('all output has connected');
        }
        const output = this.getFreeOutputNodePort();
        const nextInput = node.getFreeInputNodePort();
        if (!nextInput) {
            throw new Error('next node all input has connected');
        }
        output.port.connect(nextInput.port);
        this.outputConnectedMap.set(node, output.index);
        node.addInputPeer(this, nextInput.index);
    }
    disconnectNode(node) {
        if (!this.outputConnectedMap.has(node)) {
            return;
        }
        this.outputAVFilterNodePort[this.outputConnectedMap.get(node)].disconnect();
        this.outputConnectedMap.delete(node);
        if (node instanceof AVFilterNode) {
            node.removeInputPeer(this);
        }
    }
    disconnect(node) {
        if (node) {
            return this.disconnectNode(node);
        }
        this.outputConnectedMap.forEach((index, node) => {
            this.disconnectNode(node);
        });
    }
}


/***/ }),

/***/ "./src/avfilter/RangeFilterNode.ts":
/*!*****************************************!*\
  !*** ./src/avfilter/RangeFilterNode.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RangeFilterNode)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _AVFilterNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AVFilterNode */ "./src/avfilter/AVFilterNode.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");




class RangeFilterNode extends _AVFilterNode__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(options) {
        super(options, 1, 1);
    }
    async ready() {
    }
    async destroy() {
    }
    async process(inputs, outputs) {
        let avframe = inputs[0];
        if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(avframe) && avframe < 0) {
            outputs[0] = avframe;
            return;
        }
        let pts = common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(avframe) ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avframe + 104) : BigInt(Math.floor(avframe.timestamp));
        if (pts < this.options.start) {
            while (true) {
                const next = await this.inputInnerNodePort[0].request('pull');
                if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(next) && next < 0) {
                    outputs[0] = next;
                    return;
                }
                pts = common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(next) ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](next + 104) : BigInt(Math.floor(next.timestamp));
                if (pts >= this.options.start) {
                    outputs[0] = next;
                    return;
                }
                else {
                    if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(next)) {
                        this.options.avframePool ? this.options.avframePool.release(next) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_3__.destroyAVFrame)(next);
                    }
                    else {
                        next.close();
                    }
                }
            }
        }
        else if (pts > this.options.end && this.options.end >= this.options.start) {
            outputs[0] = -1048576 /* IOError.END */;
            return;
        }
        else {
            if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(avframe)) {
                const out = this.options.avframePool ? this.options.avframePool.alloc() : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_3__.createAVFrame)();
                (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_3__.refAVFrame)(out, avframe);
                outputs[0] = out;
            }
            else {
                outputs[0] = avframe.clone();
            }
        }
    }
}


/***/ }),

/***/ "./src/avfilter/audio/ResampleFilterNode.ts":
/*!**************************************************!*\
  !*** ./src/avfilter/audio/ResampleFilterNode.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ResampleFilterNode)
/* harmony export */ });
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var audioresample_Resampler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! audioresample/Resampler */ "./src/audioresample/Resampler.ts");
/* harmony import */ var _AVFilterNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AVFilterNode */ "./src/avfilter/AVFilterNode.ts");
/* harmony import */ var avutil_struct_avframe__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/struct/avframe */ "./src/avutil/struct/avframe.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var avutil_util_sample__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/util/sample */ "./src/avutil/util/sample.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var avutil_util_avbuffer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avutil/util/avbuffer */ "./src/avutil/util/avbuffer.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");















class ResampleFilterNode extends _AVFilterNode__WEBPACK_IMPORTED_MODULE_0__["default"] {
    resampler;
    pcm;
    constructor(options) {
        super(options, 1, 1);
    }
    async ready() {
        this.pcm = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_1__.avMallocz)(40);
    }
    async destroy() {
        if (this.pcm) {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](this.pcm)) {
                (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_1__.avFreep)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](this.pcm));
                (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_1__.avFreep)(this.pcm);
            }
            (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_1__.avFree)(this.pcm);
        }
        if (this.resampler) {
            this.resampler.close();
            this.resampler = null;
        }
    }
    async process(inputs, outputs) {
        const avframe = inputs[0];
        if (avframe < 0) {
            outputs[0] = avframe;
            return;
        }
        const out = this.options.avframePool ? this.options.avframePool.alloc() : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_3__.createAVFrame)();
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avframe + 152) !== this.options.output.sampleRate
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avframe + 292) !== this.options.output.channels
            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avframe + 80) !== this.options.output.format && this.options.output.format !== avutil_constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE) {
            if (this.resampler) {
                const currentInput = this.resampler.getInputPCMParameters();
                if (currentInput.channels !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avframe + 292)
                    || currentInput.sampleRate !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avframe + 152)
                    || currentInput.format !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avframe + 80)) {
                    this.resampler.close();
                    this.resampler = null;
                }
            }
            if (!this.resampler) {
                this.resampler = new audioresample_Resampler__WEBPACK_IMPORTED_MODULE_5__["default"]({
                    resource: this.options.resource
                });
                await this.resampler.open({
                    channels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avframe + 292),
                    sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avframe + 152),
                    format: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avframe + 80)
                }, {
                    channels: this.options.output.channels,
                    sampleRate: this.options.output.sampleRate,
                    format: this.options.output.format === avutil_constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avframe + 80) : this.options.output.format
                });
            }
            this.resampler.resample(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](avframe + 64), this.pcm, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avframe + 76));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[15](out + 80, this.options.output.format === avutil_constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avframe + 80) : this.options.output.format);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[15](out + 76, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](this.pcm + 8));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[15](out + 152, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](this.pcm + 20));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[15](out + 292, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](this.pcm + 16));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[15](out + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](this.pcm + 4));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[17](out + 104, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avframe + 104));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[17](out + 312, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avframe + 312));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[17](out + 112, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avframe + 112));
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.memcpy)(out + 120, avframe + 120, 8);
            const planar = (0,avutil_util_sample__WEBPACK_IMPORTED_MODULE_8__.sampleFormatIsPlanar)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](out + 80));
            const planes = planar ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](out + 292) : 1;
            if (planes > avutil_struct_avframe__WEBPACK_IMPORTED_MODULE_9__.AV_NUM_DATA_POINTERS) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[20](out + 64, (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_1__.avMalloc)(planes * 4));
                if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](out + 64)) {
                    (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_1__.avFreep)(out + 64);
                    outputs[0] = avutil_error__WEBPACK_IMPORTED_MODULE_10__.NO_MEMORY;
                    return;
                }
            }
            else {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[20](out + 64, out);
            }
            for (let i = 0; i < Math.min(planes, avutil_struct_avframe__WEBPACK_IMPORTED_MODULE_9__.AV_NUM_DATA_POINTERS); i++) {
                if (i === 0) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[20](out + 156 + i * 4, (0,avutil_util_avbuffer__WEBPACK_IMPORTED_MODULE_11__.avbufferCreate)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](this.pcm) + i), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](this.pcm + 4) * (planar ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](this.pcm + 16) : 1)));
                    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](out + 156 + 4 * (i))) {
                        (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_3__.unrefAVFrame)(out);
                        outputs[0] = avutil_error__WEBPACK_IMPORTED_MODULE_10__.NO_MEMORY;
                        return;
                    }
                }
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](out + 64) + (i * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](this.pcm) + (i * 4))), cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[20](out + i * 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](this.pcm) + (i * 4)));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](this.pcm) + (i * 4), 0);
            }
            for (let i = 0; i < planes - avutil_struct_avframe__WEBPACK_IMPORTED_MODULE_9__.AV_NUM_DATA_POINTERS; i++) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](out + 64) + (i + avutil_struct_avframe__WEBPACK_IMPORTED_MODULE_9__.AV_NUM_DATA_POINTERS), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](this.pcm) + (i * 4)));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](this.pcm) + (i * 4), 0);
            }
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumWrite[15](this.pcm + 12, 0);
            outputs[0] = out;
        }
        else {
            (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_3__.refAVFrame)(out, avframe);
            outputs[0] = out;
        }
    }
}


/***/ }),

/***/ "./src/avfilter/video/FramerateFilterNode.ts":
/*!***************************************************!*\
  !*** ./src/avfilter/video/FramerateFilterNode.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FramerateFilterNode)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _AVFilterNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AVFilterNode */ "./src/avfilter/AVFilterNode.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");






class FramerateFilterNode extends _AVFilterNode__WEBPACK_IMPORTED_MODULE_0__["default"] {
    lastPts;
    delta;
    timeBase;
    step;
    constructor(options) {
        super(options, 1, 1);
    }
    async ready() {
        this.lastPts = -BigInt(1);
        this.delta = BigInt(0);
        this.timeBase = avutil_constant__WEBPACK_IMPORTED_MODULE_1__.AV_TIME_BASE_Q;
        this.step = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)(BigInt(1), {
            den: this.options.framerate.num,
            num: this.options.framerate.den
        }, this.timeBase);
    }
    async destroy() {
    }
    async process(inputs, outputs) {
        let avframe = inputs[0];
        if (common_util_is__WEBPACK_IMPORTED_MODULE_3__.number(avframe) && avframe < 0) {
            outputs[0] = avframe;
            return;
        }
        let pts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)(common_util_is__WEBPACK_IMPORTED_MODULE_3__.number(avframe) ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avframe + 104) : BigInt(Math.floor(avframe.timestamp)), this.options.timeBase, this.timeBase);
        let diff = pts - this.lastPts + this.delta;
        if (diff < this.step && this.lastPts > -BigInt(1)) {
            while (true) {
                const next = await this.inputInnerNodePort[0].request('pull');
                if (common_util_is__WEBPACK_IMPORTED_MODULE_3__.number(next) && next < 0) {
                    outputs[0] = next;
                    return;
                }
                pts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avRescaleQ)(common_util_is__WEBPACK_IMPORTED_MODULE_3__.number(next) ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](next + 104) : BigInt(Math.floor(next.timestamp)), this.options.timeBase, this.timeBase);
                diff = pts - this.lastPts;
                if (diff >= this.step) {
                    this.delta += diff - this.step;
                    this.lastPts = pts;
                    outputs[0] = next;
                    return;
                }
                else {
                    if (common_util_is__WEBPACK_IMPORTED_MODULE_3__.number(next)) {
                        this.options.avframePool ? this.options.avframePool.release(next) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_5__.destroyAVFrame)(next);
                    }
                    else {
                        next.close();
                    }
                }
            }
        }
        else {
            this.delta = diff - this.step;
            this.lastPts = pts;
            if (common_util_is__WEBPACK_IMPORTED_MODULE_3__.number(avframe)) {
                const out = this.options.avframePool ? this.options.avframePool.alloc() : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_5__.createAVFrame)();
                (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_5__.refAVFrame)(out, avframe);
                outputs[0] = out;
            }
            else {
                outputs[0] = avframe.clone();
            }
        }
    }
}


/***/ }),

/***/ "./src/avfilter/video/ScaleFilterNode.ts":
/*!***********************************************!*\
  !*** ./src/avfilter/video/ScaleFilterNode.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ScaleFilterNode)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _AVFilterNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AVFilterNode */ "./src/avfilter/AVFilterNode.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var videoscale_VideoScaler__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! videoscale/VideoScaler */ "./src/videoscale/VideoScaler.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var avutil_function_videoFrame2AVFrame__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/function/videoFrame2AVFrame */ "./src/avutil/function/videoFrame2AVFrame.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");







class ScaleFilterNode extends _AVFilterNode__WEBPACK_IMPORTED_MODULE_0__["default"] {
    scaler;
    constructor(options) {
        super(options, 1, 1);
    }
    async ready() {
    }
    async destroy() {
        if (this.scaler) {
            this.scaler.close();
            this.scaler = null;
        }
    }
    async process(inputs, outputs) {
        let avframe = inputs[0];
        if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(avframe) && avframe < 0) {
            outputs[0] = avframe;
            return;
        }
        const width = common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(avframe) ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avframe + 68) : avframe.displayWidth;
        const height = common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(avframe) ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avframe + 72) : avframe.displayHeight;
        const format = common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(avframe) ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avframe + 80) : (0,avutil_function_videoFrame2AVFrame__WEBPACK_IMPORTED_MODULE_3__.mapFormat)(avframe.format);
        if (width !== this.options.output.width
            || height !== this.options.output.height
            || format !== this.options.output.format && this.options.output.format !== avutil_constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE) {
            const out = this.options.avframePool ? this.options.avframePool.alloc() : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_5__.createAVFrame)();
            if (this.scaler) {
                const currentInput = this.scaler.getInputScaleParameters();
                if (currentInput.width !== width
                    || currentInput.height !== height
                    || currentInput.format !== format) {
                    this.scaler.close();
                    this.scaler = null;
                }
            }
            if (!this.scaler) {
                this.scaler = new videoscale_VideoScaler__WEBPACK_IMPORTED_MODULE_6__["default"]({
                    resource: this.options.resource
                });
                await this.scaler.open({
                    width,
                    height,
                    format
                }, {
                    width: this.options.output.width,
                    height: this.options.output.height,
                    format: this.options.output.format !== avutil_constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE
                        ? this.options.output.format
                        : (format === 23 /* AVPixelFormat.AV_PIX_FMT_NV12 */ && !common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(avframe)
                            ? 0 /* AVPixelFormat.AV_PIX_FMT_YUV420P */
                            : format)
                });
            }
            if (!common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(avframe)) {
                avframe = (0,avutil_function_videoFrame2AVFrame__WEBPACK_IMPORTED_MODULE_3__.videoFrame2AVFrame)(inputs[0], this.options.avframePool ? this.options.avframePool.alloc() : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_5__.createAVFrame)());
            }
            this.scaler.scale(avframe, out);
            outputs[0] = out;
            if (!common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(inputs[0])) {
                this.options.avframePool ? this.options.avframePool.release(avframe) : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_5__.destroyAVFrame)(avframe);
            }
        }
        else {
            if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.number(avframe)) {
                const out = this.options.avframePool ? this.options.avframePool.alloc() : (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_5__.createAVFrame)();
                (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_5__.refAVFrame)(out, avframe);
                outputs[0] = out;
            }
            else {
                outputs[0] = avframe.clone();
            }
        }
    }
}


/***/ }),

/***/ "./src/avformat/AVFormatContext.ts":
/*!*****************************************!*\
  !*** ./src/avformat/AVFormatContext.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createAVIFormatContext: () => (/* binding */ createAVIFormatContext),
/* harmony export */   createAVOFormatContext: () => (/* binding */ createAVOFormatContext)
/* harmony export */ });
/* harmony import */ var _AVStream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AVStream */ "./src/avformat/AVStream.ts");
/*
 * libmedia AVFormatContext
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class AVFormatContextInterval {
    packetBuffer;
    constructor() {
        this.packetBuffer = [];
    }
}
class AVFormatContext {
    metadataHeaderPadding = -1;
    metadata;
    streams;
    options;
    privateData;
    processPrivateData;
    format;
    iformat;
    oformat;
    // @ts-ignore
    ioReader;
    ioWriter;
    errorFlag;
    interval;
    streamIndex;
    getDecoderResource = null;
    constructor() {
        this.streams = [];
        this.errorFlag = 0;
        this.streamIndex = 0;
        this.interval = new AVFormatContextInterval();
        this.options = {};
        this.privateData = {};
        this.metadata = {};
        this.format = -1 /* AVFormat.UNKNOWN */;
    }
    getStreamById(id) {
        return this.streams.find((stream) => stream.id === id);
    }
    getStreamByIndex(index) {
        return this.streams.find((stream) => stream.index === index);
    }
    getStreamByMediaType(mediaType) {
        return this.streams.find((stream) => stream.codecpar?.codecType === mediaType);
    }
    createStream() {
        const stream = new _AVStream__WEBPACK_IMPORTED_MODULE_0__["default"]();
        stream.index = this.streamIndex++;
        stream.id = stream.index;
        this.removeStreamByIndex(stream.index);
        this.streams.push(stream);
        return stream;
    }
    addStream(stream) {
        this.removeStreamByIndex(stream.index);
        this.streams.push(stream);
    }
    removeStream(stream) {
        this.removeStreamByIndex(stream.index);
    }
    removeStreamById(id) {
        const index = this.streams.findIndex((stream) => stream.id === id);
        if (index > -1) {
            const st = this.streams.splice(index, 1);
            if (st[0]) {
                st[0].destroy();
            }
        }
    }
    removeStreamByIndex(i) {
        const index = this.streams.findIndex((stream) => stream.index === i);
        if (index > -1) {
            const st = this.streams.splice(index, 1);
            if (st[0]) {
                st[0].destroy();
            }
        }
    }
    destroy() {
        if (this.oformat) {
            this.oformat.destroy(this);
        }
        if (this.iformat) {
            this.iformat.destroy(this);
        }
        this.streams.forEach((stream) => {
            stream.destroy();
        });
        this.streams = [];
        this.interval = null;
        this.ioReader = this.ioWriter = null;
        this.oformat = this.iformat = null;
    }
}
/**
 * 创建 AVIFormatContext
 *
 * @returns
 */
function createAVIFormatContext() {
    return new AVFormatContext();
}
/**
 * 创建 AVOFormatContext
 *
 * @returns
 */
function createAVOFormatContext() {
    return new AVFormatContext();
}


/***/ }),

/***/ "./src/avformat/AVStream.ts":
/*!**********************************!*\
  !*** ./src/avformat/AVStream.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVStream)
/* harmony export */ });
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var avutil_struct_avcodecparameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/struct/avcodecparameters */ "./src/avutil/struct/avcodecparameters.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var avutil_struct_rational__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/struct/rational */ "./src/avutil/struct/rational.ts");





/**
 * from FFmpeg
 *
 */
class AVStream {
    /**
     * stream index in AVFormatContext
     */
    index = avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    /**
     * Format-specific stream ID.
     * decoding: set by libavformat
     * encoding: set by the user, replaced by libavformat if left unset
     */
    id = avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    privData = null;
    codecpar = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_1__["default"])(avutil_struct_avcodecparameters__WEBPACK_IMPORTED_MODULE_2__["default"], new avutil_struct_avcodecparameters__WEBPACK_IMPORTED_MODULE_2__["default"]());
    /**
     * An array of side data that applies to the whole stream (i.e. the
     * container does not allow it to change between packets).
     *
     * There may be no overlap between the side data in this array and side data
     * in the packets. I.e. a given side data is either exported by the muxer
     * (demuxing) / set by the caller (muxing) in this array, then it never
     * appears in the packets, or the side data is exported / sent through
     * the packets (always in the first packet where the value becomes known or
     * changes), then it does not appear in this array.
     *
     * - demuxing: Set by libavformat when the stream is created.
     * - muxing: May be set by the caller before write_header().
     *
     */
    sideData = {};
    /**
     * number of frames in this stream if known or 0
     */
    nbFrames = BigInt(0);
    metadata = {};
    /**
     * Decoding: duration of the stream, in stream time base.
     * If a source file does not specify a duration, but does specify
     * a bitrate, this value will be estimated from bitrate and file size.
     *
     * Encoding: May be set by the caller before avformat_write_header() to
     * provide a hint to the muxer about the estimated duration.
     */
    duration = avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE_BIGINT;
    /**
     * Decoding: pts of the first frame of the stream in presentation order, in stream time base.
     * Only set this if you are absolutely 100% sure that the value you set
     * it to really is the pts of the first frame.
     * This may be undefined (AV_NOPTS_VALUE).
     * @note The ASF header does NOT contain a correct start_time the ASF
     * demuxer must NOT set this.
     */
    startTime = avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE_BIGINT;
    /**
     * 第一个 packet 的 dts
     */
    firstDTS = BigInt(0);
    /**
     * AV_DISPOSITION_* bit field
     */
    disposition = 0 /* AVDisposition.NONE */;
    /**
     *
     * 封装时间基
     *
     * decoding: set by libavformat
     * encoding: May be set by the caller before avformat_write_header() to
     *           provide a hint to the muxer about the desired timebase. In
     *           avformat_write_header(), the muxer will overwrite this field
     *           with the timebase that will actually be used for the timestamps
     *           written into the file (which may or may not be related to the
     *           user-provided one, depending on the format).
     */
    timeBase = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_1__["default"])(avutil_struct_rational__WEBPACK_IMPORTED_MODULE_3__.Rational);
    /**
     * 帧索引，可用于 seek
     */
    sampleIndexes = [];
    /**
     * pos 到 sample index 的映射
     */
    sampleIndexesPosMap = new Map();
    destroy() {
        if (this.codecpar) {
            this.codecpar.destroy();
            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_4__["default"])(this.codecpar);
            this.codecpar = null;
        }
        if (this.timeBase) {
            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_4__["default"])(this.timeBase);
            this.timeBase = null;
        }
        this.sampleIndexes.length = 0;
        this.sampleIndexesPosMap.clear();
    }
}


/***/ }),

/***/ "./src/avformat/codecs/aac.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/aac.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AACProfile2Name: () => (/* binding */ AACProfile2Name),
/* harmony export */   MPEG4Channels: () => (/* binding */ MPEG4Channels),
/* harmony export */   MPEG4SamplingFrequencies: () => (/* binding */ MPEG4SamplingFrequencies),
/* harmony export */   MPEG4SamplingFrequencyIndex: () => (/* binding */ MPEG4SamplingFrequencyIndex),
/* harmony export */   avCodecParameters2Extradata: () => (/* binding */ avCodecParameters2Extradata),
/* harmony export */   getAVCodecParameters: () => (/* binding */ getAVCodecParameters),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/*
 * libmedia aac util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

const AACProfile2Name = {
    [1 /* MPEG4AudioObjectTypes.AAC_MAIN */]: 'Main',
    [2 /* MPEG4AudioObjectTypes.AAC_LC */]: 'LC',
    [3 /* MPEG4AudioObjectTypes.AAC_SSR */]: 'LC',
    [4 /* MPEG4AudioObjectTypes.AAC_LTP */]: 'LC',
    [5 /* MPEG4AudioObjectTypes.AAC_SBR */]: 'HE',
    [6 /* MPEG4AudioObjectTypes.AAC_SCALABLE */]: 'HE'
};
const MPEG4SamplingFrequencyIndex = {
    96000: 0,
    88200: 1,
    64000: 2,
    48000: 3,
    44100: 4,
    32000: 5,
    24000: 6,
    22050: 7,
    16000: 8,
    12000: 9,
    11025: 10,
    8000: 11,
    7350: 12
};
const MPEG4SamplingFrequencies = [
    96000,
    88200,
    64000,
    48000,
    44100,
    32000,
    24000,
    22050,
    16000,
    12000,
    11025,
    8000,
    7350,
    avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
    avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
    avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE
];
const MPEG4Channels = [
    avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE,
    1,
    2,
    3,
    4,
    5,
    6,
    7
];
/**
 * 解析 AAC AudioSpecificConfig
 *
 *             frequency
 *              44100Hz        fill bit
 *               4 bit          3 bit
 *              -------         -----
 *    0 0 0 1 0 0 1 0 0 0 0 1 0 0 0 0
 *    ---------         -------
 *      5 bit            4 bit
 *     AAC LC           fl, fr
 *    profile           channel
 *
 * url: https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Audio_Specific_Config
 *
 */
function getAVCodecParameters(extradata) {
    let profile = avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    let sampleRate = avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    let channels = avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    if (extradata.length >= 2) {
        profile = (extradata[0] >> 3) & 0x1f;
        sampleRate = MPEG4SamplingFrequencies[((extradata[0] & 0x07) << 1)
            | (extradata[1] >> 7)] ?? 48000;
        channels = MPEG4Channels[(extradata[1] >> 3) & 0x0f] ?? 2;
    }
    return {
        profile,
        sampleRate,
        channels
    };
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata) {
        const { profile, sampleRate, channels } = getAVCodecParameters(extradata);
        stream.codecpar.profile = profile;
        stream.codecpar.sampleRate = sampleRate;
        stream.codecpar.chLayout.nbChannels = channels;
    }
}
function avCodecParameters2Extradata(codecpar) {
    const samplingFreqIndex = MPEG4SamplingFrequencyIndex[codecpar.sampleRate];
    const channelConfig = codecpar.chLayout.nbChannels;
    const extradata = new Uint8Array(2);
    extradata[0] = ((codecpar.profile & 0x1f) << 3) | ((samplingFreqIndex & 0x0e) >> 1);
    extradata[1] = ((samplingFreqIndex & 0x01) << 7) | ((channelConfig & 0x0f) << 3);
    return extradata;
}


/***/ }),

/***/ "./src/avformat/codecs/av1.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/av1.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AV1Profile2Name: () => (/* binding */ AV1Profile2Name),
/* harmony export */   generateExtradata: () => (/* binding */ generateExtradata),
/* harmony export */   getLevelByResolution: () => (/* binding */ getLevelByResolution),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseExtraData: () => (/* binding */ parseExtraData)
/* harmony export */ });
/* unused harmony exports LevelCapabilities, AV1LevelIdx, parseSequenceHeader, splitOBU */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/* harmony import */ var avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/util/av1syntax */ "./src/avutil/util/av1syntax.ts");
/* harmony import */ var common_io_BitWriter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/io/BitWriter */ "./src/common/io/BitWriter.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");





const AV1Profile2Name = {
    [0 /* AV1Profile.Main */]: 'Main',
    [1 /* AV1Profile.High */]: 'High',
    [2 /* AV1Profile.Professional */]: 'Professional'
};
const LevelCapabilities = [
    { level: 20, maxResolution: 2359296 },
    { level: 21, maxResolution: 4460544 },
    { level: 30, maxResolution: 10653696 },
    { level: 31, maxResolution: 17040384 },
    { level: 40, maxResolution: 21233664 },
    { level: 41, maxResolution: 21233664 },
    { level: 50, maxResolution: 35651584 },
    { level: 51, maxResolution: 35651584 },
    { level: 52, maxResolution: 35651584 },
    { level: 53, maxResolution: 35651584 },
    { level: 60, maxResolution: 142606336 },
    { level: 61, maxResolution: 142606336 },
    { level: 62, maxResolution: 142606336 },
    { level: 63, maxResolution: 142606336 }
];
const AV1LevelIdx = [20, 21, 22, 23, 30, 31, 32, 33, 40, 41, 42, 43, 50, 51, 52, 53, 60, 61, 62, 63, 70, 71, 72, 73];
function getLevelByResolution(width, height, fps) {
    const resolution = width * height;
    for (const level of LevelCapabilities) {
        if (resolution <= level.maxResolution) {
            return level.level;
        }
    }
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 4) {
        const params = parseExtraData(extradata);
        stream.codecpar.profile = params.profile;
        stream.codecpar.level = params.level;
    }
}
/**
 * - 1 bit marker
 * - 7 bit version
 * - 3 bit profile
 * - 5 bit level
 * - 1 bit tier
 * - 1 bit bitdepth > 8
 * - 1 bit bitdepth == 12
 * - 1 bit monochrome
 * - 1 bit chroma_subsampling_x
 * - 1 bit chroma_subsampling_y
 * - 2 bit chroma_sample_position
 * - 8 bit padding
 *
 * @param header
 */
function parseExtraData(extradata) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__["default"](extradata.length);
    bitReader.appendBuffer(extradata);
    // marker
    bitReader.readU1();
    // version
    bitReader.readU(7);
    const profile = bitReader.readU(3);
    const level = bitReader.readU(5);
    const tier = bitReader.readU1();
    let bitDepth = bitReader.readU1() ? 10 : 8;
    if (bitReader.readU1()) {
        bitDepth = 12;
    }
    const monochrome = bitReader.readU1();
    const chromaSubsamplingX = bitReader.readU1();
    const chromaSubsamplingY = bitReader.readU1();
    const chromaSamplePosition = bitReader.readU(2);
    return {
        profile,
        level,
        tier,
        bitDepth,
        monochrome,
        chromaSubsamplingX,
        chromaSubsamplingY,
        chromaSamplePosition
    };
}
/* eslint-disable camelcase */
function parseSequenceHeader(header) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__["default"](header.length);
    bitReader.appendBuffer(header);
    bitReader.readU1();
    bitReader.readU(4);
    const extensionFlag = bitReader.readU1();
    const hasSizeFlag = bitReader.readU1();
    // obu_reserved_1bit
    bitReader.readU1();
    if (extensionFlag) {
        bitReader.readU(8);
    }
    if (hasSizeFlag) {
        avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.leb128(bitReader);
    }
    const seq_profile = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 3);
    const still_picture = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    const reduced_still_picture_header = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    let timing_info_present_flag = 0;
    let decoder_model_info_present_flag = 0;
    let initial_display_delay_present_flag = 0;
    let operating_points_cnt_minus_1 = 0;
    let operating_point_idc = [0];
    let seq_level_idx = [0];
    let seq_tier = [0];
    let decoder_model_present_for_this_op = [0];
    let initial_display_delay_present_for_this_op = [0];
    let initial_display_delay_minus_1 = [0];
    let buffer_delay_length_minus_1 = 0;
    let decoder_buffer_delay = [0];
    let encoder_buffer_delay = [0];
    let low_delay_mode_flag = [0];
    if (reduced_still_picture_header) {
        seq_level_idx[0] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 5);
    }
    else {
        timing_info_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        if (timing_info_present_flag) {
            let num_units_in_display_tick = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 32);
            let time_scale = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 32);
            let equal_picture_interval = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
            if (equal_picture_interval) {
                let num_ticks_per_picture_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.uvlc(bitReader);
            }
            let decoder_model_info_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
            if (decoder_model_info_present_flag) {
                buffer_delay_length_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 5);
                let num_units_in_decoding_tick = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 32);
                let buffer_removal_time_length_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 5);
                let frame_presentation_time_length_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 5);
            }
        }
        else {
            decoder_model_info_present_flag = 0;
        }
        let initial_display_delay_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        let operating_points_cnt_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 5);
        for (let i = 0; i <= operating_points_cnt_minus_1; i++) {
            operating_point_idc[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 12);
            seq_level_idx[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 5);
            if (seq_level_idx[i] > 7) {
                seq_tier[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
            }
            else {
                seq_tier[i] = 0;
            }
            if (decoder_model_info_present_flag) {
                decoder_model_present_for_this_op[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
                if (decoder_model_present_for_this_op[i]) {
                    let n = buffer_delay_length_minus_1 + 1;
                    decoder_buffer_delay[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, n);
                    encoder_buffer_delay[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, n);
                    low_delay_mode_flag[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
                }
            }
            else {
                decoder_model_present_for_this_op[i] = 0;
            }
            if (initial_display_delay_present_flag) {
                initial_display_delay_present_for_this_op[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
                if (initial_display_delay_present_for_this_op[i]) {
                    initial_display_delay_minus_1[i] = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 4);
                }
            }
        }
    }
    let frame_width_bits_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 4);
    let frame_height_bits_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 4);
    let n = frame_width_bits_minus_1 + 1;
    let max_frame_width_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, n);
    n = frame_height_bits_minus_1 + 1;
    let max_frame_height_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, n);
    let frame_id_numbers_present_flag = 0;
    let delta_frame_id_length_minus_2 = 0;
    let additional_frame_id_length_minus_1 = 0;
    if (reduced_still_picture_header) {
        frame_id_numbers_present_flag = 0;
    }
    else {
        frame_id_numbers_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    }
    if (frame_id_numbers_present_flag) {
        delta_frame_id_length_minus_2 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 4);
        additional_frame_id_length_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 3);
    }
    let use_128x128_superblock = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    let enable_filter_intra = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    let enable_intra_edge_filter = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    let enable_interintra_compound = 0;
    let enable_masked_compound = 0;
    let enable_warped_motion = 0;
    let enable_dual_filter = 0;
    let enable_order_hint = 0;
    let enable_jnt_comp = 0;
    let enable_ref_frame_mvs = 0;
    let seq_force_screen_content_tools = 2;
    let seq_force_integer_mv = 2;
    let OrderHintBits = 0;
    if (!reduced_still_picture_header) {
        let enable_interintra_compound = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        enable_masked_compound = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        enable_warped_motion = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        enable_dual_filter = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        enable_order_hint = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        if (enable_order_hint) {
            enable_jnt_comp = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
            enable_ref_frame_mvs = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        }
        else {
            enable_jnt_comp = 0;
            enable_ref_frame_mvs = 0;
        }
        let seq_choose_screen_content_tools = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        if (seq_choose_screen_content_tools) {
            seq_force_screen_content_tools = 2;
        }
        else {
            seq_force_screen_content_tools = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        }
        if (seq_force_screen_content_tools > 0) {
            let seq_choose_integer_mv = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
            if (seq_choose_integer_mv) {
                seq_force_integer_mv = 2;
            }
            else {
                seq_force_integer_mv = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
            }
        }
        else {
            seq_force_integer_mv = 2;
        }
        if (enable_order_hint) {
            const order_hint_bits_minus_1 = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 3);
            OrderHintBits = order_hint_bits_minus_1 + 1;
        }
        else {
            OrderHintBits = 0;
        }
    }
    let enable_superres = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    let enable_cdef = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    let enable_restoration = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    let high_bitdepth = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    let twelve_bit = 0;
    let bit_depth = 0;
    let mono_chrome = 0;
    if (seq_profile == 2 && high_bitdepth) {
        twelve_bit = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        bit_depth = twelve_bit ? 12 : 10;
    }
    else if (seq_profile <= 2) {
        bit_depth = high_bitdepth ? 10 : 8;
    }
    if (seq_profile == 1) {
        mono_chrome = 0;
    }
    else {
        mono_chrome = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    }
    const color_description_present_flag = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    let color_primaries = 0;
    let transfer_characteristics = 0;
    let matrix_coefficients = 0;
    if (color_description_present_flag) {
        color_primaries = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 8);
        transfer_characteristics = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 8);
        matrix_coefficients = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 8);
    }
    else {
        color_primaries = 2;
        transfer_characteristics = 2;
        matrix_coefficients = 2;
    }
    let color_range = 0;
    let subsampling_x = 0;
    let subsampling_y = 0;
    let chroma_sample_position = 0;
    let separate_uv_delta_q = 0;
    if (mono_chrome) {
        color_range = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        subsampling_x = 1;
        subsampling_y = 1;
        chroma_sample_position = 0;
        separate_uv_delta_q = 0;
    }
    else if (color_primaries == 1
        && transfer_characteristics == 13
        && matrix_coefficients == 0) {
        color_range = 1;
        subsampling_x = 0;
        subsampling_y = 0;
        separate_uv_delta_q = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    }
    else {
        color_range = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
        if (seq_profile == 0) {
            subsampling_x = 1;
            subsampling_y = 1;
        }
        else if (seq_profile == 1) {
            subsampling_x = 0;
            subsampling_y = 0;
        }
        else {
            if (bit_depth == 12) {
                subsampling_x = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
                if (subsampling_x) {
                    subsampling_y = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
                }
                else {
                    subsampling_y = 0;
                }
            }
            else {
                subsampling_x = 1;
                subsampling_y = 0;
            }
        }
        if (subsampling_x && subsampling_y) {
            chroma_sample_position = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 2);
        }
        separate_uv_delta_q = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    }
    let film_grain_params_present = avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.f(bitReader, 1);
    return {
        width: max_frame_width_minus_1 + 1,
        height: max_frame_height_minus_1 + 1,
        profile: seq_profile,
        level: AV1LevelIdx[seq_level_idx[0]],
        tier: seq_tier[0],
        bitDepth: bit_depth,
        monoChrome: mono_chrome,
        colorRange: color_range,
        colorPrimaries: color_primaries,
        transferCharacteristics: transfer_characteristics,
        matrixCoefficients: matrix_coefficients,
        subsamplingX: subsampling_x,
        subsamplingY: subsampling_y,
        chromaSamplePosition: chroma_sample_position
    };
}
function splitOBU(buffer) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__["default"]();
    bitReader.appendBuffer(buffer);
    const list = [];
    while (bitReader.remainingLength()) {
        const now = bitReader.getPos();
        // obu_forbidden_bit
        bitReader.readU1();
        const type = bitReader.readU(4);
        const extensionFlag = bitReader.readU1();
        const hasSizeFlag = bitReader.readU1();
        // obu_reserved_1bit
        bitReader.readU1();
        if (extensionFlag) {
            bitReader.readU(8);
        }
        const size = hasSizeFlag ? avutil_util_av1syntax__WEBPACK_IMPORTED_MODULE_1__.leb128(bitReader) : buffer.length - 1 - extensionFlag;
        const headerSize = bitReader.getPos() - now;
        list.push(buffer.subarray(now, now + headerSize + size));
        bitReader.skip(size * 8);
    }
    return list;
}
function generateExtradata(codecpar, buffer) {
    const bitWriter = new common_io_BitWriter__WEBPACK_IMPORTED_MODULE_2__["default"](4);
    // marker
    bitWriter.writeU1(1);
    // version
    bitWriter.writeU(7, 1);
    const header = splitOBU(buffer).find((buffer) => {
        return ((buffer[0] >>> 3) & 0x0f) === 1 /* OBUType.SEQUENCE_HEADER */;
    });
    if (header) {
        const params = parseSequenceHeader(header);
        bitWriter.writeU(3, params.profile);
        bitWriter.writeU(5, params.level);
        bitWriter.writeU(1, params.tier);
        bitWriter.writeU(1, params.bitDepth > 8 ? 1 : 0);
        bitWriter.writeU(1, params.bitDepth === 12 ? 1 : 0);
        bitWriter.writeU(1, params.monoChrome);
        bitWriter.writeU(1, params.subsamplingX);
        bitWriter.writeU(1, params.subsamplingY);
        bitWriter.writeU(1, params.chromaSamplePosition);
    }
    else {
        const desc = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_3__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](codecpar + 28)];
        bitWriter.writeU(3, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](codecpar + 48));
        bitWriter.writeU(5, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](codecpar + 52));
        bitWriter.writeU(1, 0);
        bitWriter.writeU(1, desc.comp[0].depth > 8 ? 1 : 0);
        bitWriter.writeU(1, desc.comp[0].depth === 12 ? 1 : 0);
        bitWriter.writeU(1, 0);
        bitWriter.writeU(1, 1);
        bitWriter.writeU(1, 1);
        bitWriter.writeU(1, 0);
    }
    // padding
    bitWriter.writeU(8, 0);
    return bitWriter.getBuffer();
}


/***/ }),

/***/ "./src/avformat/codecs/h264.ts":
/*!*************************************!*\
  !*** ./src/avformat/codecs/h264.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H264Profile2Name: () => (/* binding */ H264Profile2Name),
/* harmony export */   annexb2Avcc: () => (/* binding */ annexb2Avcc),
/* harmony export */   avcc2Annexb: () => (/* binding */ avcc2Annexb),
/* harmony export */   getLevelByResolution: () => (/* binding */ getLevelByResolution),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseAnnexbExtraData: () => (/* binding */ parseAnnexbExtraData),
/* harmony export */   parseAvccExtraData: () => (/* binding */ parseAvccExtraData)
/* harmony export */ });
/* unused harmony exports NALULengthSizeMinusOne, LevelCapabilities, extradata2SpsPps, spsPps2Extradata, parserSPS */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/io/BufferWriter */ "./src/common/io/BufferWriter.ts");
/* harmony import */ var common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BufferReader */ "./src/common/io/BufferReader.ts");
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_util_nalu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/util/nalu */ "./src/avutil/util/nalu.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avutil/util/expgolomb */ "./src/avutil/util/expgolomb.ts");
var cheap__fileName__0 = "src/avformat/codecs/h264.ts";


/*
 * libmedia h264 util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */










const NALULengthSizeMinusOne = 3;
const H264Profile2Name = {
    [66 /* H264Profile.kBaseline */]: 'Constrained Baseline',
    [77 /* H264Profile.kMain */]: 'Main',
    [100 /* H264Profile.kHigh */]: 'High',
    [110 /* H264Profile.kHigh10 */]: 'High10',
    [122 /* H264Profile.kHigh422 */]: 'High422',
    [244 /* H264Profile.kHigh444 */]: 'High444'
};
const LevelCapabilities = [
    { level: 10, maxResolution: 25344, maxFrameRate: 15 },
    { level: 11, maxResolution: 25344, maxFrameRate: 30 },
    { level: 12, maxResolution: 101376, maxFrameRate: 30 },
    { level: 13, maxResolution: 101376, maxFrameRate: 30 },
    { level: 20, maxResolution: 101376, maxFrameRate: 30 },
    { level: 21, maxResolution: 202752, maxFrameRate: 30 },
    { level: 22, maxResolution: 414720, maxFrameRate: 30 },
    { level: 30, maxResolution: 414720, maxFrameRate: 30 },
    { level: 31, maxResolution: 921600, maxFrameRate: 30 },
    { level: 32, maxResolution: 1310720, maxFrameRate: 60 },
    { level: 40, maxResolution: 2097152, maxFrameRate: 30 },
    { level: 41, maxResolution: 2097152, maxFrameRate: 60 },
    { level: 42, maxResolution: 2228224, maxFrameRate: 60 },
    { level: 50, maxResolution: 8912896, maxFrameRate: 30 },
    { level: 51, maxResolution: 8912896, maxFrameRate: 60 },
    { level: 52, maxResolution: 8912896, maxFrameRate: 120 },
    { level: 60, maxResolution: 35651584, maxFrameRate: 30 },
    { level: 61, maxResolution: 35651584, maxFrameRate: 60 },
    { level: 62, maxResolution: 35651584, maxFrameRate: 120 }
];
function getLevelByResolution(width, height, fps) {
    const resolution = width * height;
    for (const level of LevelCapabilities) {
        if (resolution <= level.maxResolution && fps <= level.maxFrameRate) {
            return level.level;
        }
    }
}
/**
 *
 * avcc 格式的 extradata 转 annexb sps pps
 *
 * bits
 * - 8   version ( always 0x01 )
 * - 8   avc profile ( sps[0][1] )
 * - 8   avc compatibility ( sps[0][2] )
 * - 8   avc level ( sps[0][3] )
 * - 6   reserved ( all bits on )
 * - 2   NALULengthSizeMinusOne
 * - 3   reserved ( all bits on )
 * - 5   number of SPS NALUs (usually 1)
 * - repeated once per SPS:
 *   - 16         SPS size
 *   - variable   SPS NALU data
 * - 8 number of PPS NALUs (usually 1)
 * - repeated once per PPS:
 *   - 16       PPS size
 *   - variable PPS NALU data
 *
 * - ext (profile !== 66 && profile !== 77 && profile !== 88)
 *  - 6 reserved ( all bits on )
 *  - 2 chroma_format_idc
 *  - 5 reserved ( all bits on )
 *  - 3 bit_depth_luma_minus8
 *  - 5 reserved ( all bits on )
 *  - 3 bit_depth_chroma_minus8
 *  - 8 number of SPS_EXT NALUs
 *    - 16 SPS_EXT size
 *    - variable   SPS_EXT NALU data
 *
 */
function extradata2SpsPps(extradata) {
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](extradata);
    bufferReader.skip(5);
    const spss = [];
    const ppss = [];
    const spsExts = [];
    const spsLength = bufferReader.readUint8() & 0x1f;
    for (let i = 0; i < spsLength; i++) {
        const length = bufferReader.readUint16();
        spss.push(bufferReader.readBuffer(length));
    }
    const ppsLength = bufferReader.readUint8();
    for (let i = 0; i < ppsLength; i++) {
        const length = bufferReader.readUint16();
        ppss.push(bufferReader.readBuffer(length));
    }
    if (bufferReader.remainingSize() > 4) {
        bufferReader.skip(3);
        const spsExtLength = bufferReader.readUint8();
        if (spsExtLength > 0) {
            for (let i = 0; i < spsExtLength; i++) {
                const length = bufferReader.readUint16();
                spsExts.push(bufferReader.readBuffer(length));
            }
        }
    }
    return {
        spss,
        ppss,
        spsExts
    };
}
function spsPps2Extradata(spss, ppss, spsExts = []) {
    if (spss.length > 32) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.warn(`h264 metadata\'s sps max length is 32, but get ${spss.length}`, cheap__fileName__0, 199);
        spss = spss.slice(0, 32);
    }
    if (spss.length > 256) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.warn(`h264 metadata\'s pps max length is 256, but get ${spss.length}`, cheap__fileName__0, 203);
        spss = spss.slice(0, 256);
    }
    let length = 7;
    length = spss.reduce((prev, sps) => {
        return prev + 2 + sps.length;
    }, length);
    length = ppss.reduce((prev, pps) => {
        return prev + 2 + pps.length;
    }, length);
    const sps = spss[0];
    const params = parserSPS(sps);
    if (params.profile !== 66 && params.profile !== 77 && params.profile !== 88) {
        length += 4;
        if (spsExts.length) {
            length = spsExts.reduce((prev, ext) => {
                return prev + 2 + ext.length;
            }, length);
        }
    }
    const buffer = new Uint8Array(length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_2__["default"](buffer);
    bufferWriter.writeUint8(0x01);
    bufferWriter.writeUint8(sps[1]);
    bufferWriter.writeUint8(sps[2]);
    bufferWriter.writeUint8(sps[3]);
    bufferWriter.writeUint8(0xfc | NALULengthSizeMinusOne);
    // sps
    bufferWriter.writeUint8(0xe0 | (spss.length & 0x1f));
    common_util_array__WEBPACK_IMPORTED_MODULE_3__.each(spss, (sps) => {
        bufferWriter.writeUint16(sps.length);
        bufferWriter.writeBuffer(sps);
    });
    // pps
    bufferWriter.writeUint8(ppss.length);
    common_util_array__WEBPACK_IMPORTED_MODULE_3__.each(ppss, (pps) => {
        bufferWriter.writeUint16(pps.length);
        bufferWriter.writeBuffer(pps);
    });
    if (params.profile !== 66 && params.profile !== 77 && params.profile !== 88) {
        bufferWriter.writeUint8(0xfc | params.chromaFormatIdc);
        bufferWriter.writeUint8(0xf8 | params.bitDepthLumaMinus8);
        bufferWriter.writeUint8(0xf8 | params.bitDepthChromaMinus8);
        if (spsExts.length) {
            common_util_array__WEBPACK_IMPORTED_MODULE_3__.each(spsExts, (ext) => {
                bufferWriter.writeUint16(ext.length);
                bufferWriter.writeBuffer(ext);
            });
        }
    }
    return buffer;
}
/**
 *
 * annexb 格式的 NALU 转 avcc NALU
 *
 */
function annexb2Avcc(data) {
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_4__.splitNaluByStartCode)(data);
    let extradata;
    let key = false;
    if (nalus.length > 1) {
        const spss = [];
        const ppss = [];
        const spsExts = [];
        nalus.forEach((nalu) => {
            const type = nalu[0] & 0x1f;
            if (type === 7 /* H264NaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 8 /* H264NaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
            else if (type === 13 /* H264NaluType.kSPSExt */) {
                spsExts.push(nalu);
            }
        });
        if (spss.length && ppss.length) {
            extradata = spsPps2Extradata(spss, ppss, spsExts);
        }
        nalus = nalus.filter((nalu) => {
            const type = nalu[0] & 0x1f;
            return type !== 9 /* H264NaluType.kSliceAUD */
                && type !== 8 /* H264NaluType.kSlicePPS */
                && type !== 7 /* H264NaluType.kSliceSPS */
                && type !== 13 /* H264NaluType.kSPSExt */;
        });
    }
    const length = nalus.reduce((prev, nalu) => {
        return prev + NALULengthSizeMinusOne + 1 + nalu.length;
    }, 0);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_5__.avMalloc)(length);
    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(bufferPointer, length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_2__["default"](buffer);
    common_util_array__WEBPACK_IMPORTED_MODULE_3__.each(nalus, (nalu) => {
        if (NALULengthSizeMinusOne === 3) {
            bufferWriter.writeUint32(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 2) {
            bufferWriter.writeUint24(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 1) {
            bufferWriter.writeUint16(nalu.length);
        }
        else {
            bufferWriter.writeUint8(nalu.length);
        }
        bufferWriter.writeBuffer(nalu.subarray(0));
        const type = nalu[0] & 0x1f;
        if (type === 5 /* H264NaluType.kSliceIDR */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length,
        key,
        extradata
    };
}
/**
 * avcc 格式的 NALU 转 annexb NALU
 *
 */
function avcc2Annexb(data, extradata) {
    const naluLengthSizeMinusOne = extradata ? (extradata[4] & 0x03) : NALULengthSizeMinusOne;
    let spss = [];
    let ppss = [];
    let spsExts = [];
    let key = false;
    if (extradata) {
        const result = extradata2SpsPps(extradata);
        spss = result.spss;
        ppss = result.ppss;
        spsExts = result.spsExts;
        key = true;
    }
    const nalus = [];
    const seis = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        const nalu = data.subarray((Number(bufferReader.getPos() & 0xffffffffn) >> 0), (Number(bufferReader.getPos() & 0xffffffffn) >> 0) + length);
        bufferReader.skip(length);
        const naluType = nalu[0] & 0x1f;
        if (naluType === 6 /* H264NaluType.kSliceSEI */) {
            seis.push(nalu);
        }
        else if (naluType !== 9 /* H264NaluType.kSliceAUD */) {
            nalus.push(nalu);
        }
    }
    let length = spss.reduce((prev, sps) => {
        return prev + 4 + sps.length;
    }, 0);
    length = ppss.reduce((prev, pps) => {
        return prev + 4 + pps.length;
    }, length);
    length = spsExts.reduce((prev, ext) => {
        return prev + 4 + ext.length;
    }, length);
    length = seis.reduce((prev, sei) => {
        return prev + 4 + sei.length;
    }, length);
    length = nalus.reduce((prev, nalu, index) => {
        return prev + (index ? 3 : 4) + nalu.length;
    }, length);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_5__.avMalloc)(length + 6);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_2__["default"]((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapUint8Array)(bufferPointer, length + 6));
    // AUD
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x01);
    bufferWriter.writeUint8(0x09);
    bufferWriter.writeUint8(0xf0);
    common_util_array__WEBPACK_IMPORTED_MODULE_3__.each(seis, (sei) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(sei);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_3__.each(spss, (sps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(sps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_3__.each(ppss, (pps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(pps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_3__.each(spsExts, (ext) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(ext);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_3__.each(nalus, (nalu, index) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        if (!index) {
            bufferWriter.writeUint8(0x00);
        }
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(nalu);
        const type = nalu[0] & 0x1f;
        if (type === 5 /* H264NaluType.kSliceIDR */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length: length + 6,
        key
    };
}
function parseAvccExtraData(avpacket, stream) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */)) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.getAVPacketData)(avpacket);
    if ((0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_4__.isAnnexb)(data)) {
        return;
    }
    const naluLengthSizeMinusOne = stream.metadata.naluLengthSizeMinusOne ?? NALULengthSizeMinusOne;
    let spss = [];
    let ppss = [];
    let spsExts = [];
    let others = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        const nalu = data.subarray((Number(bufferReader.getPos() & 0xffffffffn) >> 0), (Number(bufferReader.getPos() & 0xffffffffn) >> 0) + length);
        bufferReader.skip(length);
        const naluType = nalu[0] & 0x1f;
        if (naluType === 7 /* H264NaluType.kSliceSPS */) {
            spss.push(nalu);
        }
        else if (naluType === 8 /* H264NaluType.kSlicePPS */) {
            ppss.push(nalu);
        }
        else if (naluType === 13 /* H264NaluType.kSPSExt */) {
            spsExts.push(nalu);
        }
        else {
            others.push(nalu);
        }
    }
    if (spss.length || ppss.length) {
        const extradata = spsPps2Extradata(spss, ppss, spsExts);
        const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_5__.avMalloc)(extradata.length);
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
    }
}
function parseAnnexbExtraData(avpacket, force = false) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) && !force) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.getAVPacketData)(avpacket);
    if (!(0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_4__.isAnnexb)(data)) {
        return;
    }
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_4__.splitNaluByStartCode)(data);
    if (nalus.length > 1) {
        const spss = [];
        const ppss = [];
        const spsExts = [];
        nalus.forEach((nalu) => {
            const type = nalu[0] & 0x1f;
            if (type === 7 /* H264NaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 8 /* H264NaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
            else if (type === 13 /* H264NaluType.kSPSExt */) {
                spsExts.push(nalu);
            }
        });
        if (spss.length && ppss.length) {
            const extradata = spsPps2Extradata(spss, ppss, spsExts);
            const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_5__.avMalloc)(extradata.length);
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_8__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_9__.CTypeEnumWrite[15](avpacket + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[15](avpacket + 36) | 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */);
        }
    }
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 6) {
        stream.metadata.naluLengthSizeMinusOne = (extradata[4] & 0x03);
        const { spss } = extradata2SpsPps(extradata);
        if (spss.length) {
            const { profile, level, width, height } = parserSPS(spss[0]);
            stream.codecpar.profile = profile;
            stream.codecpar.level = level;
            stream.codecpar.width = width;
            stream.codecpar.height = height;
        }
    }
}
function parserSPS(sps) {
    if (!sps || sps.length < 3) {
        return;
    }
    let offset = 0;
    if (sps[0] === 0x00
        && sps[1] === 0x00
        && sps[2] === 0x00
        && sps[3] === 0x01) {
        offset = 4;
    }
    const buffer = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_4__.naluUnescape)(sps.subarray(offset));
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_10__["default"](buffer.length);
    bitReader.appendBuffer(buffer);
    // forbidden_zero_bit
    bitReader.readU1();
    // nal_ref_idc
    bitReader.readU(2);
    // nal_unit_type
    bitReader.readU(5);
    const profile = bitReader.readU(8);
    // constraint_set0_flag
    bitReader.readU1();
    // constraint_set1_flag
    bitReader.readU1();
    // constraint_set2_flag
    bitReader.readU1();
    // constraint_set3_flag
    bitReader.readU1();
    // constraint_set4_flag
    bitReader.readU1();
    // constraint_set4_flag
    bitReader.readU1();
    // reserved_zero_2bits
    bitReader.readU(2);
    const level = bitReader.readU(8);
    // seq_parameter_set_id
    avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    // 摄像机出图大部分格式是 4:2:0
    let chromaFormatIdc = 1;
    let bitDepthLumaMinus8 = 0;
    let bitDepthChromaMinus8 = 0;
    if (profile == 100 || profile == 110 || profile == 122
        || profile == 244 || profile == 44 || profile == 83
        || profile == 86 || profile == 118 || profile == 128
        || profile == 138 || profile == 139 || profile == 134 || profile == 135) {
        chromaFormatIdc = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        if (chromaFormatIdc === 3) {
            // separate_colour_plane_flag
            bitReader.readU1();
        }
        // bit_depth_luma_minus8
        bitDepthLumaMinus8 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        // bit_depth_chroma_minus8
        bitDepthChromaMinus8 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        // qpprime_y_zero_transform_bypass_flag
        bitReader.readU1();
        let seqScalingMatrixPresentFlag = bitReader.readU1();
        if (seqScalingMatrixPresentFlag) {
            const seqScalingListPresentFlag = new Array(8);
            for (let i = 0; i < ((chromaFormatIdc != 3) ? 8 : 12); i++) {
                seqScalingListPresentFlag[i] = bitReader.readU1();
            }
        }
    }
    // log2_max_frame_num_minus4
    avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    const picOrderCntType = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    if (picOrderCntType === 0) {
        // log2_max_pic_order_cnt_lsb_minus4
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    }
    else if (picOrderCntType === 1) {
        // delta_pic_order_always_zero_flag
        bitReader.readU1();
        // offset_for_non_ref_pic
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readSE(bitReader);
        // offset_for_top_to_bottom_field
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readSE(bitReader);
        const numRefFramesInPicOrderCntCycle = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        for (let i = 0; i < numRefFramesInPicOrderCntCycle; i++) {
            avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readSE(bitReader);
        }
    }
    // max_num_ref_frames
    avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    // gaps_in_frame_num_value_allowed_flag
    bitReader.readU1();
    const picWidthInMbsMinus1 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    const picHeightInMapUnitsMinus1 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    const frameMbsOnlyFlag = bitReader.readU1();
    let width = (picWidthInMbsMinus1 + 1) * 16;
    let height = (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16;
    if (!frameMbsOnlyFlag) {
        // mb_adaptive_frame_field_flag
        bitReader.readU1();
    }
    // direct_8x8_inference_flag
    bitReader.readU1();
    const frameCroppingFlag = bitReader.readU1();
    if (frameCroppingFlag) {
        const frameCropLeftOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        const frameCropRightOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        const frameCropTopOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        const frameCropBottomOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        let cropUnitX = 1;
        let cropUnitY = 2 - frameCroppingFlag;
        if (chromaFormatIdc === 1) {
            cropUnitX = 2;
            cropUnitY = 2 * (2 - frameCroppingFlag);
        }
        else if (frameCroppingFlag === 2) {
            cropUnitX = 2;
            cropUnitY = 2 - frameCroppingFlag;
        }
        width -= cropUnitX * (frameCropLeftOffset + frameCropRightOffset);
        height -= cropUnitY * (frameCropTopOffset + frameCropBottomOffset);
    }
    return {
        profile,
        level,
        width,
        height,
        chromaFormatIdc,
        bitDepthLumaMinus8,
        bitDepthChromaMinus8
    };
}


/***/ }),

/***/ "./src/avformat/codecs/hevc.ts":
/*!*************************************!*\
  !*** ./src/avformat/codecs/hevc.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HEVCProfile2Name: () => (/* binding */ HEVCProfile2Name),
/* harmony export */   annexb2Avcc: () => (/* binding */ annexb2Avcc),
/* harmony export */   avcc2Annexb: () => (/* binding */ avcc2Annexb),
/* harmony export */   getLevelByResolution: () => (/* binding */ getLevelByResolution),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseAnnexbExtraData: () => (/* binding */ parseAnnexbExtraData),
/* harmony export */   parseAvccExtraData: () => (/* binding */ parseAvccExtraData)
/* harmony export */ });
/* unused harmony exports LevelCapabilities, extradata2VpsSpsPps, vpsSpsPps2Extradata, parserSPS */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/io/BufferWriter */ "./src/common/io/BufferWriter.ts");
/* harmony import */ var common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BufferReader */ "./src/common/io/BufferReader.ts");
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_nalu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/nalu */ "./src/avutil/util/nalu.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/util/expgolomb */ "./src/avutil/util/expgolomb.ts");


/*
 * libmedia hevc util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */









const HEVCProfile2Name = {
    [1 /* HEVCProfile.Main */]: 'Main',
    [2 /* HEVCProfile.Main10 */]: 'Main10',
    [3 /* HEVCProfile.MainStillPicture */]: 'MainStillPicture',
    [4 /* HEVCProfile.Main444 */]: 'Main444'
};
const LevelCapabilities = [
    { level: 10, maxLumaSamplesPerSecond: 552960, maxLumaPictureSize: 36864, maxBitRate: { main: 128, main10: 150 } },
    { level: 20, maxLumaSamplesPerSecond: 3686400, maxLumaPictureSize: 122880, maxBitRate: { main: 1500, main10: 1875 } },
    { level: 21, maxLumaSamplesPerSecond: 7372800, maxLumaPictureSize: 245760, maxBitRate: { main: 3000, main10: 3750 } },
    { level: 30, maxLumaSamplesPerSecond: 16588800, maxLumaPictureSize: 552960, maxBitRate: { main: 6000, main10: 7500 } },
    { level: 31, maxLumaSamplesPerSecond: 33177600, maxLumaPictureSize: 983040, maxBitRate: { main: 10000, main10: 12500 } },
    { level: 40, maxLumaSamplesPerSecond: 66846720, maxLumaPictureSize: 2228224, maxBitRate: { main: 12000, main10: 15000 } },
    { level: 41, maxLumaSamplesPerSecond: 133693440, maxLumaPictureSize: 2228224, maxBitRate: { main: 20000, main10: 25000 } },
    { level: 50, maxLumaSamplesPerSecond: 267386880, maxLumaPictureSize: 8912896, maxBitRate: { main: 25000, main10: 40000 } },
    { level: 51, maxLumaSamplesPerSecond: 534773760, maxLumaPictureSize: 8912896, maxBitRate: { main: 40000, main10: 60000 } },
    { level: 52, maxLumaSamplesPerSecond: 1069547520, maxLumaPictureSize: 35651584, maxBitRate: { main: 60000, main10: 100000 } },
    { level: 60, maxLumaSamplesPerSecond: 1069547520, maxLumaPictureSize: 35651584, maxBitRate: { main: 60000, main10: 100000 } },
    { level: 61, maxLumaSamplesPerSecond: 2139095040, maxLumaPictureSize: 89128960, maxBitRate: { main: 120000, main10: 240000 } },
    { level: 62, maxLumaSamplesPerSecond: 4278190080, maxLumaPictureSize: 356515840, maxBitRate: { main: 240000, main10: 480000 } }
];
function getLevelByResolution(profile, width, height, fps, bitrate) {
    const selectedProfile = profile === 1 /* HEVCProfile.Main */ ? 'main' : 'main10';
    const lumaSamplesPerSecond = width * height * fps;
    for (const level of LevelCapabilities) {
        if (lumaSamplesPerSecond <= level.maxLumaSamplesPerSecond && width * height <= level.maxLumaPictureSize && bitrate <= level.maxBitRate[selectedProfile]) {
            return level.level;
        }
    }
}
const NALULengthSizeMinusOne = 3;
/**
 *
 * avcc 格式的 extradata 转 annexb vps sps pps
 *
 * bits
 * - 8   configurationVersion( 固定   1)
 * - 2   general_profile_space
 * - 1   general_tier_flag
 * - 5   general_profile_idc
 * - 32  general_profile_compatibility_flags
 * - 48  general_constraint_indicator_flags (6 个 字节）
 * - 8   general_level_idc
 * - 4   reserved1 (1111)
 * - 4   min_spatial_segmentation_idc_L
 * - 8   min_spatial_segmentation_idc_H
 * - 6   reserved2 (111111)
 * - 2   parallelismType
 * - 6   reserved3 (111111)
 * - 2   chromaFormat
 * - 5   reserved4 (11111)
 * - 3   bitDepthLumaMinus8
 * - 5   reserved5(11111)
 * - 3   bitDepthChromaMinus8
 * - 16  avgFrameRate
 * - 2   constantFrameRate
 * - 3   numTemporalLayers
 * - 1   temporalIdNested
 * - 2   lengthSizeMinusOne
 * - 8   numOfArrays
 * - repeated of array (vps/sps/pps)
 * - 1   array_completeness
 * - 1   reserved (0)
 * - 6   NAL_unit_type
 * - 16  numNalus
 * - repeated once per NAL
 * - 16  nalUnitLength
 * - N   NALU data
 *
 */
function extradata2VpsSpsPps(extradata) {
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](extradata, true);
    bufferReader.skip(22);
    let vpss = [];
    let spss = [];
    let ppss = [];
    const arrayLen = bufferReader.readUint8();
    for (let i = 0; i < arrayLen; i++) {
        const naluType = bufferReader.readUint8() & 0x3f;
        const count = bufferReader.readUint16();
        const list = [];
        for (let j = 0; j < count; j++) {
            const len = bufferReader.readUint16();
            list.push(bufferReader.readBuffer(len));
        }
        if (naluType === 32 /* HEVCNaluType.kSliceVPS */) {
            vpss = list;
        }
        else if (naluType === 33 /* HEVCNaluType.kSliceSPS */) {
            spss = list;
        }
        else if (naluType === 34 /* HEVCNaluType.kSlicePPS */) {
            ppss = list;
        }
    }
    return {
        vpss,
        spss,
        ppss
    };
}
function vpsSpsPps2Extradata(vpss, spss, ppss) {
    const sps = spss[0];
    let length = 23;
    if (vpss.length) {
        // type + count
        length += 3;
        length = vpss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    if (spss.length) {
        // type + count
        length += 3;
        length = spss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    if (ppss.length) {
        // type + count
        length += 3;
        length = ppss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    const buffer = new Uint8Array(length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__["default"](buffer, true);
    const spsData = parserSPS(sps);
    bufferWriter.writeUint8(0x01);
    bufferWriter.writeUint8(sps[1]);
    bufferWriter.writeUint8(sps[2]);
    bufferWriter.writeUint8(sps[3]);
    bufferWriter.writeUint8(sps[4]);
    bufferWriter.writeUint8(sps[5]);
    // general_constraint_indicator_flags
    bufferWriter.writeUint8(sps[6]);
    bufferWriter.writeUint8(sps[7]);
    bufferWriter.writeUint8(sps[8]);
    bufferWriter.writeUint8(sps[9]);
    bufferWriter.writeUint8(sps[10]);
    bufferWriter.writeUint8(sps[11]);
    bufferWriter.writeUint8(spsData.level);
    // min_spatial_segmentation_idc
    bufferWriter.writeUint8((1020) | 0);
    bufferWriter.writeUint8(0);
    // parallelismType
    bufferWriter.writeUint8((16320) | 0);
    // chromaFormat
    bufferWriter.writeUint8((16320) | spsData.chromaFormatIdc);
    // bitDepthLumaMinus8
    bufferWriter.writeUint8((8160) | spsData.bitDepthLumaMinus8);
    // bitDepthChromaMinus8
    bufferWriter.writeUint8((8160) | spsData.bitDepthChromaMinus8);
    // avgFrameRate
    bufferWriter.writeUint16(0);
    // constantFrameRate numTemporalLayers temporalIdNested lengthSizeMinusOne
    bufferWriter.writeUint8((0) | (8) | ((sps[0] & 0x01) << 2) | NALULengthSizeMinusOne);
    // numOfArrays
    let numOfArrays = 0;
    if (vpss.length) {
        numOfArrays++;
    }
    if (spss.length) {
        numOfArrays++;
    }
    if (ppss.length) {
        numOfArrays++;
    }
    bufferWriter.writeUint8(numOfArrays);
    // vps
    if (vpss.length) {
        bufferWriter.writeUint8((128) | 32 /* HEVCNaluType.kSliceVPS */);
        bufferWriter.writeUint16(vpss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(vpss, (vps) => {
            bufferWriter.writeUint16(vps.length);
            bufferWriter.writeBuffer(vps);
        });
    }
    // sps
    if (spss.length) {
        bufferWriter.writeUint8((128) | 33 /* HEVCNaluType.kSliceSPS */);
        bufferWriter.writeUint16(spss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spss, (sps) => {
            bufferWriter.writeUint16(sps.length);
            bufferWriter.writeBuffer(sps);
        });
    }
    // pps
    if (ppss.length) {
        bufferWriter.writeUint8((128) | 34 /* HEVCNaluType.kSlicePPS */);
        bufferWriter.writeUint16(ppss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(ppss, (pps) => {
            bufferWriter.writeUint16(pps.length);
            bufferWriter.writeBuffer(pps);
        });
    }
    return buffer;
}
/**
 *
 * annexb 格式的 NALU 转 avcc NALU
 *
 */
function annexb2Avcc(data) {
    let extradata;
    let key = false;
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_3__.splitNaluByStartCode)(data);
    if (nalus.length > 2) {
        const vpss = [];
        const spss = [];
        const ppss = [];
        nalus.forEach((nalu) => {
            const type = (nalu[0] >>> 1) & 0x3f;
            if (type === 32 /* HEVCNaluType.kSliceVPS */) {
                vpss.push(nalu);
            }
            else if (type === 33 /* HEVCNaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 34 /* HEVCNaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
        });
        if (vpss.length && spss.length && ppss.length) {
            extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
            nalus = nalus.filter((nalu) => {
                const type = (nalu[0] >>> 1) & 0x3f;
                return type !== 32 /* HEVCNaluType.kSliceVPS */
                    && type !== 33 /* HEVCNaluType.kSliceSPS */
                    && type !== 34 /* HEVCNaluType.kSlicePPS */
                    && type !== 35 /* HEVCNaluType.kSliceAUD */;
            });
        }
    }
    const length = nalus.reduce((prev, nalu) => {
        return prev + NALULengthSizeMinusOne + 1 + nalu.length;
    }, 0);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_4__.avMalloc)(length);
    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.mapUint8Array)(bufferPointer, length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__["default"](buffer);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu) => {
        if (NALULengthSizeMinusOne === 3) {
            bufferWriter.writeUint32(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 2) {
            bufferWriter.writeUint24(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 1) {
            bufferWriter.writeUint16(nalu.length);
        }
        else {
            bufferWriter.writeUint8(nalu.length);
        }
        bufferWriter.writeBuffer(nalu.subarray(0));
        const type = (nalu[0] >>> 1) & 0x3f;
        if (type === 19 /* HEVCNaluType.kSliceIDR_W_RADL */
            || type === 20 /* HEVCNaluType.kSliceIDR_N_LP */
            || type === 21 /* HEVCNaluType.kSliceCRA_NUT */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length,
        extradata,
        key
    };
}
/**
 * avcc 格式的 NALU 转 annexb NALU
 *
 */
function avcc2Annexb(data, extradata) {
    const naluLengthSizeMinusOne = extradata ? (extradata[21] & 0x03) : NALULengthSizeMinusOne;
    let vpss = [];
    let spss = [];
    let ppss = [];
    let key = false;
    if (extradata) {
        const result = extradata2VpsSpsPps(extradata);
        vpss = result.vpss;
        spss = result.spss;
        ppss = result.ppss;
        key = true;
    }
    const nalus = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        nalus.push(bufferReader.readBuffer(length));
    }
    let length = vpss.reduce((prev, vps) => {
        return prev + 4 + vps.length;
    }, 0);
    length = spss.reduce((prev, sps) => {
        return prev + 4 + sps.length;
    }, length);
    length = ppss.reduce((prev, pps) => {
        return prev + 4 + pps.length;
    }, length);
    length = nalus.reduce((prev, nalu, index) => {
        return prev + (index ? 3 : 4) + nalu.length;
    }, length);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_4__.avMalloc)(length + 7);
    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.mapUint8Array)(bufferPointer, length + 7);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__["default"](buffer);
    // AUD
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x01);
    bufferWriter.writeUint8(35 /* HEVCNaluType.kSliceAUD */ << 1);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0xf0);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(vpss, (vps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(vps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(spss, (sps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(sps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(ppss, (pps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(pps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu, index) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        if (!index) {
            bufferWriter.writeUint8(0x00);
        }
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(nalu);
        const type = (nalu[0] >>> 1) & 0x3f;
        if (type === 19 /* HEVCNaluType.kSliceIDR_W_RADL */
            || type === 20 /* HEVCNaluType.kSliceIDR_N_LP */
            || type === 21 /* HEVCNaluType.kSliceCRA_NUT */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length: length + 7,
        key
    };
}
function parseAvccExtraData(avpacket, stream) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */)) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_7__.getAVPacketData)(avpacket);
    if ((0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_3__.isAnnexb)(data)) {
        return;
    }
    const naluLengthSizeMinusOne = stream.metadata.naluLengthSizeMinusOne ?? NALULengthSizeMinusOne;
    let vpss = [];
    let spss = [];
    let ppss = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        const nalu = data.subarray((Number(bufferReader.getPos() & 0xffffffffn) >> 0), (Number(bufferReader.getPos() & 0xffffffffn) >> 0) + length);
        bufferReader.skip(length);
        const naluType = (nalu[0] >>> 1) & 0x3f;
        if (naluType === 33 /* HEVCNaluType.kSliceSPS */) {
            spss.push(nalu);
        }
        else if (naluType === 34 /* HEVCNaluType.kSlicePPS */) {
            ppss.push(nalu);
        }
        else if (naluType === 32 /* HEVCNaluType.kSliceVPS */) {
            vpss.push(nalu);
        }
    }
    if (spss.length || ppss.length || vpss.length) {
        const extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
        const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_4__.avMalloc)(extradata.length);
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_7__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
    }
}
function parseAnnexbExtraData(avpacket, force = false) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) && !force) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_7__.getAVPacketData)(avpacket);
    if (!(0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_3__.isAnnexb)(data)) {
        return;
    }
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_3__.splitNaluByStartCode)(data);
    if (nalus.length > 2) {
        const vpss = [];
        const spss = [];
        const ppss = [];
        nalus.forEach((nalu) => {
            const type = (nalu[0] >>> 1) & 0x3f;
            if (type === 32 /* HEVCNaluType.kSliceVPS */) {
                vpss.push(nalu);
            }
            else if (type === 33 /* HEVCNaluType.kSliceSPS */) {
                spss.push(nalu);
            }
            else if (type === 34 /* HEVCNaluType.kSlicePPS */) {
                ppss.push(nalu);
            }
        });
        if (vpss.length && spss.length && ppss.length) {
            const extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
            const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_4__.avMalloc)(extradata.length);
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_7__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_8__.CTypeEnumWrite[15](avpacket + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](avpacket + 36) | 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */);
        }
    }
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 6) {
        stream.metadata.naluLengthSizeMinusOne = (extradata[21] & 0x03);
        const { spss } = extradata2VpsSpsPps(extradata);
        if (spss.length) {
            const { profile, level, width, height } = parserSPS(spss[0]);
            stream.codecpar.profile = profile;
            stream.codecpar.level = level;
            stream.codecpar.width = width;
            stream.codecpar.height = height;
        }
    }
}
function parserSPS(sps) {
    if (!sps || sps.length < 3) {
        return;
    }
    let offset = 0;
    if (sps[0] === 0x00
        && sps[1] === 0x00
        && sps[2] === 0x00
        && sps[3] === 0x01) {
        offset = 4;
    }
    let profile = 0;
    let level = 0;
    let width = 0;
    let height = 0;
    let bitDepthLumaMinus8 = 0;
    let bitDepthChromaMinus8 = 0;
    let chromaFormatIdc = 1;
    let generalProfileSpace = 0;
    let generalTierFlag = 0;
    let generalProfileCompatibilityFlag = 0;
    let constraintFlags = 0;
    const buffer = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_3__.naluUnescape)(sps.subarray(offset));
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_9__["default"](buffer.length);
    bitReader.appendBuffer(buffer);
    // forbidden_zero_bit
    bitReader.readU1();
    // nalu type
    bitReader.readU(6);
    // layerId
    bitReader.readU(6);
    // tid
    bitReader.readU(3);
    // sps_video_parameter_set_id
    bitReader.readU(4);
    // The value of sps_max_sub_layers_minus1 shall be in the range of 0 to 6, inclusive.
    const spsMaxSubLayersMinus1 = bitReader.readU(3);
    // sps_temporal_id_nesting_flag
    bitReader.readU1();
    if (spsMaxSubLayersMinus1 <= 6) {
        // profile_tier_level(sps_max_sub_layers_minus1)
        // general_profile_space
        generalProfileSpace = bitReader.readU(2);
        // general_tier_flag
        generalTierFlag = bitReader.readU1();
        // general_profile_idc
        profile = bitReader.readU(5);
        // general_profile_compatibility_flag[32]
        generalProfileCompatibilityFlag = bitReader.readU(32);
        /**
         * 1 general_progressive_source_flag
         * 1 general_interlaced_source_flag
         * 1 general_non_packed_constraint_flag
         * 1 general_frame_only_constraint_flag
         * 44 general_reserved_zero_44bits
         */
        constraintFlags = bitReader.readU(48);
        // general_level_idc
        level = bitReader.readU(8);
        const subLayerProfilePresentFlag = new Array(6);
        const subLayerLevelPresentFlag = new Array(6);
        for (let i = 0; i < spsMaxSubLayersMinus1; i++) {
            subLayerProfilePresentFlag[i] = bitReader.readU1();
            subLayerLevelPresentFlag[i] = bitReader.readU1();
        }
        if (spsMaxSubLayersMinus1 > 0) {
            for (let i = spsMaxSubLayersMinus1; i < 8; i++) {
                // reserved_zero_2bits
                bitReader.readU(2);
            }
        }
        for (let i = 0; i < spsMaxSubLayersMinus1; i++) {
            if (subLayerProfilePresentFlag[i]) {
                // sub_layer_profile_space[i]
                bitReader.readU(2);
                // sub_layer_tier_flag[i]
                bitReader.readU(1);
                // sub_layer_profile_idc[i]
                bitReader.readU(5);
                // sub_layer_profile_compatibility_flag[i][32]
                bitReader.readU(32);
                // sub_layer_progressive_source_flag[i]
                bitReader.readU(1);
                // sub_layer_interlaced_source_flag[i]
                bitReader.readU(1);
                // sub_layer_non_packed_constraint_flag[i]
                bitReader.readU(1);
                // sub_layer_frame_only_constraint_flag[i]
                bitReader.readU(1);
                // sub_layer_reserved_zero_44bits[i]
                bitReader.readU(44);
            }
            if (subLayerLevelPresentFlag[i]) {
                // sub_layer_level_idc[i]
                bitReader.readU(8);
            }
        }
        // "The  value  of sps_seq_parameter_set_id shall be in the range of 0 to 15, inclusive."
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        chromaFormatIdc = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        if (chromaFormatIdc === 3) {
            // separate_colour_plane_flag
            bitReader.readU(1);
        }
        width = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        height = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        const conformanceWindowFlag = bitReader.readU1();
        let confWinLeftOffset = 0;
        let confWinRightOffset = 0;
        let confWinTopOffset = 0;
        let confWinBottomOffset = 0;
        if (conformanceWindowFlag) {
            confWinLeftOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
            confWinRightOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
            confWinTopOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
            confWinBottomOffset = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        }
        bitDepthLumaMinus8 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        bitDepthChromaMinus8 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_10__.readUE(bitReader);
        let SubWidthC = 2;
        let SubHeightC = 2;
        if (chromaFormatIdc === 0) {
            SubWidthC = SubHeightC = 0;
        }
        else if (chromaFormatIdc === 2) {
            SubWidthC = 2;
            SubHeightC = 1;
        }
        else if (chromaFormatIdc === 3) {
            SubWidthC = SubHeightC = 1;
        }
        const cropUnitX = SubWidthC * (1 << (bitDepthLumaMinus8 + 1));
        const cropUnitY = SubHeightC * (1 << (bitDepthLumaMinus8 + 1));
        width -= cropUnitX * (confWinLeftOffset + confWinRightOffset);
        height -= cropUnitY * (confWinTopOffset + confWinBottomOffset);
    }
    return {
        profile,
        level,
        width,
        height,
        chromaFormatIdc,
        bitDepthLumaMinus8,
        bitDepthChromaMinus8,
        generalProfileSpace,
        generalTierFlag,
        generalProfileCompatibilityFlag,
        constraintFlags
    };
}


/***/ }),

/***/ "./src/avformat/codecs/mp3.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/mp3.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MP3Profile2Name: () => (/* binding */ MP3Profile2Name),
/* harmony export */   getBitRateByVersionLayerIndex: () => (/* binding */ getBitRateByVersionLayerIndex),
/* harmony export */   getFrameSizeByVersionLayer: () => (/* binding */ getFrameSizeByVersionLayer),
/* harmony export */   getProfileByLayer: () => (/* binding */ getProfileByLayer),
/* harmony export */   getSampleRateByVersionIndex: () => (/* binding */ getSampleRateByVersionIndex),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/*
 * libmedia mp3 util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

const MpegAudioV10SampleRateTable = [44100, 48000, 32000, 0];
const MpegAudioV20SampleRateTable = [22050, 24000, 16000, 0];
const MpegAudioV25SampleRateTable = [11025, 12000, 8000, 0];
const MpegAudioV10FrameSizeTable = [0, 1152, 1152, 384];
const MpegAudioV20FrameSizeTable = [0, 576, 1152, 384];
const MpegAudioV25FrameSizeTable = [0, 576, 1152, 384];
const MpegAudioV1L1BitRateTable = [0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, -1];
const MpegAudioV1L2BitRateTable = [0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, -1];
const MpegAudioV1L3BitRateTable = [0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1];
const MpegAudioV2L1BitRateTable = [0, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, -1];
const MpegAudioV2L2L3BitRateTable = [0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, -1];
function getSampleRateByVersionIndex(version, samplingFreqIndex) {
    switch (version) {
        case 0:
            // MPEG 2.5
            return MpegAudioV25SampleRateTable[samplingFreqIndex];
        case 2:
            // MPEG 2
            return MpegAudioV20SampleRateTable[samplingFreqIndex];
        case 3:
            // MPEG 1
            return MpegAudioV10SampleRateTable[samplingFreqIndex];
    }
    return avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
}
function getFrameSizeByVersionLayer(version, layer) {
    switch (version) {
        case 0:
            // MPEG 2.5
            return MpegAudioV25FrameSizeTable[layer];
        case 2:
            // MPEG 2
            return MpegAudioV20FrameSizeTable[layer];
        case 3:
            // MPEG 1
            return MpegAudioV10FrameSizeTable[layer];
    }
    return avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
}
function getBitRateByVersionLayerIndex(version, layer, index) {
    switch (layer) {
        // layer3
        case 1:
            switch (version) {
                case 0:
                case 2:
                    return MpegAudioV2L2L3BitRateTable[index];
                case 3:
                    return MpegAudioV1L3BitRateTable[index];
            }
            break;
        // layer2
        case 2:
            switch (version) {
                case 0:
                case 2:
                    return MpegAudioV2L2L3BitRateTable[index];
                case 3:
                    return MpegAudioV1L2BitRateTable[index];
            }
        // layer1
        case 3:
            switch (version) {
                case 0:
                case 2:
                    return MpegAudioV2L1BitRateTable[index];
                case 3:
                    return MpegAudioV1L1BitRateTable[index];
            }
    }
    return avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
}
function getProfileByLayer(layer) {
    switch (layer) {
        case 1:
            // Layer 3
            return 34;
        case 2:
            // Layer 2
            return 33;
        case 3:
            // Layer 1
            return 32;
    }
    return avutil_constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
}
const MP3Profile2Name = {
    [32 /* MP3Profile.Layer1 */]: 'Layer1',
    [33 /* MP3Profile.Layer2 */]: 'Layer2',
    [34 /* MP3Profile.Layer3 */]: 'Layer3'
};
function parseAVCodecParameters(stream, buffer) {
    if (buffer && buffer.length >= 4) {
        const ver = (buffer[1] >>> 3) & 0x03;
        const layer = (buffer[1] & 0x06) >> 1;
        // const bitrateIndex = (buffer[2] & 0xF0) >>> 4
        const samplingFreqIndex = (buffer[2] & 0x0C) >>> 2;
        const channelMode = (buffer[3] >>> 6) & 0x03;
        const channelCount = channelMode !== 3 ? 2 : 1;
        const profile = getProfileByLayer(layer);
        const sampleRate = getSampleRateByVersionIndex(ver, samplingFreqIndex);
        stream.codecpar.profile = profile;
        stream.codecpar.sampleRate = sampleRate;
        stream.codecpar.chLayout.nbChannels = channelCount;
    }
}


/***/ }),

/***/ "./src/avformat/codecs/opus.ts":
/*!*************************************!*\
  !*** ./src/avformat/codecs/opus.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   avCodecParameters2Extradata: () => (/* binding */ avCodecParameters2Extradata),
/* harmony export */   getBufferSamples: () => (/* binding */ getBufferSamples),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters)
/* harmony export */ });
/* unused harmony export durations */
/* harmony import */ var common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BufferReader */ "./src/common/io/BufferReader.ts");
/* harmony import */ var common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/io/BufferWriter */ "./src/common/io/BufferWriter.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/*
 * libmedia opus util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



const durations = [
    /* Silk NB */
    480, 960, 1920, 2880,
    /* Silk MB */
    480, 960, 1920, 2880,
    /* Silk WB */
    480, 960, 1920, 2880,
    /* Hybrid SWB */
    480, 960,
    /* Hybrid FB */
    480, 960,
    /* CELT NB */
    120, 240, 480, 960,
    /* CELT NB */
    120, 240, 480, 960,
    /* CELT NB */
    120, 240, 480, 960,
    /* CELT NB */
    120, 240, 480, 960
];
function getBufferSamples(buffer) {
    let toc = 0, frameDuration = 0, nframes = 0;
    if (buffer.length < 1) {
        return 0;
    }
    toc = buffer[0];
    frameDuration = durations[toc >> 3];
    switch (toc & 3) {
        case 0:
            nframes = 1;
            break;
        case 1:
            nframes = 2;
            break;
        case 2:
            nframes = 2;
            break;
        case 3:
            if (buffer.length < 2) {
                return 0;
            }
            nframes = buffer[1] & 63;
            break;
    }
    return nframes * frameDuration;
}
/**
 * opus extradata
 *
 * - 8 bytes Magic Signature: OpusHead
 * - 1 bytes unsigned, 对应值 0x01 version
 * - 1 bytes unsigned, channels 它可能和编码声道数不一致， 它可能被修改成 packet-by-packet, 对应值 0x01
 * - 2 bytes unsigned, preSkip 这是要从开始播放时的解码器输出， 从页面的颗粒位置减去以计算其 PCM 样本位置。
 * - 4 bytes unsigned, sampleRate 原始输入采样率
 * - 2 bytes signed, outputGain 这是解码时要应用的增益， 20 * log10 缩放解码器输出以实现所需的播放音量
 * - 1 bytes unsigned, channelMappingFamily 指示输出渠道的顺序和语音含义。该八位位组的每个当前指定的值表示一个映射系列，它定义了一组允许的通道数，以及每个允许的通道数的通道名称的有序集合
 * - channelMappingTable 可选， 当 Channel Mapping Family 为 0 时被省略。
 *  - 1 bytes, streamCount, unsigned ogg packet 里面编码了多少路 stream
 *  - 1 bytes, coupledStreamCount, unsigned 标识有多少路流是双声声道，必须小于 streamCount
 *  - C bytes, C 为总输出声道数 coupledStreamCount + streamCount
 *
 */
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 19) {
        const reader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](extradata, false);
        reader.skip(9);
        stream.codecpar.chLayout.nbChannels = reader.readUint8();
        stream.codecpar.initialPadding = reader.readUint16();
        stream.codecpar.sampleRate = reader.readUint32();
        stream.codecpar.seekPreroll = Number((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_1__.avRescaleQ)(BigInt(80), {
            den: 1000,
            num: 1
        }, {
            den: 48000,
            num: 1
        }));
    }
}
function avCodecParameters2Extradata(codecpar) {
    const extradata = new Uint8Array(19);
    const writer = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_2__["default"](extradata, false);
    writer.writeString('OpusHead');
    writer.writeUint8(0x01);
    writer.writeUint8(codecpar.chLayout.nbChannels);
    writer.writeUint16(codecpar.initialPadding);
    writer.writeUint32(codecpar.sampleRate);
    return extradata;
}


/***/ }),

/***/ "./src/avformat/codecs/vp8.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/vp8.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseExtraData: () => (/* binding */ parseExtraData)
/* harmony export */ });
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/*
 * libmedia vp8 util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 6) {
        const params = parseExtraData(extradata);
        stream.codecpar.profile = params.profile;
        stream.codecpar.level = params.level;
    }
}
/**
 * - 1 byte profile
 * - 1 byte level
 * - 4 bit bitdepth
 * - 3 bit chroma_subsampling
 * - 1 bit full_range_flag
 * - 1 byte color_primaries
 * - 1 byte color_trc
 * - 1 byte color_space
 *
 * @param extradata
 */
function parseExtraData(extradata) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__["default"](extradata.length);
    bitReader.appendBuffer(extradata.subarray(4));
    const profile = bitReader.readU(8);
    const level = bitReader.readU(8);
    let bitDepth = bitReader.readU(4);
    const chromaSubsampling = bitReader.readU(3);
    const fullRangeFlag = bitReader.readU1();
    const colorPrimaries = bitReader.readU(8);
    const colorTrc = bitReader.readU(8);
    const colorSpace = bitReader.readU(8);
    return {
        profile,
        level,
        bitDepth,
        chromaSubsampling,
        fullRangeFlag,
        colorPrimaries,
        colorTrc,
        colorSpace
    };
}


/***/ }),

/***/ "./src/avformat/codecs/vp9.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/vp9.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VP9Profile2Name: () => (/* binding */ VP9Profile2Name),
/* harmony export */   generateExtradata: () => (/* binding */ generateExtradata),
/* harmony export */   getLevelByResolution: () => (/* binding */ getLevelByResolution),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseExtraData: () => (/* binding */ parseExtraData)
/* harmony export */ });
/* unused harmony export LevelCapabilities */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../avutil/struct/rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/io/BufferWriter */ "./src/common/io/BufferWriter.ts");








const VP9Profile2Name = {
    [0 /* VP9Profile.Profile0 */]: 'Profile0',
    [1 /* VP9Profile.Profile1 */]: 'Profile1',
    [2 /* VP9Profile.Profile2 */]: 'Profile2',
    [3 /* VP9Profile.Profile3 */]: 'Profile3'
};
const LevelCapabilities = [
    { level: 10, maxResolution: 196608, maxFrameRate: 30 },
    { level: 11, maxResolution: 196608, maxFrameRate: 60 },
    { level: 20, maxResolution: 518400, maxFrameRate: 30 },
    { level: 21, maxResolution: 518400, maxFrameRate: 60 },
    { level: 30, maxResolution: 2073600, maxFrameRate: 30 },
    { level: 31, maxResolution: 2073600, maxFrameRate: 60 },
    { level: 40, maxResolution: 3686400, maxFrameRate: 30 },
    { level: 41, maxResolution: 3686400, maxFrameRate: 60 },
    { level: 50, maxResolution: 8294400, maxFrameRate: 30 },
    { level: 51, maxResolution: 8294400, maxFrameRate: 60 },
    { level: 60, maxResolution: 8847360, maxFrameRate: 30 },
    { level: 61, maxResolution: 8847360, maxFrameRate: 60 },
    { level: 70, maxResolution: 35389440, maxFrameRate: 30 },
    { level: 71, maxResolution: 35389440, maxFrameRate: 60 }
];
function getLevelByResolution(width, height, fps) {
    const resolution = width * height;
    for (const level of LevelCapabilities) {
        if (resolution <= level.maxResolution && fps <= level.maxFrameRate) {
            return level.level;
        }
    }
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 6) {
        const params = parseExtraData(extradata);
        stream.codecpar.profile = params.profile;
        stream.codecpar.level = params.level;
    }
}
/**
 * - 1 byte profile
 * - 1 byte level
 * - 4 bit bitdepth
 * - 3 bit chroma_subsampling
 * - 1 bit full_range_flag
 * - 1 byte color_primaries
 * - 1 byte color_trc
 * - 1 byte color_space
 *
 * @param extradata
 */
function parseExtraData(extradata) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_0__["default"](extradata.length);
    bitReader.appendBuffer(extradata);
    const profile = bitReader.readU(8);
    const level = bitReader.readU(8);
    let bitDepth = bitReader.readU(4);
    const chromaSubsampling = bitReader.readU(3);
    const fullRangeFlag = bitReader.readU1();
    const colorPrimaries = bitReader.readU(8);
    const colorTrc = bitReader.readU(8);
    const colorSpace = bitReader.readU(8);
    return {
        profile,
        level,
        bitDepth,
        chromaSubsampling,
        fullRangeFlag,
        colorPrimaries,
        colorTrc,
        colorSpace
    };
}
function getVpccFeature(codecpar) {
    let profile = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](codecpar + 48);
    let level = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](codecpar + 52);
    if (level === avutil_constant__WEBPACK_IMPORTED_MODULE_2__.NOPTS_VALUE) {
        level = getLevelByResolution(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](codecpar + 56), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](codecpar + 60), (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_3__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_4__["default"])(codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_5__.Rational)));
    }
    const desc = avutil_pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_6__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](codecpar + 28)];
    let bitDepth = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](codecpar + 40);
    let chromaSubsampling = 1 /* VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_420_COLLOCATED_WITH_LUMA */;
    if (desc) {
        bitDepth = desc.comp[0].depth;
        if (desc.log2ChromaW === 1 && desc.log2ChromaH === 1) {
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](codecpar + 100) === 1 /* AVChromaLocation.AVCHROMA_LOC_LEFT */) {
                chromaSubsampling = 0 /* VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_420_VERTICAL */;
            }
        }
        else if (desc.log2ChromaW === 1 && desc.log2ChromaH === 0) {
            chromaSubsampling = 2 /* VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_422 */;
        }
        else if (desc.log2ChromaW === 0 && desc.log2ChromaH === 0) {
            chromaSubsampling = 3 /* VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_444 */;
        }
    }
    const fullRange = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](codecpar + 84) === 2 /* AVColorRange.AVCOL_RANGE_JPEG */ ? 1 : 0;
    if (profile === avutil_constant__WEBPACK_IMPORTED_MODULE_2__.NOPTS_VALUE && bitDepth) {
        if (chromaSubsampling == 0 /* VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_420_VERTICAL */
            || chromaSubsampling == 1 /* VPX_CHROMA_SUBSAMPLING.VPX_SUBSAMPLING_420_COLLOCATED_WITH_LUMA */) {
            profile = (bitDepth == 8) ? 0 /* VP9Profile.Profile0 */ : 2 /* VP9Profile.Profile2 */;
        }
        else {
            profile = (bitDepth == 8) ? 1 /* VP9Profile.Profile1 */ : 3 /* VP9Profile.Profile3 */;
        }
    }
    return {
        profile,
        level,
        bitDepth,
        chromaSubsampling,
        fullRange
    };
}
function generateExtradata(codecpar) {
    const ioWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_7__["default"](new Uint8Array(8));
    const vpcc = getVpccFeature(codecpar);
    ioWriter.writeUint8(vpcc.profile);
    ioWriter.writeUint8(vpcc.level);
    ioWriter.writeUint8((vpcc.bitDepth << 4) | (vpcc.chromaSubsampling << 1) | vpcc.fullRange);
    ioWriter.writeUint8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](codecpar + 88));
    ioWriter.writeUint8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](codecpar + 92));
    ioWriter.writeUint8(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](codecpar + 96));
    ioWriter.writeUint16(0);
    return ioWriter.getWroteBuffer();
}


/***/ }),

/***/ "./src/avformat/codecs/vvc.ts":
/*!************************************!*\
  !*** ./src/avformat/codecs/vvc.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   annexb2Avcc: () => (/* binding */ annexb2Avcc),
/* harmony export */   avcc2Annexb: () => (/* binding */ avcc2Annexb),
/* harmony export */   parseAVCodecParameters: () => (/* binding */ parseAVCodecParameters),
/* harmony export */   parseAnnexbExtraData: () => (/* binding */ parseAnnexbExtraData),
/* harmony export */   parseAvccExtraData: () => (/* binding */ parseAvccExtraData),
/* harmony export */   parseExtraData: () => (/* binding */ parseExtraData)
/* harmony export */ });
/* unused harmony exports extradata2VpsSpsPps, vpsSpsPps2Extradata, parserSPS */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/io/BufferWriter */ "./src/common/io/BufferWriter.ts");
/* harmony import */ var common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BufferReader */ "./src/common/io/BufferReader.ts");
/* harmony import */ var common_io_BitReader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/io/BitReader */ "./src/common/io/BitReader.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avutil_util_nalu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/util/nalu */ "./src/avutil/util/nalu.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avutil/util/expgolomb */ "./src/avutil/util/expgolomb.ts");
/* harmony import */ var common_io_BitWriter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/io/BitWriter */ "./src/common/io/BitWriter.ts");


/*
 * libmedia vvc util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */










const NALULengthSizeMinusOne = 3;
function parsePTL(bitReader) {
    const olsIdx = bitReader.readU(9);
    const numSublayers = bitReader.readU(3);
    const constantFrameRate = bitReader.readU(2);
    const chromaFormatIdc = bitReader.readU(2);
    const bitDepthMinus8 = bitReader.readU(3);
    bitReader.readU(5);
    // VvcPTLRecord
    bitReader.readU(2);
    const num_bytes_constraint_info = bitReader.readU(6);
    const generalProfileIdc = bitReader.readU(7);
    const generalTierFlag = bitReader.readU(1);
    const generalLevelIdc = bitReader.readU(8);
    const ptlFrameOnlyConstraintFlag = bitReader.readU(1);
    const ptlMultilayerEnabledFlag = bitReader.readU(1);
    const generalConstraintInfo = [];
    const sublayerLevelIdc = [];
    if (num_bytes_constraint_info) {
        for (let i = 0; i < num_bytes_constraint_info - 1; i++) {
            generalConstraintInfo[i] = bitReader.readU(8);
        }
        generalConstraintInfo[num_bytes_constraint_info - 1] = bitReader.readU(6);
    }
    else {
        bitReader.readU(6);
    }
    if (numSublayers > 1) {
        let ptl_sublayer_present_mask = 0;
        for (let j = numSublayers - 2; j >= 0; --j) {
            const val = bitReader.readU(1);
            ptl_sublayer_present_mask |= val << j;
        }
        for (let j = numSublayers; j <= 8 && numSublayers > 1; ++j) {
            bitReader.readU(1);
        }
        for (let j = numSublayers - 2; j >= 0; --j) {
            if (ptl_sublayer_present_mask & (1 << j)) {
                sublayerLevelIdc[j] = bitReader.readU(8);
            }
        }
    }
    const ptl_num_sub_profiles = bitReader.readU(8);
    const generalSubProfileIdc = [];
    if (ptl_num_sub_profiles) {
        for (let i = 0; i < ptl_num_sub_profiles; i++) {
            generalSubProfileIdc.push(bitReader.readU(8));
        }
    }
    const maxPictureWidth = bitReader.readU(16);
    const maxPictureHeight = bitReader.readU(16);
    const avgFramerate = bitReader.readU(16);
    return {
        olsIdx,
        numSublayers,
        bitDepthMinus8,
        chromaFormatIdc,
        constantFrameRate,
        generalProfileIdc,
        generalTierFlag,
        generalLevelIdc,
        ptlFrameOnlyConstraintFlag,
        ptlMultilayerEnabledFlag,
        generalConstraintInfo,
        sublayerLevelIdc,
        generalSubProfileIdc,
        maxPictureWidth,
        maxPictureHeight,
        avgFramerate
    };
}
/**
 *
 * vvcc 格式的 extradata 转 annexb vps sps pps
 *
 * bits
 * - 5   reserved (11111)
 * - 2   lengthSizeMinusOne
 * - 1   ptl_present_flag
 * if ptl_present_flag
 *   - 9   ols_idx
 *   - 3  num_sublayers
 *   - 2  constant_frame_rate
 *   - 2  chroma_format_idc
 *   - 3  bit_depth_minus8
 *   - 5  reserved (11111)
 *   VvcPTLRecord
 *   - 2 reserved (11)
 *   - 6 num_bytes_constraint_info
 *   - 7 general_profile_idc
 *   - 1 general_tier_flag
 *   - 8 general_level_idc
 *   - 1 general_level_idc
 *   - 1 ptl_multilayer_enabled_flag
 *   if num_bytes_constraint_info > 0
 *      for (i = 0; i < num_bytes_constraint_info - 1; i++)
 *        - 8 general_constraint_info[i]
 *      - 6 general_constraint_info[num_bytes_constraint_info - 1]
 *   else
 *      - 6 reserved
 *   if num_sublayers > 1
 *      - num_sublayers - 2 ptl_sublayer_level_present_flag
 *      - 8 - num_sublayers + 1 ptl_reserved_zero_bit
 *      for (i = num_sublayers -2; i >= 0; i--)
 *        if ptl_sublayer_present_mask & (1 << i)
 *          - 8 sublayer_level_idc[i]
 *    - 8 ptl_num_sub_profiles
 *    if ptl_num_sub_profiles
 *      for (i = 0; i < ptl_num_sub_profiles; i++)
 *        - 32 general_sub_profile_idc[i]
 *    - 16 max_picture_width
 *    - 16 max_picture_height
 *    - 16 avg_frame_rate
 * - 8   numOfArrays
 * - repeated of array (vps/sps/pps)
 * - 1   array_completeness
 * - 2   reserved (0)
 * - 5   NAL_unit_type
 * if nalu_type != VVC_NALU_DEC_PARAM && nalu_type != VVC_NALU_OPI
 *    - 16  numNalus
 * else
 *   numNalus = 1
 * - repeated once per NAL
 * - 16  nalUnitLength
 * - N   NALU data
 *
 */
function extradata2VpsSpsPps(extradata) {
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](extradata, true);
    const ptlPresentFlag = bufferReader.readUint8() & 0x01;
    if (ptlPresentFlag) {
        const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_1__["default"]();
        bitReader.appendBuffer(extradata.subarray(1));
        parsePTL(bitReader);
        bufferReader.skip(bitReader.getPos());
    }
    let vpss = [];
    let spss = [];
    let ppss = [];
    const arrayLen = bufferReader.readUint8();
    for (let i = 0; i < arrayLen; i++) {
        const naluType = bufferReader.readUint8() & 0x1f;
        let count = 1;
        if (naluType !== 13 /* VVCNaluType.kDCI_NUT */ && naluType !== 12 /* VVCNaluType.kOPI_NUT */) {
            count = bufferReader.readUint16();
        }
        const list = [];
        for (let j = 0; j < count; j++) {
            const len = bufferReader.readUint16();
            list.push(bufferReader.readBuffer(len));
        }
        if (naluType === 14 /* VVCNaluType.kVPS_NUT */) {
            vpss = list;
        }
        else if (naluType === 15 /* VVCNaluType.kSPS_NUT */) {
            spss = list;
        }
        else if (naluType === 16 /* VVCNaluType.kPPS_NUT */) {
            ppss = list;
        }
    }
    return {
        vpss,
        spss,
        ppss
    };
}
function vpsSpsPps2Extradata(vpss, spss, ppss) {
    const sps = spss[0];
    let ptl;
    if (sps) {
        const spsParams = parserSPS(sps);
        const biWriter = new common_io_BitWriter__WEBPACK_IMPORTED_MODULE_2__["default"]();
        biWriter.writeU(9, 0);
        biWriter.writeU(3, spsParams.spsMaxSublayersMinus1 + 1);
        biWriter.writeU(2, 1);
        biWriter.writeU(2, spsParams.chromaFormatIdc);
        biWriter.writeU(3, spsParams.bitDepthMinus8);
        biWriter.writeU(5, 0b11111);
        biWriter.writeU(2, 0b11);
        biWriter.writeU(6, spsParams.generalConstraintInfo.length);
        biWriter.writeU(7, spsParams.profile);
        biWriter.writeU1(spsParams.tierFlag);
        biWriter.writeU(8, spsParams.level);
        biWriter.writeU1(spsParams.ptlFrameOnlyConstraintFlag);
        biWriter.writeU1(spsParams.ptlMultilayerEnabledFlag);
        if (spsParams.generalConstraintInfo.length) {
            for (let i = 0; i < spsParams.generalConstraintInfo.length - 1; i++) {
                biWriter.writeU(8, spsParams.generalConstraintInfo[i]);
            }
            biWriter.writeU(6, spsParams.generalConstraintInfo[spsParams.generalConstraintInfo.length - 1]);
        }
        else {
            biWriter.writeU(6, 0b111111);
        }
        if (spsParams.spsMaxSublayersMinus1 + 1 > 1) {
            let ptl_sublayer_level_present_flags = 0;
            for (let i = spsParams.spsMaxSublayersMinus1 - 1; i >= 0; i--) {
                ptl_sublayer_level_present_flags = (ptl_sublayer_level_present_flags << 1 | spsParams.ptlSublayerLevelPresentFlag[i]);
            }
            biWriter.writeU(8, ptl_sublayer_level_present_flags);
        }
        for (let i = spsParams.spsMaxSublayersMinus1 - 1; i >= 0; i--) {
            if (spsParams.ptlSublayerLevelPresentFlag[i]) {
                biWriter.writeU(8, spsParams.sublayerLevelIdc[i]);
            }
        }
        biWriter.writeU(8, spsParams.generalSubProfileIdc.length);
        for (let i = 0; i < spsParams.generalSubProfileIdc.length; i++) {
            biWriter.writeU(32, spsParams.sublayerLevelIdc[i]);
        }
        biWriter.writeU(16, spsParams.width);
        biWriter.writeU(16, spsParams.height);
        biWriter.writeU(16, 0);
        biWriter.padding();
        ptl = biWriter.getBuffer().subarray(0, biWriter.getPointer());
    }
    let length = 1 + (ptl ? ptl.length : 0);
    if (vpss.length) {
        // type + count
        length += 3;
        length = vpss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    if (spss.length) {
        // type + count
        length += 3;
        length = spss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    if (ppss.length) {
        // type + count
        length += 3;
        length = ppss.reduce((prev, value) => {
            // length + data
            return prev + 2 + value.length;
        }, length);
    }
    const buffer = new Uint8Array(length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"](buffer, true);
    bufferWriter.writeUint8(NALULengthSizeMinusOne << 1 | (ptl ? 1 : 0) | 0xf8);
    if (ptl) {
        bufferWriter.writeBuffer(ptl);
    }
    // numOfArrays
    let numOfArrays = 0;
    if (vpss.length) {
        numOfArrays++;
    }
    if (spss.length) {
        numOfArrays++;
    }
    if (ppss.length) {
        numOfArrays++;
    }
    bufferWriter.writeUint8(numOfArrays);
    // vps
    if (vpss.length) {
        bufferWriter.writeUint8((128) | 14 /* VVCNaluType.kVPS_NUT */);
        bufferWriter.writeUint16(vpss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_4__.each(vpss, (vps) => {
            bufferWriter.writeUint16(vps.length);
            bufferWriter.writeBuffer(vps);
        });
    }
    // sps
    if (spss.length) {
        bufferWriter.writeUint8((128) | 15 /* VVCNaluType.kSPS_NUT */);
        bufferWriter.writeUint16(spss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_4__.each(spss, (sps) => {
            bufferWriter.writeUint16(sps.length);
            bufferWriter.writeBuffer(sps);
        });
    }
    // pps
    if (ppss.length) {
        bufferWriter.writeUint8((128) | 16 /* VVCNaluType.kPPS_NUT */);
        bufferWriter.writeUint16(ppss.length);
        common_util_array__WEBPACK_IMPORTED_MODULE_4__.each(ppss, (pps) => {
            bufferWriter.writeUint16(pps.length);
            bufferWriter.writeBuffer(pps);
        });
    }
    return buffer;
}
/**
 *
 * annexb 格式的 NALU 转 avcc NALU
 *
 */
function annexb2Avcc(data) {
    let extradata;
    let key = false;
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_5__.splitNaluByStartCode)(data);
    if (nalus.length > 2) {
        const vpss = [];
        const spss = [];
        const ppss = [];
        nalus.forEach((nalu) => {
            const type = (nalu[0] >>> 1) & 0x3f;
            if (type === 14 /* VVCNaluType.kVPS_NUT */) {
                vpss.push(nalu);
            }
            else if (type === 15 /* VVCNaluType.kSPS_NUT */) {
                spss.push(nalu);
            }
            else if (type === 16 /* VVCNaluType.kPPS_NUT */) {
                ppss.push(nalu);
            }
        });
        if (vpss.length && spss.length && ppss.length) {
            extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
            nalus = nalus.filter((nalu) => {
                const type = (nalu[0] >>> 1) & 0x3f;
                return type !== 14 /* VVCNaluType.kVPS_NUT */
                    && type !== 15 /* VVCNaluType.kSPS_NUT */
                    && type !== 16 /* VVCNaluType.kPPS_NUT */
                    && type !== 20 /* VVCNaluType.kAUD_NUT */;
            });
        }
    }
    const length = nalus.reduce((prev, nalu) => {
        return prev + NALULengthSizeMinusOne + 1 + nalu.length;
    }, 0);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_6__.avMalloc)(length);
    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.mapUint8Array)(bufferPointer, length);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"](buffer);
    common_util_array__WEBPACK_IMPORTED_MODULE_4__.each(nalus, (nalu) => {
        if (NALULengthSizeMinusOne === 3) {
            bufferWriter.writeUint32(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 2) {
            bufferWriter.writeUint24(nalu.length);
        }
        else if (NALULengthSizeMinusOne === 1) {
            bufferWriter.writeUint16(nalu.length);
        }
        else {
            bufferWriter.writeUint8(nalu.length);
        }
        bufferWriter.writeBuffer(nalu.subarray(0));
        const type = (nalu[0] >>> 1) & 0x3f;
        if (type === 8 /* VVCNaluType.kIDR_N_LP */
            || type === 7 /* VVCNaluType.kIDR_W_RADL */
            || type === 9 /* VVCNaluType.kCRA_NUT */
            || type === 10 /* VVCNaluType.kGDR_NUT */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length,
        extradata,
        key
    };
}
/**
 * avcc 格式的 NALU 转 annexb NALU
 *
 */
function avcc2Annexb(data, extradata) {
    const naluLengthSizeMinusOne = extradata ? ((extradata[0] >>> 1) & 0x03) : NALULengthSizeMinusOne;
    let vpss = [];
    let spss = [];
    let ppss = [];
    let key = false;
    if (extradata) {
        const result = extradata2VpsSpsPps(extradata);
        vpss = result.vpss;
        spss = result.spss;
        ppss = result.ppss;
        key = true;
    }
    const nalus = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        nalus.push(bufferReader.readBuffer(length));
    }
    let length = vpss.reduce((prev, vps) => {
        return prev + 4 + vps.length;
    }, 0);
    length = spss.reduce((prev, sps) => {
        return prev + 4 + sps.length;
    }, length);
    length = ppss.reduce((prev, pps) => {
        return prev + 4 + pps.length;
    }, length);
    length = nalus.reduce((prev, nalu, index) => {
        return prev + (index ? 3 : 4) + nalu.length;
    }, length);
    const bufferPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_6__.avMalloc)(length + 7);
    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.mapUint8Array)(bufferPointer, length + 7);
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_3__["default"](buffer);
    // AUD
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(0x01);
    bufferWriter.writeUint8(0x00);
    bufferWriter.writeUint8(20 /* VVCNaluType.kAUD_NUT */ << 3);
    bufferWriter.writeUint8(0xf0);
    common_util_array__WEBPACK_IMPORTED_MODULE_4__.each(vpss, (vps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(vps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_4__.each(spss, (sps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(sps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_4__.each(ppss, (pps) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(pps);
    });
    common_util_array__WEBPACK_IMPORTED_MODULE_4__.each(nalus, (nalu, index) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        if (!index) {
            bufferWriter.writeUint8(0x00);
        }
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(nalu);
        const type = (nalu[0] >>> 1) & 0x3f;
        if (type === 8 /* VVCNaluType.kIDR_N_LP */
            || type === 7 /* VVCNaluType.kIDR_W_RADL */
            || type === 9 /* VVCNaluType.kCRA_NUT */
            || type === 10 /* VVCNaluType.kGDR_NUT */) {
            key = true;
        }
    });
    return {
        bufferPointer,
        length: length + 7,
        key
    };
}
function parseAvccExtraData(avpacket, stream) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_8__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */)) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.getAVPacketData)(avpacket);
    if ((0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_5__.isAnnexb)(data)) {
        return;
    }
    const naluLengthSizeMinusOne = stream.metadata.naluLengthSizeMinusOne ?? NALULengthSizeMinusOne;
    let vpss = [];
    let spss = [];
    let ppss = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](data);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        const nalu = data.subarray((Number(bufferReader.getPos() & 0xffffffffn) >> 0), (Number(bufferReader.getPos() & 0xffffffffn) >> 0) + length);
        bufferReader.skip(length);
        const naluType = (nalu[0] >>> 1) & 0x3f;
        if (naluType === 15 /* VVCNaluType.kSPS_NUT */) {
            spss.push(nalu);
        }
        else if (naluType === 16 /* VVCNaluType.kPPS_NUT */) {
            ppss.push(nalu);
        }
        else if (naluType === 14 /* VVCNaluType.kVPS_NUT */) {
            vpss.push(nalu);
        }
    }
    if (spss.length || ppss.length || vpss.length) {
        const extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
        const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_6__.avMalloc)(extradata.length);
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
    }
}
function parseAnnexbExtraData(avpacket, force = false) {
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_8__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) && !force) {
        return;
    }
    const data = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.getAVPacketData)(avpacket);
    if (!(0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_5__.isAnnexb)(data)) {
        return;
    }
    let nalus = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_5__.splitNaluByStartCode)(data);
    if (nalus.length > 2) {
        const vpss = [];
        const spss = [];
        const ppss = [];
        nalus.forEach((nalu) => {
            const type = (nalu[0] >>> 1) & 0x3f;
            if (type === 14 /* VVCNaluType.kVPS_NUT */) {
                vpss.push(nalu);
            }
            else if (type === 15 /* VVCNaluType.kSPS_NUT */) {
                spss.push(nalu);
            }
            else if (type === 16 /* VVCNaluType.kPPS_NUT */) {
                ppss.push(nalu);
            }
        });
        if (vpss.length && spss.length && ppss.length) {
            const extradata = vpsSpsPps2Extradata(vpss, spss, ppss);
            const extradataPointer = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_6__.avMalloc)(extradata.length);
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_7__.memcpyFromUint8Array)(extradataPointer, extradata.length, extradata);
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_9__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradataPointer, extradata.length);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_10__.CTypeEnumWrite[15](avpacket + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_8__.CTypeEnumRead[15](avpacket + 36) | 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */);
        }
    }
}
function parseAVCodecParameters(stream, extradata) {
    if (!extradata && stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */]) {
        extradata = stream.sideData[1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */];
    }
    if (extradata && extradata.length >= 6) {
        stream.metadata.naluLengthSizeMinusOne = (extradata[0] >>> 1) & 0x03;
        const { spss } = extradata2VpsSpsPps(extradata);
        if (spss.length) {
            const { profile, level, width, height } = parserSPS(spss[0]);
            stream.codecpar.profile = profile;
            stream.codecpar.level = level;
            stream.codecpar.width = width;
            stream.codecpar.height = height;
        }
    }
}
function parserSPS(sps) {
    if (!sps || sps.length < 3) {
        return;
    }
    let offset = 0;
    if (sps[0] === 0x00
        && sps[1] === 0x00
        && sps[2] === 0x00
        && sps[3] === 0x01) {
        offset = 4;
    }
    let profile = 0;
    let level = 0;
    let width = 0;
    let height = 0;
    let bitDepthMinus8 = 0;
    let chromaFormatIdc = 1;
    let generalProfileSpace = 0;
    let tierFlag = 0;
    let ptlFrameOnlyConstraintFlag = 0;
    let ptlMultilayerEnabledFlag = 0;
    const generalConstraintInfo = [];
    const ptlSublayerLevelPresentFlag = [];
    const sublayerLevelIdc = [];
    const generalSubProfileIdc = [];
    const buffer = (0,avutil_util_nalu__WEBPACK_IMPORTED_MODULE_5__.naluUnescape)(sps.subarray(offset));
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_1__["default"](buffer.length);
    bitReader.appendBuffer(buffer);
    // forbidden_zero_bit
    bitReader.readU1();
    // nuh_reserved_zero_bit
    bitReader.readU1();
    // layerId
    bitReader.readU(6);
    // nalu type
    bitReader.readU(5);
    // tid
    bitReader.readU(3);
    // sps_seq_parameter_set_id && sps_video_parameter_set_id
    bitReader.readU(8);
    const spsMaxSublayersMinus1 = bitReader.readU(3);
    chromaFormatIdc = bitReader.readU(2);
    const sps_log2_ctu_size_minus5 = bitReader.readU(2);
    const sps_ptl_dpb_hrd_params_present_flag = bitReader.readU(1);
    if (sps_ptl_dpb_hrd_params_present_flag) {
        profile = bitReader.readU(7);
        tierFlag = bitReader.readU(1);
        level = bitReader.readU(8);
        ptlFrameOnlyConstraintFlag = bitReader.readU(1);
        ptlMultilayerEnabledFlag = bitReader.readU(1);
        const gci_present_flag = bitReader.readU(1);
        if (gci_present_flag) {
            for (let j = 0; j < 8; j++) {
                generalConstraintInfo[j] = bitReader.readU(8);
            }
            generalConstraintInfo[8] = bitReader.readU(7);
            const gci_num_reserved_bits = bitReader.readU(8);
            bitReader.readU(gci_num_reserved_bits);
        }
        bitReader.skipPadding();
        for (let i = spsMaxSublayersMinus1 - 1; i >= 0; i--) {
            ptlSublayerLevelPresentFlag[i] = bitReader.readU(1);
        }
        bitReader.skipPadding();
        for (let i = spsMaxSublayersMinus1 - 1; i >= 0; i--) {
            if (ptlSublayerLevelPresentFlag[i]) {
                sublayerLevelIdc[i] = bitReader.readU(8);
            }
        }
        const ptl_num_sub_profiles = bitReader.readU(8);
        if (ptl_num_sub_profiles) {
            for (let i = 0; i < ptl_num_sub_profiles; i++) {
                generalSubProfileIdc[i] = bitReader.readU(32);
            }
        }
    }
    // sps_gdr_enabled_flag
    bitReader.readU1();
    const sps_ref_pic_resampling_enabled_flag = bitReader.readU1();
    if (sps_ref_pic_resampling_enabled_flag) {
        // sps_res_change_in_clvs_allowed_flag
        bitReader.readU1();
    }
    const sps_pic_width_max_in_luma_samples = width = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    const sps_pic_height_max_in_luma_samples = height = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    if (bitReader.readU1()) {
        // sps_conf_win_left_offset
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        // sps_conf_win_right_offset
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        // sps_conf_win_top_offset
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        // sps_conf_win_bottom_offset
        avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    }
    if (bitReader.readU1()) {
        const sps_num_subpics_minus1 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
        const ctb_log2_size_y = sps_log2_ctu_size_minus5 + 5;
        const ctb_size_y = 1 << ctb_log2_size_y;
        const tmp_width_val = sps_pic_width_max_in_luma_samples / (1 << ctb_log2_size_y);
        const tmp_height_val = sps_pic_height_max_in_luma_samples / (1 << ctb_log2_size_y);
        const wlen = Math.ceil(Math.log2(tmp_width_val));
        const hlen = Math.ceil(Math.log2(tmp_height_val));
        let sps_subpic_id_len = 0;
        let sps_subpic_same_size_flag = 0;
        let sps_independent_subpics_flag = 0;
        // sps_num_subpics_minus1
        if (sps_num_subpics_minus1 > 0) {
            sps_independent_subpics_flag = bitReader.readU1();
            sps_subpic_same_size_flag = bitReader.readU1();
        }
        for (let i = 0; sps_num_subpics_minus1 > 0 && i <= sps_num_subpics_minus1; i++) {
            if (!sps_subpic_same_size_flag || i == 0) {
                if (i > 0 && sps_pic_width_max_in_luma_samples > ctb_size_y) {
                    bitReader.readU(wlen);
                }
                if (i > 0 && sps_pic_height_max_in_luma_samples > ctb_size_y) {
                    bitReader.readU(hlen);
                }
                if (i < sps_num_subpics_minus1 && sps_pic_width_max_in_luma_samples > ctb_size_y) {
                    bitReader.readU(wlen);
                }
                if (i < sps_num_subpics_minus1 && sps_pic_height_max_in_luma_samples > ctb_size_y) {
                    bitReader.readU(hlen);
                }
            }
            if (!sps_independent_subpics_flag) {
                // sps_subpic_treated_as_pic_flag && sps_loop_filter_across_subpic_enabled_flag
                bitReader.readU(2);
            }
        }
        sps_subpic_id_len = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader) + 1;
        // sps_subpic_id_mapping_explicitly_signalled_flag
        if (bitReader.readU(1)) {
            // sps_subpic_id_mapping_present_flag
            if (bitReader.readU(1)) {
                for (let i = 0; i <= sps_num_subpics_minus1; i++) {
                    // sps_subpic_id[i]
                    bitReader.readU(sps_subpic_id_len);
                }
            }
        }
    }
    bitDepthMinus8 = avutil_util_expgolomb__WEBPACK_IMPORTED_MODULE_11__.readUE(bitReader);
    return {
        profile,
        level,
        width,
        height,
        chromaFormatIdc,
        bitDepthMinus8,
        generalProfileSpace,
        tierFlag,
        generalConstraintInfo,
        generalSubProfileIdc,
        ptlFrameOnlyConstraintFlag,
        ptlMultilayerEnabledFlag,
        spsMaxSublayersMinus1,
        ptlSublayerLevelPresentFlag,
        sublayerLevelIdc
    };
}
function parseExtraData(extradata) {
    const bitReader = new common_io_BitReader__WEBPACK_IMPORTED_MODULE_1__["default"]();
    bitReader.appendBuffer(extradata);
    const ptlPresentFlag = bitReader.readU(8) & 0x01;
    if (ptlPresentFlag) {
        return parsePTL(bitReader);
    }
    return {};
}


/***/ }),

/***/ "./src/avformat/config.ts":
/*!********************************!*\
  !*** ./src/avformat/config.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DURATION_MAX_READ_SIZE: () => (/* binding */ DURATION_MAX_READ_SIZE),
/* harmony export */   SAMPLE_INDEX_STEP: () => (/* binding */ SAMPLE_INDEX_STEP)
/* harmony export */ });
/*
 * libmedia avformat config
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const DURATION_MAX_READ_SIZE = 256000;
const SAMPLE_INDEX_STEP = BigInt(5000);


/***/ }),

/***/ "./src/avformat/demux.ts":
/*!*******************************!*\
  !*** ./src/avformat/demux.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   analyzeStreams: () => (/* binding */ analyzeStreams),
/* harmony export */   open: () => (/* binding */ open),
/* harmony export */   readAVPacket: () => (/* binding */ readAVPacket),
/* harmony export */   seek: () => (/* binding */ seek)
/* harmony export */ });
/* unused harmony export DefaultDemuxOptions */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../avutil/struct/rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var _function_checkStreamParameters__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./function/checkStreamParameters */ "./src/avformat/function/checkStreamParameters.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config */ "./src/avformat/config.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avcodec_wasmcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avcodec/wasmcodec/VideoDecoder */ "./src/avcodec/wasmcodec/VideoDecoder.ts");
/* harmony import */ var avcodec_wasmcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avcodec/wasmcodec/AudioDecoder */ "./src/avcodec/wasmcodec/AudioDecoder.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
var cheap__fileName__0 = "src/avformat/demux.ts";
















const DefaultDemuxOptions = {
    fastOpen: false,
    maxAnalyzeDuration: 1000
};
// @ts-ignore
async function open(formatContext, options = {}) {
    const opts = common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend({}, DefaultDemuxOptions, options);
    if (!formatContext.ioReader) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('need IOReader', cheap__fileName__0, 65);
    }
    if (!formatContext.iformat) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('need iformat', cheap__fileName__0, 68);
    }
    if (formatContext.iformat.type === 2 /* AVFormat.MPEGTS */) {
        // mpegts 的最小分析时长为 2 秒，mpegts 的 dts 一般从 1.4 秒开始
        opts.maxAnalyzeDuration = Math.max(opts.maxAnalyzeDuration, 2000);
    }
    formatContext.format = formatContext.iformat.type;
    formatContext.iformat.init(formatContext);
    formatContext.options = opts;
    return formatContext.iformat.readHeader(formatContext);
}
// @ts-ignore
async function estimateDurationFromPts(formatContext) {
    const fileSize = await formatContext.ioReader.fileSize();
    if (fileSize <= BigInt(0)) {
        return;
    }
    const cache = formatContext.interval.packetBuffer;
    formatContext.interval.packetBuffer = [];
    let now = formatContext.ioReader.getPos();
    let retry = 0;
    while (retry < 4) {
        const pos = fileSize - BigInt(Math.floor(_config__WEBPACK_IMPORTED_MODULE_2__.DURATION_MAX_READ_SIZE << retry));
        const nextPos = await formatContext.iformat.seek(formatContext, null, pos, 2 /* AVSeekFlags.BYTE */);
        if (nextPos > BigInt(0)) {
            now = nextPos;
        }
        const lastDurationMap = {};
        const avpacket = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.createAVPacket)();
        while (true) {
            const ret = await readAVPacket(formatContext, avpacket);
            if (ret < 0) {
                break;
            }
            else {
                let duration = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8);
                const stream = formatContext.getStreamByIndex(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 32));
                if (stream.startTime !== avutil_constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE_BIGINT) {
                    duration -= stream.startTime;
                }
                else {
                    duration -= stream.firstDTS;
                }
                if (duration > BigInt(0)) {
                    if (stream.duration === avutil_constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE_BIGINT
                        || !lastDurationMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 32)]
                        || (stream.duration < duration
                            && Math.abs(Number(duration - stream.duration)) < 60 * stream.timeBase.den / stream.timeBase.num)) {
                        stream.duration = duration;
                    }
                    lastDurationMap[avpacket.streamIndex] = duration;
                }
            }
        }
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(avpacket);
        let hasDuration = true;
        common_util_array__WEBPACK_IMPORTED_MODULE_6__.each(formatContext.streams, (stream) => {
            if (stream.duration === avutil_constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE_BIGINT) {
                hasDuration = false;
                return false;
            }
        });
        if (hasDuration) {
            break;
        }
        retry++;
    }
    common_util_array__WEBPACK_IMPORTED_MODULE_6__.each(formatContext.interval.packetBuffer, (avpacket) => {
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(avpacket);
    });
    formatContext.interval.packetBuffer = cache;
    await formatContext.iformat.seek(formatContext, null, now, 2 /* AVSeekFlags.BYTE */);
}
// @ts-ignore
async function analyzeStreams(formatContext) {
    const needStreams = formatContext.iformat.getAnalyzeStreamsCount();
    const streamFirstGotMap = {};
    const streamDtsMap = {};
    const streamBitMap = {};
    let avpacket = 0;
    const caches = [];
    let ret = 0;
    const decoderMap = {};
    const pictureGot = {};
    function checkPictureGot() {
        if (!formatContext.getDecoderResource) {
            return true;
        }
        for (let i = 0; i < formatContext.streams.length; i++) {
            if (decoderMap[formatContext.streams[i].index] && !pictureGot[formatContext.streams[i].index]) {
                return false;
            }
        }
        return true;
    }
    while (true) {
        if (formatContext.streams.length >= needStreams
            && (0,_function_checkStreamParameters__WEBPACK_IMPORTED_MODULE_7__.checkStreamParameters)(formatContext)
            && formatContext.options.fastOpen
            && checkPictureGot()) {
            break;
        }
        if (!avpacket) {
            avpacket = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.createAVPacket)();
        }
        let packetCached = false;
        ret = await readAVPacket(formatContext, avpacket);
        if (ret !== 0) {
            break;
        }
        const stream = formatContext.getStreamByIndex(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 32));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 28)) {
            packetCached = true;
            caches.push(avpacket);
            if (!streamFirstGotMap[stream.index]) {
                stream.firstDTS = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 16);
                stream.startTime = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8);
                streamFirstGotMap[stream.index] = true;
            }
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8) < stream.startTime) {
                stream.startTime = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8);
            }
            if (streamDtsMap[stream.index]) {
                streamDtsMap[stream.index].push(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 16));
            }
            else {
                streamDtsMap[stream.index] = [cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 16)];
            }
            if (streamBitMap[stream.index]) {
                streamBitMap[stream.index] += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 28);
            }
            else {
                streamBitMap[stream.index] = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 28);
            }
            if (!pictureGot[stream.index] && formatContext.getDecoderResource) {
                let decoder = decoderMap[stream.index];
                if (!decoder) {
                    const resource = await formatContext.getDecoderResource(stream.codecpar.codecType, stream.codecpar.codecId);
                    if (resource) {
                        if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                            decoder = new avcodec_wasmcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_8__["default"]({
                                resource,
                                onReceiveFrame: (avframe) => {
                                    stream.codecpar.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avframe + 80);
                                    (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_9__.destroyAVFrame)(avframe);
                                    pictureGot[stream.index] = true;
                                },
                                onError: () => {
                                    pictureGot[stream.index] = true;
                                }
                            });
                        }
                        else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                            if (resource.threadModule) {
                                delete resource.threadModule;
                            }
                            decoder = new avcodec_wasmcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_10__["default"]({
                                resource,
                                onReceiveFrame: (avframe) => {
                                    stream.codecpar.format = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avframe + 80);
                                    stream.codecpar.colorSpace = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avframe + 220);
                                    stream.codecpar.colorPrimaries = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avframe + 212);
                                    stream.codecpar.colorTrc = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avframe + 216);
                                    stream.codecpar.chromaLocation = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avframe + 224);
                                    stream.codecpar.sampleAspectRatio = (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_11__["default"])(avframe + 92, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_12__.Rational);
                                    (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_9__.destroyAVFrame)(avframe);
                                    pictureGot[stream.index] = true;
                                },
                                onError: () => {
                                    pictureGot[stream.index] = true;
                                }
                            });
                        }
                        await decoder.open(stream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_13__.symbolStructAddress]);
                        decoderMap[stream.index] = decoder;
                    }
                }
                if (decoder) {
                    decoder.decode(avpacket);
                }
            }
        }
        if (streamDtsMap[stream.index] && streamDtsMap[stream.index].length === 12) {
            let count = BigInt(0);
            for (let i = 1; i < streamDtsMap[stream.index].length; i++) {
                count += streamDtsMap[stream.index][i] - streamDtsMap[stream.index][i - 1];
            }
            let value = Number(count) / (streamDtsMap[stream.index].length - 1);
            if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */
                && stream.codecpar.sampleRate > 0) {
                stream.codecpar.frameSize = Math.round(value / stream.timeBase.den * stream.timeBase.num * stream.codecpar.sampleRate);
            }
            else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                const framerate = stream.timeBase.den * stream.timeBase.num / value;
                stream.codecpar.framerate.num = Math.round(framerate);
                stream.codecpar.framerate.den = 1;
            }
            const duration = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 16) - stream.firstDTS) * stream.timeBase.num / stream.timeBase.den;
            if (duration) {
                stream.codecpar.bitRate = BigInt(Math.floor(streamBitMap[stream.index] * 8 / duration));
            }
        }
        if ((cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 16) - stream.startTime) > (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_14__.avRescaleQ)(BigInt(Math.floor(formatContext.options.maxAnalyzeDuration)), avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q, stream.timeBase)) {
            common_util_object__WEBPACK_IMPORTED_MODULE_0__.each(streamDtsMap, (list, id) => {
                const stream = formatContext.getStreamById(+id);
                if (list && list.length > 1) {
                    let count = BigInt(0);
                    for (let i = 1; i < list.length; i++) {
                        count += list[i] - list[i - 1];
                    }
                    let value = Number(count) / (streamDtsMap[stream.index].length - 1);
                    if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */
                        && stream.codecpar.sampleRate > 0) {
                        stream.codecpar.frameSize = Math.round(value / stream.timeBase.den * stream.timeBase.num * stream.codecpar.sampleRate);
                    }
                    else if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                        const framerate = stream.timeBase.den * stream.timeBase.num / value;
                        stream.codecpar.framerate.num = Math.round(framerate);
                        stream.codecpar.framerate.den = 1;
                    }
                    const duration = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 16) - stream.firstDTS) * stream.timeBase.num / stream.timeBase.den;
                    if (duration) {
                        stream.codecpar.bitRate = BigInt(Math.floor(streamBitMap[stream.index] * 8 / duration));
                    }
                }
            });
            if (packetCached) {
                avpacket = 0;
            }
            break;
        }
        if (packetCached) {
            avpacket = 0;
        }
    }
    if (avpacket) {
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(avpacket);
    }
    if (caches.length) {
        formatContext.interval.packetBuffer = caches.concat(formatContext.interval.packetBuffer);
    }
    common_util_object__WEBPACK_IMPORTED_MODULE_0__.each(decoderMap, (decoder) => {
        if (decoder) {
            decoder.close();
        }
    });
    if (ret === -1048576 /* IOError.END */) {
        return 0;
    }
    else if (ret !== 0) {
        return ret;
    }
    if ((formatContext.iformat.type === 2 /* AVFormat.MPEGTS */)
        && (formatContext.ioReader.flags & 1 /* IOFlags.SEEKABLE */)) {
        await estimateDurationFromPts(formatContext);
    }
    return 0;
}
function addSample(stream, avpacket) {
    const index = common_util_array__WEBPACK_IMPORTED_MODULE_6__.binarySearch(stream.sampleIndexes, (sample) => {
        if (sample.pts < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8)) {
            return 1;
        }
        else {
            return -1;
        }
    });
    const sample = {
        dts: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 16),
        pts: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8),
        pos: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 56),
        size: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 28),
        duration: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 48),
        flags: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 36)
    };
    if (index > -1) {
        stream.sampleIndexesPosMap.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 56), index);
        stream.sampleIndexes.splice(index, 0, sample);
    }
    else {
        stream.sampleIndexesPosMap.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 56), stream.sampleIndexes.length);
        stream.sampleIndexes.push(sample);
    }
}
// @ts-ignore
async function packetNeedRead(formatContext, avpacket) {
    const stream = formatContext.getStreamById(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 32));
    let ret = 0;
    // h264 hevc aac 解析到 extradata，继续
    if (stream
        && (stream.codecpar.codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */
            || stream.codecpar.codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
            || stream.codecpar.codecId === 196 /* AVCodecID.AV_CODEC_ID_VVC */
            || stream.codecpar.codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */)) {
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 28)
            && (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.hasAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */)) {
            while (1) {
                const tmpPacket = (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.createAVPacket)();
                ret = await formatContext.iformat.readAVPacket(formatContext, tmpPacket);
                if (ret !== 0) {
                    if (formatContext.interval.packetBuffer.length) {
                        let cache = formatContext.interval.packetBuffer.shift();
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.unrefAVPacket)(avpacket);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.refAVPacket)(avpacket, cache);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(cache);
                        return packetNeedRead(formatContext, avpacket);
                    }
                    return ret;
                }
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](tmpPacket + 32) === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 32)) {
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](tmpPacket + 28)) {
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.copyAVPacketData)(avpacket, tmpPacket);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(tmpPacket);
                        return 0;
                    }
                    else {
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.unrefAVPacket)(avpacket);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.refAVPacket)(avpacket, tmpPacket);
                        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(tmpPacket);
                        continue;
                    }
                }
                else {
                    formatContext.interval.packetBuffer.push(tmpPacket);
                }
            }
        }
        else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 36) & 32 /* AVPacketFlags.AV_PKT_FLAG_END */) {
            return readAVPacket(formatContext, avpacket);
        }
    }
    if (formatContext.ioReader.flags & 1 /* IOFlags.SEEKABLE */) {
        if (!stream.sampleIndexesPosMap.has(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 56))) {
            if (stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                    addSample(stream, avpacket);
                }
            }
            else if (stream.codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                const index = common_util_array__WEBPACK_IMPORTED_MODULE_6__.binarySearch(stream.sampleIndexes, (sample) => {
                    if (sample.pts < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8)) {
                        return 1;
                    }
                    else {
                        return -1;
                    }
                });
                if (!stream.sampleIndexes.length
                    || (index < 0
                        && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_14__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8) - stream.sampleIndexes[stream.sampleIndexes.length - 1].pts, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_11__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_12__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q) >= _config__WEBPACK_IMPORTED_MODULE_2__.SAMPLE_INDEX_STEP)
                    || (index > 0
                        && index < stream.sampleIndexes.length - 1
                        && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_14__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8) - stream.sampleIndexes[index - 1].pts, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_11__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_12__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q) >= _config__WEBPACK_IMPORTED_MODULE_2__.SAMPLE_INDEX_STEP)
                    || (index === 0
                        && (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_14__.avRescaleQ)(stream.sampleIndexes[0].pts - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](avpacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_11__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_12__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q) >= _config__WEBPACK_IMPORTED_MODULE_2__.SAMPLE_INDEX_STEP)) {
                    addSample(stream, avpacket);
                }
            }
        }
    }
    return 0;
}
// @ts-ignore
async function readAVPacket(formatContext, avpacket) {
    let ret = 0;
    (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.unrefAVPacket)(avpacket);
    if (formatContext.interval.packetBuffer.length) {
        const cache = formatContext.interval.packetBuffer.shift();
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.refAVPacket)(avpacket, cache);
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(cache);
        return packetNeedRead(formatContext, avpacket);
    }
    ret = await formatContext.iformat.readAVPacket(formatContext, avpacket);
    if (ret !== 0) {
        (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.unrefAVPacket)(avpacket);
        return ret;
    }
    return packetNeedRead(formatContext, avpacket);
}
// @ts-ignore
async function seek(formatContext, streamIndex, timestamp, flags) {
    let stream = formatContext.streams[streamIndex];
    if (!stream) {
        stream = formatContext.getStreamByMediaType(0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
        if (!stream) {
            stream = formatContext.getStreamByMediaType(1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */);
        }
    }
    if (!stream) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.error(`not found any stream to seek, streamIndex: ${stream.index}`, cheap__fileName__0, 540);
        return BigInt(avutil_error__WEBPACK_IMPORTED_MODULE_15__.DATA_INVALID);
    }
    common_util_logger__WEBPACK_IMPORTED_MODULE_1__.debug(`seek in ${stream.codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */
        ? 'video'
        : 'audio'} stream, streamIndex: ${stream.index}, timestamp: ${timestamp}, flags: ${flags}`, cheap__fileName__0, 544);
    timestamp = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_14__.avRescaleQ)(timestamp, avutil_constant__WEBPACK_IMPORTED_MODULE_5__.AV_MILLI_TIME_BASE_Q, stream.timeBase);
    const ret = await formatContext.iformat.seek(formatContext, stream, timestamp, flags);
    if (ret >= BigInt(0)) {
        common_util_array__WEBPACK_IMPORTED_MODULE_6__.each(formatContext.interval.packetBuffer, (avpacket) => {
            (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_3__.destroyAVPacket)(avpacket);
        });
        formatContext.interval.packetBuffer.length = 0;
        return BigInt(0);
    }
    return ret;
}


/***/ }),

/***/ "./src/avformat/dump.ts":
/*!******************************!*\
  !*** ./src/avformat/dump.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ dump),
/* harmony export */   dumpCodecName: () => (/* binding */ dumpCodecName)
/* harmony export */ });
/* unused harmony exports dumpTime, dumpInt64, dumpBitrate, dumpKey */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../avutil/struct/rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/stringEnum */ "./src/avutil/stringEnum.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/string */ "./src/common/util/string.ts");
/* harmony import */ var common_function_toString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/function/toString */ "./src/common/function/toString.ts");
/* harmony import */ var _codecs_aac__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./codecs/aac */ "./src/avformat/codecs/aac.ts");
/* harmony import */ var _codecs_h264__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./codecs/h264 */ "./src/avformat/codecs/h264.ts");
/* harmony import */ var _codecs_hevc__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./codecs/hevc */ "./src/avformat/codecs/hevc.ts");
/* harmony import */ var _codecs_av1__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./codecs/av1 */ "./src/avformat/codecs/av1.ts");
/* harmony import */ var _codecs_vp9__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./codecs/vp9 */ "./src/avformat/codecs/vp9.ts");
/* harmony import */ var _codecs_mp3__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./codecs/mp3 */ "./src/avformat/codecs/mp3.ts");
















function dumpTime(time) {
    const ms = (Number(time % BigInt(1000) & 0xffffffffn) >> 0);
    const secs = (Number(time / BigInt(1000) % BigInt(60) & 0xffffffffn) >> 0);
    const mins = (Number(time / BigInt(1000) / BigInt(60) % BigInt(60) & 0xffffffffn) >> 0);
    const hours = (Number(time / BigInt(1000) / BigInt(3600) & 0xffffffffn) >> 0);
    return common_util_string__WEBPACK_IMPORTED_MODULE_0__.format('%02d:%02d:%02d.%03d', hours, mins, secs, ms);
}
function dumpInt64(v) {
    if (v < BigInt(10000)) {
        return (0,common_function_toString__WEBPACK_IMPORTED_MODULE_1__["default"])((Number(v & 0xffffffffn) >> 0));
    }
    return (Number(v / BigInt(1000) & 0xffffffffn) >> 0) + 'k';
}
function dumpBitrate(v) {
    if (v < BigInt(10000)) {
        return (0,common_function_toString__WEBPACK_IMPORTED_MODULE_1__["default"])((Number(v & 0xffffffffn) >> 0)) + ' bps/s';
    }
    return (Number(v / BigInt(1000) & 0xffffffffn) >> 0) + ' kbps/s';
}
function dumpKey(obj, value, defaultValue = 'unknown') {
    let name = defaultValue;
    common_util_object__WEBPACK_IMPORTED_MODULE_2__.each(obj, (v, k) => {
        if (value === v) {
            name = k;
            return false;
        }
    });
    return name;
}
function dumpCodecName(stream) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
        return dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.AudioCodecString2CodecId, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 4));
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
        return dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.VideoCodecString2CodecId, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 4));
    }
    return 'unknown';
}
function dumpProfileName(codecId, profile) {
    switch (codecId) {
        case 86018 /* AVCodecID.AV_CODEC_ID_AAC */:
            return _codecs_aac__WEBPACK_IMPORTED_MODULE_5__.AACProfile2Name[profile] || 'LC';
        case 86017 /* AVCodecID.AV_CODEC_ID_MP3 */:
            return _codecs_mp3__WEBPACK_IMPORTED_MODULE_6__.MP3Profile2Name[profile] || 'Layer3';
        case 27 /* AVCodecID.AV_CODEC_ID_H264 */:
            return _codecs_h264__WEBPACK_IMPORTED_MODULE_7__.H264Profile2Name[profile] || 'High';
        case 173 /* AVCodecID.AV_CODEC_ID_HEVC */:
            return _codecs_hevc__WEBPACK_IMPORTED_MODULE_8__.HEVCProfile2Name[profile] || 'Main';
        case 225 /* AVCodecID.AV_CODEC_ID_AV1 */:
            return _codecs_av1__WEBPACK_IMPORTED_MODULE_9__.AV1Profile2Name[profile] || 'Main';
        case 167 /* AVCodecID.AV_CODEC_ID_VP9 */:
            return _codecs_vp9__WEBPACK_IMPORTED_MODULE_10__.VP9Profile2Name[profile] || 'Profile0';
    }
}
function dumpAVStreamInterface(stream, index, prefix) {
    const mediaType = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.mediaType2AVMediaType, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar));
    const list = [];
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
        const profileName = dumpProfileName(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 48));
        const codecName = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.AudioCodecString2CodecId, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 4));
        list.push(`${codecName}${profileName ? ` (${profileName})` : ''}`);
        list.push(`${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 136)} Hz`);
        let channel = `${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 116)} channels`;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 116) === 1) {
            channel = 'mono';
        }
        else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 116) === 2) {
            channel = 'stereo';
        }
        list.push(channel);
        list.push(dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.SampleFmtString2SampleFormat, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 28)));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](stream.codecpar + 32) > BigInt(0)) {
            list.push(`${dumpBitrate(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](stream.codecpar + 32))}`);
        }
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
        const profileName = dumpProfileName(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 48));
        const codecName = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.VideoCodecString2CodecId, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 4));
        list.push(`${codecName}${profileName ? ` (${profileName})` : ''}`);
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 28) !== avutil_constant__WEBPACK_IMPORTED_MODULE_11__.NOPTS_VALUE) {
            const pixfmt = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.PixfmtString2AVPixelFormat, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 28));
            const range = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.colorRange2AVColorRange, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 84), 'tv');
            const space = dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.colorSpace2AVColorSpace, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 96), 'bt709');
            list.push(`${pixfmt}(${range}, ${space})`);
        }
        const dar = {
            num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 56) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 64),
            den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 60) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 68)
        };
        (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_12__.avReduce)(dar);
        list.push(`${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 56)}x${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 60)} [SAR: ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 64)}:${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.codecpar + 68)} DAR ${dar.num}:${dar.den}]`);
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](stream.codecpar + 32) > BigInt(0)) {
            list.push(`${dumpBitrate(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](stream.codecpar + 32))}`);
        }
        if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_12__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_13__["default"])(stream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_14__.Rational)) > 0) {
            list.push(`${(0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_12__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_13__["default"])(stream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_14__.Rational)).toFixed(2)} fps`);
            list.push(`${(0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_12__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_13__["default"])(stream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_14__.Rational)).toFixed(2)} tbr`);
        }
        list.push(`${dumpInt64(BigInt(Math.floor((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_12__.avQ2D)({
            num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.timeBase + 4),
            den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](stream.timeBase)
        }))))} tbn`);
        if (stream.disposition) {
            let disposition = '';
            if (stream.disposition & 1 /* AVDisposition.DEFAULT */) {
                disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.disposition2AVDisposition, 1 /* AVDisposition.DEFAULT */)}) `;
            }
            if (stream.disposition & 2 /* AVDisposition.DUB */) {
                disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.disposition2AVDisposition, 2 /* AVDisposition.DUB */)}) `;
            }
            if (stream.disposition & 4 /* AVDisposition.ORIGINAL */) {
                disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.disposition2AVDisposition, 4 /* AVDisposition.ORIGINAL */)}) `;
            }
            if (stream.disposition & 8 /* AVDisposition.COMMENT */) {
                disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.disposition2AVDisposition, 8 /* AVDisposition.COMMENT */)}) `;
            }
            if (stream.disposition & 16 /* AVDisposition.LYRICS */) {
                disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.disposition2AVDisposition, 16 /* AVDisposition.LYRICS */)}) `;
            }
            if (stream.disposition & 32 /* AVDisposition.KARAOKE */) {
                disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.disposition2AVDisposition, 32 /* AVDisposition.KARAOKE */)}) `;
            }
            if (stream.disposition & 64 /* AVDisposition.FORCED */) {
                disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.disposition2AVDisposition, 64 /* AVDisposition.FORCED */)}) `;
            }
            if (stream.disposition & 128 /* AVDisposition.HEARING_IMPAIRED */) {
                disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.disposition2AVDisposition, 128 /* AVDisposition.HEARING_IMPAIRED */)}) `;
            }
            if (stream.disposition & 256 /* AVDisposition.VISUAL_IMPAIRED */) {
                disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.disposition2AVDisposition, 256 /* AVDisposition.VISUAL_IMPAIRED */)}) `;
            }
            if (stream.disposition & 512 /* AVDisposition.CLEAN_EFFECTS */) {
                disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.disposition2AVDisposition, 512 /* AVDisposition.CLEAN_EFFECTS */)}) `;
            }
            if (stream.disposition & 1024 /* AVDisposition.ATTACHED_PIC */) {
                disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.disposition2AVDisposition, 1024 /* AVDisposition.ATTACHED_PIC */)}) `;
            }
            if (stream.disposition & 2048 /* AVDisposition.TIMED_THUMBNAILS */) {
                disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.disposition2AVDisposition, 2048 /* AVDisposition.TIMED_THUMBNAILS */)}) `;
            }
            if (stream.disposition & 65536 /* AVDisposition.CAPTIONS */) {
                disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.disposition2AVDisposition, 65536 /* AVDisposition.CAPTIONS */)}) `;
            }
            if (stream.disposition & 131072 /* AVDisposition.DESCRIPTIONS */) {
                disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.disposition2AVDisposition, 131072 /* AVDisposition.DESCRIPTIONS */)}) `;
            }
            if (stream.disposition & 262144 /* AVDisposition.METADATA */) {
                disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.disposition2AVDisposition, 262144 /* AVDisposition.METADATA */)}) `;
            }
            if (stream.disposition & 524288 /* AVDisposition.DEPENDENT */) {
                disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.disposition2AVDisposition, 524288 /* AVDisposition.DEPENDENT */)}) `;
            }
            if (stream.disposition & 1048576 /* AVDisposition.STILL_IMAGE */) {
                disposition += `(${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.disposition2AVDisposition, 1048576 /* AVDisposition.STILL_IMAGE */)}) `;
            }
            if (disposition) {
                list.push(disposition);
            }
        }
    }
    else {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](stream.codecpar + 32) > BigInt(0)) {
            list.push(`${dumpBitrate(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](stream.codecpar + 32))}`);
        }
    }
    let dump = `${prefix}Stream #${index}:${stream.index} ${mediaType}: ${list.join(', ')}\n`;
    if (Object.keys(stream.metadata).length) {
        dump += `${prefix}  Metadata:\n`;
        common_util_object__WEBPACK_IMPORTED_MODULE_2__.each(stream.metadata, (value, key) => {
            if (!common_util_is__WEBPACK_IMPORTED_MODULE_15__.object(value) || !common_util_is__WEBPACK_IMPORTED_MODULE_15__.array(value)) {
                dump += `${prefix}    ${key}: ${value}\n`;
            }
        });
    }
    return dump;
}
function dumpAVFormatContextInterface(formatContext, index, input) {
    let dump = `${input.tag} #${index}, ${dumpKey(avutil_stringEnum__WEBPACK_IMPORTED_MODULE_4__.Format2AVFormat, formatContext.format)}, from '${input.from}:'\n`;
    if (Object.keys(formatContext.metadata).length) {
        dump += `  Metadata:\n`;
        common_util_object__WEBPACK_IMPORTED_MODULE_2__.each(formatContext.metadata, (value, key) => {
            if (!common_util_is__WEBPACK_IMPORTED_MODULE_15__.object(value) || !common_util_is__WEBPACK_IMPORTED_MODULE_15__.array(value)) {
                dump += `    ${key}: ${value}\n`;
            }
        });
    }
    let duration = BigInt(0);
    let bitrate = BigInt(0);
    let start = -BigInt(1);
    formatContext.streams.forEach((stream) => {
        const d = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_12__.avRescaleQ)(stream.duration, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_13__["default"])(stream.timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_14__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_11__.AV_MILLI_TIME_BASE_Q);
        const s = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_12__.avRescaleQ)(stream.startTime, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_13__["default"])(stream.timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_14__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_11__.AV_MILLI_TIME_BASE_Q);
        if (d > duration) {
            duration = d;
        }
        if (s < start || start === -BigInt(1)) {
            start = s;
        }
        bitrate += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](stream.codecpar + 32);
    });
    dump += `  Duration: ${dumpTime(duration)}, start: ${dumpTime(start)}, bitrate: ${dumpBitrate(bitrate)}\n`;
    formatContext.streams.forEach((stream, i) => {
        dump += dumpAVStreamInterface(stream, index, '  ');
    });
    return dump;
}
function dump(formatContexts, inputs) {
    let dump = '';
    formatContexts.forEach((formatContext, index) => {
        dump += dumpAVFormatContextInterface(formatContext, index, inputs[index]);
    });
    return dump;
}


/***/ }),

/***/ "./src/avformat/function/checkStreamParameters.ts":
/*!********************************************************!*\
  !*** ./src/avformat/function/checkStreamParameters.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkStreamParameters: () => (/* binding */ checkStreamParameters)
/* harmony export */ });
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/*
 * libmedia check stream parameters
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function checkStreamParameters(context) {
    let result = true;
    common_util_array__WEBPACK_IMPORTED_MODULE_0__.each(context.streams, (stream) => {
        switch (stream.codecpar.codecType) {
            case 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */:
                if (stream.codecpar.chLayout.nbChannels === avutil_constant__WEBPACK_IMPORTED_MODULE_1__.NOPTS_VALUE
                    || stream.codecpar.sampleRate === avutil_constant__WEBPACK_IMPORTED_MODULE_1__.NOPTS_VALUE
                    || stream.codecpar.frameSize === avutil_constant__WEBPACK_IMPORTED_MODULE_1__.NOPTS_VALUE
                    || stream.codecpar.bitRate === BigInt(0)) {
                    result = false;
                }
                break;
            case 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */:
                if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_2__.avQ2D)(stream.codecpar.framerate) === 0
                    || stream.codecpar.width === avutil_constant__WEBPACK_IMPORTED_MODULE_1__.NOPTS_VALUE
                    || stream.codecpar.height === avutil_constant__WEBPACK_IMPORTED_MODULE_1__.NOPTS_VALUE
                    || stream.codecpar.bitRate === BigInt(0)) {
                    result = false;
                }
                if ((stream.codecpar.codecId === 27 /* AVCodecID.AV_CODEC_ID_H264 */
                    || stream.codecpar.codecId === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                    || stream.codecpar.codecId === 196 /* AVCodecID.AV_CODEC_ID_VVC */
                    || stream.codecpar.codecId === 12 /* AVCodecID.AV_CODEC_ID_MPEG4 */)
                    && (stream.codecpar.profile === avutil_constant__WEBPACK_IMPORTED_MODULE_1__.NOPTS_VALUE
                        || stream.codecpar.level === avutil_constant__WEBPACK_IMPORTED_MODULE_1__.NOPTS_VALUE)) {
                    result = false;
                }
                break;
        }
    });
    return result;
}


/***/ }),

/***/ "./src/avformat/mux.ts":
/*!*****************************!*\
  !*** ./src/avformat/mux.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   flush: () => (/* binding */ flush),
/* harmony export */   open: () => (/* binding */ open),
/* harmony export */   writeAVPacket: () => (/* binding */ writeAVPacket),
/* harmony export */   writeHeader: () => (/* binding */ writeHeader),
/* harmony export */   writeTrailer: () => (/* binding */ writeTrailer)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avformat/mux.ts";




const defaultMuxOptions = {
    paddingZero: false
};
function open(formatContext, options = {}) {
    const opts = common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend({}, defaultMuxOptions, options);
    if (!formatContext.ioWriter) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('need ioWriter', cheap__fileName__0, 46);
    }
    if (!formatContext.oformat) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('need oformat', cheap__fileName__0, 49);
    }
    formatContext.options = opts;
    formatContext.processPrivateData = {
        first: new Map()
    };
    return formatContext.oformat.init(formatContext);
}
function writeHeader(formatContext) {
    formatContext.oformat.writeHeader(formatContext);
}
function writeAVPacket(formatContext, avpacket) {
    const privateData = formatContext.processPrivateData;
    if (!privateData.first.has(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avpacket + 32))) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16) > BigInt(0)) {
            privateData.first.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avpacket + 32), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16));
        }
        else {
            privateData.first.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avpacket + 32), BigInt(0));
        }
    }
    if (formatContext.options.paddingZero) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](avpacket + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 16) - privateData.first.get(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avpacket + 32)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](avpacket + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](avpacket + 8) - privateData.first.get(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](avpacket + 32)));
    }
    return formatContext.oformat.writeAVPacket(formatContext, avpacket);
}
function writeTrailer(formatContext) {
    formatContext.oformat.writeTrailer(formatContext);
}
function flush(formatContext) {
    formatContext.oformat.flush(formatContext);
}


/***/ }),

/***/ "./src/avnetwork/ioLoader/FetchIOLoader.ts":
/*!*************************************************!*\
  !*** ./src/avnetwork/ioLoader/FetchIOLoader.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FetchIOLoader)
/* harmony export */ });
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
/* harmony import */ var _IOLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IOLoader */ "./src/avnetwork/ioLoader/IOLoader.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avnetwork/ioLoader/FetchIOLoader.ts";
/*
 * libmedia fetch loader
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




class FetchIOLoader extends _IOLoader__WEBPACK_IMPORTED_MODULE_0__["default"] {
    contentLength;
    receivedLength;
    info;
    range;
    startBytes;
    endBytes;
    eofIndex;
    abortController;
    reader;
    buffers;
    constructor(options = {}) {
        super(options);
    }
    async open(info, range) {
        this.info = info;
        this.range = range;
        if (!this.range.to) {
            this.range.to = -1;
        }
        this.range.from = Math.max(this.range.from, 0);
        if (this.eofIndex < 0) {
            this.eofIndex = range.to;
        }
        this.startBytes = 0;
        this.endBytes = -1;
        this.receivedLength = 0;
        this.buffers = [];
        if (this.range && !this.options.isLive) {
            this.startBytes = this.range.from ?? 0;
        }
        this.status = 1 /* IOLoaderStatus.CONNECTING */;
        if (!this.options.isLive && !this.options.disableSegment) {
            const params = {
                method: 'HEAD',
                headers: {},
                mode: 'cors',
                cache: 'default',
                referrerPolicy: 'no-referrer-when-downgrade'
            };
            if (this.info.headers) {
                common_util_object__WEBPACK_IMPORTED_MODULE_1__.each(this.info.headers, (value, key) => {
                    params.headers[key] = value;
                });
            }
            if (this.info.withCredentials) {
                params.credentials = 'include';
            }
            if (this.info.referrerPolicy) {
                params.referrerPolicy = this.info.referrerPolicy;
            }
            if (AbortController) {
                this.abortController = new AbortController();
                params.signal = this.abortController.signal;
            }
            try {
                const res = await fetch(this.info.url, params);
                if (res.ok && (res.status >= 200 && res.status <= 299)) {
                    const lengthHeader = res.headers.get('X-Content-Length') || res.headers.get('Content-Length');
                    if (lengthHeader != null) {
                        this.contentLength = parseInt(lengthHeader);
                        if (this.range.to < 0) {
                            this.eofIndex = this.contentLength + this.range.to;
                        }
                    }
                    this.endBytes = Math.min(this.startBytes + this.options.preload - 1, this.eofIndex);
                    this.status = 2 /* IOLoaderStatus.BUFFERING */;
                }
                else {
                    this.endBytes = -1;
                }
            }
            catch (error) {
                this.endBytes = -1;
            }
        }
    }
    async openReader() {
        const params = {
            method: 'GET',
            headers: {},
            mode: 'cors',
            cache: 'default',
            referrerPolicy: 'no-referrer-when-downgrade'
        };
        if (this.info.headers) {
            common_util_object__WEBPACK_IMPORTED_MODULE_1__.each(this.info.headers, (value, key) => {
                params.headers[key] = value;
            });
        }
        if (!this.options.isLive && !this.options.disableSegment) {
            params.headers['range'] = `bytes=${this.startBytes}-${this.endBytes > 0 ? this.endBytes : ''}`;
        }
        if (this.info.withCredentials) {
            params.credentials = 'include';
        }
        if (this.info.referrerPolicy) {
            params.referrerPolicy = this.info.referrerPolicy;
        }
        if (this.abortController) {
            this.abortController.abort();
        }
        if (typeof AbortController === 'function') {
            this.abortController = new AbortController();
            params.signal = this.abortController.signal;
        }
        try {
            const res = await fetch(this.info.url, params);
            if (res.ok && (res.status >= 200 && res.status <= 299)) {
                this.reader = res.body.getReader();
            }
            else {
                this.status = 3 /* IOLoaderStatus.ERROR */;
                common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal(`FetchStreamLoader: Http code invalid, ${res.status} ${res.statusText}`, cheap__fileName__0, 189);
            }
        }
        catch (error) {
            if (this.retryCount < this.options.retryCount && (!this.options.isLive || !this.receivedLength)) {
                this.retryCount++;
                this.status = 1 /* IOLoaderStatus.CONNECTING */;
                await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_3__["default"](this.options.retryInterval);
                return this.openReader();
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal(`FetchStreamLoader: exception ${error.message}`, cheap__fileName__0, 202);
            }
        }
    }
    async readInterval(buffer, preLen = 0) {
        let pos = 0;
        while (this.buffers.length && pos < buffer.length) {
            const cache = this.buffers.shift();
            if (cache.length > buffer.length - pos) {
                buffer.set(cache.subarray(0, buffer.length - pos), pos);
                this.buffers.unshift(cache.subarray(buffer.length - pos));
                pos = buffer.length;
            }
            else {
                buffer.set(cache, pos);
                pos += cache.length;
            }
        }
        if (pos >= buffer.length) {
            return buffer.length + preLen;
        }
        if (this.status === 4 /* IOLoaderStatus.COMPLETE */) {
            return pos > 0 ? (pos + preLen) : (preLen > 0 ? preLen : -1048576 /* IOError.END */);
        }
        if (!this.reader) {
            await this.openReader();
        }
        const { value, done } = await this.reader.read();
        if (done) {
            if (this.contentLength !== null && (this.receivedLength + this.range.from) < this.endBytes + 1) {
                this.status = 3 /* IOLoaderStatus.ERROR */;
                common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal('Fetch stream meet Early-EOF', cheap__fileName__0, 241);
            }
            else if (this.options.isLive || this.options.disableSegment || (this.receivedLength + this.range.from) >= this.eofIndex) {
                this.status = 4 /* IOLoaderStatus.COMPLETE */;
                this.startBytes = 0;
                return pos > 0 ? (pos + preLen) : (preLen > 0 ? preLen : -1048576 /* IOError.END */);
            }
            else {
                await this.reader.cancel();
                if (this.abortController) {
                    this.abortController.abort();
                }
                this.reader = null;
                this.startBytes = this.endBytes + 1;
                this.endBytes = Math.min(this.startBytes + this.options.preload - 1, this.eofIndex);
                return this.readInterval(buffer.subarray(pos), pos);
            }
        }
        else {
            this.receivedLength += value.length;
            if (value.length > buffer.length - pos) {
                buffer.set(value.subarray(0, buffer.length - pos), pos);
                this.buffers.push(value.subarray(buffer.length - pos));
                return buffer.length + preLen;
            }
            else {
                buffer.set(value, pos);
                pos += value.length;
                return pos + preLen;
            }
        }
    }
    async read(buffer) {
        return this.readInterval(buffer);
    }
    async seek(pos) {
        await this.abort();
        this.receivedLength = Number(pos) - this.range.from;
        this.startBytes = Number(pos);
        if (!this.options.disableSegment) {
            this.endBytes = Math.min(this.startBytes + this.options.preload, this.eofIndex);
        }
        this.buffers.length = 0;
        if (this.status === 4 /* IOLoaderStatus.COMPLETE */) {
            this.status = 2 /* IOLoaderStatus.BUFFERING */;
        }
        0;
    }
    async size() {
        if (this.options.isLive) {
            return BigInt(0);
        }
        return BigInt(Math.floor(this.contentLength));
    }
    async abort() {
        if (!this.reader) {
            return;
        }
        await this.reader.cancel();
        if (this.abortController) {
            this.abortController.abort();
        }
        this.reader = null;
    }
    async stop() {
        await this.abort();
        this.status = 0 /* IOLoaderStatus.IDLE */;
    }
}


/***/ }),

/***/ "./src/avnetwork/ioLoader/FileIOLoader.ts":
/*!************************************************!*\
  !*** ./src/avnetwork/ioLoader/FileIOLoader.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FileIOLoader)
/* harmony export */ });
/* harmony import */ var _IOLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IOLoader */ "./src/avnetwork/ioLoader/IOLoader.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/*
 * libmedia file loader
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class FileIOLoader extends _IOLoader__WEBPACK_IMPORTED_MODULE_0__["default"] {
    info;
    range;
    readPos;
    endPos;
    reader;
    readerResolve;
    async open(info, range) {
        this.info = info;
        this.range = range;
        this.readPos = 0;
        this.endPos = this.info.file.size;
        if (range.from > 0) {
            this.readPos = range.from;
        }
        if (range.to > 0) {
            this.endPos = range.to;
        }
        this.status = 2 /* IOLoaderStatus.BUFFERING */;
    }
    async readBufferByReader(len) {
        if (!this.reader) {
            this.reader = new FileReader();
            this.reader.onloadend = (event) => {
                if (this.readerResolve) {
                    this.readerResolve(event.target.result);
                }
            };
        }
        const blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;
        return new Promise((resolve) => {
            this.readerResolve = resolve;
            this.reader.readAsArrayBuffer(blobSlice.call(this.info.file, this.readPos, this.readPos + len));
        });
    }
    async read(buffer) {
        if (this.readPos >= this.endPos) {
            this.status === 4 /* IOLoaderStatus.COMPLETE */;
            return -1048576 /* IOError.END */;
        }
        const len = Math.min(buffer.length, this.endPos - this.readPos);
        if (common_util_is__WEBPACK_IMPORTED_MODULE_1__.func(Blob.prototype.arrayBuffer)) {
            buffer.set(new Uint8Array(await (this.info.file.slice(this.readPos, this.readPos + len).arrayBuffer())), 0);
        }
        else {
            buffer.set(new Uint8Array(await this.readBufferByReader(len)), 0);
        }
        this.readPos += len;
        if (this.readPos >= this.endPos) {
            this.status = 4 /* IOLoaderStatus.COMPLETE */;
        }
        return len;
    }
    async seek(pos) {
        await this.abort();
        this.readPos = Number(pos);
        if (this.status === 4 /* IOLoaderStatus.COMPLETE */) {
            this.status = 2 /* IOLoaderStatus.BUFFERING */;
        }
        return 0;
    }
    async size() {
        return BigInt(Math.floor(this.info.file.size));
    }
    async abort() {
    }
    async stop() {
        await this.abort();
        this.status = 0 /* IOLoaderStatus.IDLE */;
    }
}


/***/ }),

/***/ "./src/avnetwork/ioLoader/IOLoader.ts":
/*!********************************************!*\
  !*** ./src/avnetwork/ioLoader/IOLoader.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOLoader)
/* harmony export */ });
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/*
 * libmedia abstract loader
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

const optionsDefault = {
    isLive: true,
    preload: 5242880,
    retryCount: 20,
    retryInterval: 1
};
class IOLoader {
    options;
    status;
    retryCount;
    retryTimeout;
    constructor(options = {}) {
        this.options = options;
        this.status = 0 /* IOLoaderStatus.IDLE */;
        this.retryCount = 0;
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend({}, optionsDefault);
        common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend(this.options, options);
    }
}


/***/ }),

/***/ "./src/avpipeline/AudioDecodePipeline.ts":
/*!***********************************************!*\
  !*** ./src/avpipeline/AudioDecodePipeline.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioDecodePipeline)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../cheap/std/collection/List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../avutil/struct/rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var avcodec_wasmcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! avcodec/wasmcodec/AudioDecoder */ "./src/avcodec/wasmcodec/AudioDecoder.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/implement/AVFramePoolImpl */ "./src/avutil/implement/AVFramePoolImpl.ts");
/* harmony import */ var avcodec_webcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avcodec/webcodec/AudioDecoder */ "./src/avcodec/webcodec/AudioDecoder.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var avutil_function_audioData2AVFrame__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/function/audioData2AVFrame */ "./src/avutil/function/audioData2AVFrame.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
var cheap__fileName__0 = "src/avpipeline/AudioDecodePipeline.ts";





/*
 * libmedia AudioDecodePipeline
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */














class AudioDecodePipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
    }
    createWebcodecDecoder(task) {
        return new avcodec_webcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_1__["default"]({
            onError: (error) => {
                common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`audio decode error, taskId: ${task.taskId}, error: ${error}`, cheap__fileName__0, 82);
                if (task.openReject) {
                    task.openReject(error);
                    task.openReject = null;
                }
            },
            onReceiveFrame(audioData) {
                const avframe = (0,avutil_function_audioData2AVFrame__WEBPACK_IMPORTED_MODULE_3__.audioData2AVFrame)(audioData, task.avframePool.alloc());
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](avframe + 104, (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_5__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[17](avframe + 104), avutil_constant__WEBPACK_IMPORTED_MODULE_7__.AV_TIME_BASE_Q, task.timeBase));
                task.frameCaches.push(avframe);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](task.stats + 56, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[17](task.stats + 56) + BigInt(1));
                if (task.lastDecodeTimestamp) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 240, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_8__["default"])() - task.lastDecodeTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](task.stats + 240)));
                }
                task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_8__["default"])();
                audioData.close();
            }
        });
    }
    createTask(options) {
        const leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_9__["default"](options.leftPort);
        const rightIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_9__["default"](options.rightPort);
        const frameCaches = [];
        const avframePool = new avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_10__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_11__["default"])(options.avframeList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_12__["default"]), options.avframeListMutex);
        const task = {
            ...options,
            frameCaches,
            inputEnd: false,
            decoder: null,
            parameters: 0,
            lastDecodeTimestamp: 0,
            avframePool,
            avpacketPool: new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_13__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_11__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_12__["default"]), options.avpacketListMutex)
        };
        if (options.resource) {
            task.decoder = new avcodec_wasmcodec_AudioDecoder__WEBPACK_IMPORTED_MODULE_14__["default"]({
                resource: options.resource,
                onError: (error) => {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`audio decode error, taskId: ${options.taskId}, error: ${error}`, cheap__fileName__0, 134);
                    const task = this.tasks.get(options.taskId);
                    if (task.openReject) {
                        task.openReject(error);
                        task.openReject = null;
                    }
                },
                onReceiveFrame(frame) {
                    frameCaches.push(frame);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](task.stats + 56, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[17](task.stats + 56) + BigInt(1));
                    if (task.lastDecodeTimestamp) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 240, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_8__["default"])() - task.lastDecodeTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](task.stats + 240)));
                    }
                    task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_8__["default"])();
                },
                avframePool: avframePool
            });
        }
        else {
            task.decoder = this.createWebcodecDecoder(task);
        }
        this.tasks.set(options.taskId, task);
        rightIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_9__.REQUEST, async (request) => {
            switch (request.method) {
                case 'pull': {
                    if (frameCaches.length) {
                        const frame = frameCaches.shift();
                        rightIPCPort.reply(request, frame);
                        break;
                    }
                    else if (!task.inputEnd) {
                        while (true) {
                            if (frameCaches.length) {
                                const frame = frameCaches.shift();
                                rightIPCPort.reply(request, frame);
                                break;
                            }
                            const avpacket = await leftIPCPort.request('pull');
                            if (avpacket === -1048576 /* IOError.END */) {
                                await task.decoder.flush();
                                task.inputEnd = true;
                                if (frameCaches.length) {
                                    const frame = frameCaches.shift();
                                    rightIPCPort.reply(request, frame);
                                    break;
                                }
                                else {
                                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.info(`audio decoder ended, taskId: ${task.taskId}`, cheap__fileName__0, 188);
                                    rightIPCPort.reply(request, -1048576 /* IOError.END */);
                                    break;
                                }
                            }
                            else if (avpacket > 0) {
                                const ret = task.decoder.decode(avpacket, (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_5__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[17](avpacket + 8), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_11__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_15__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_7__.AV_TIME_BASE_Q));
                                task.avpacketPool.release(avpacket);
                                if (ret < 0) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](task.stats + 48, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_6__.CTypeEnumRead[15](task.stats + 48) + 1);
                                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`audio decode error, taskId: ${options.taskId}, ret: ${ret}`, cheap__fileName__0, 201);
                                    rightIPCPort.reply(request, ret);
                                    break;
                                }
                                continue;
                            }
                            else {
                                common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`audio decode pull avpacket error, taskId: ${options.taskId}, ret: ${avpacket}`, cheap__fileName__0, 208);
                                rightIPCPort.reply(request, avpacket);
                                break;
                            }
                        }
                        break;
                    }
                    rightIPCPort.reply(request, -1048576 /* IOError.END */);
                    break;
                }
            }
        });
        return 0;
    }
    async open(taskId, parameters) {
        const task = this.tasks.get(taskId);
        if (task) {
            return new Promise(async (resolve, reject) => {
                task.openReject = reject;
                await task.decoder.open(parameters);
                task.parameters = parameters;
                resolve();
            });
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal('task not found', cheap__fileName__0, 234);
    }
    async resetTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.decoder) {
                await task.decoder.flush();
            }
            common_util_array__WEBPACK_IMPORTED_MODULE_16__.each(task.frameCaches, (frame) => {
                task.avframePool.release(frame);
            });
            task.frameCaches.length = 0;
            task.inputEnd = false;
            task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_8__["default"])();
            common_util_logger__WEBPACK_IMPORTED_MODULE_2__.info(`reset audio decoder, taskId: ${task.taskId}`, cheap__fileName__0, 250);
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_17__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.rightPort.close();
            task.leftPort.close();
            task.decoder.close();
            task.frameCaches.forEach((frame) => {
                task.avframePool.release(frame);
            });
            this.tasks.delete(taskId);
        }
    }
}


/***/ }),

/***/ "./src/avpipeline/AudioEncodePipeline.ts":
/*!***********************************************!*\
  !*** ./src/avpipeline/AudioEncodePipeline.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioEncodePipeline)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../cheap/std/collection/List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avcodec_wasmcodec_AudioEncoder__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avcodec/wasmcodec/AudioEncoder */ "./src/avcodec/wasmcodec/AudioEncoder.ts");
/* harmony import */ var avcodec_webcodec_AudioEncoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avcodec/webcodec/AudioEncoder */ "./src/avcodec/webcodec/AudioEncoder.ts");
/* harmony import */ var avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/implement/AVFramePoolImpl */ "./src/avutil/implement/AVFramePoolImpl.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
var cheap__fileName__0 = "src/avpipeline/AudioEncodePipeline.ts";















class AudioEncodePipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
    }
    createWebcodecEncoder(task) {
        return new avcodec_webcodec_AudioEncoder__WEBPACK_IMPORTED_MODULE_1__["default"]({
            onError: (error) => {
                common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`audio encode error, taskId: ${task.taskId}, error: ${error}`, cheap__fileName__0, 75);
                if (task.openReject) {
                    task.openReject(error);
                    task.openReject = null;
                }
            },
            onReceivePacket(avpacket, avframe) {
                task.avpacketCaches.push(avpacket);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 64, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](task.stats + 64) + BigInt(1));
                if (avframe) {
                    task.avframePool.release(avframe);
                }
            },
            avpacketPool: task.avpacketPool,
            avframePool: task.avframePool
        });
    }
    createTask(options) {
        const leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_5__["default"](options.leftPort);
        const rightIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_5__["default"](options.rightPort);
        const avpacketCaches = [];
        const avpacketPool = new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_6__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_7__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_8__["default"]), options.avpacketListMutex);
        const task = {
            ...options,
            avpacketCaches,
            encoder: null,
            inputEnd: false,
            parameters: 0,
            avframePool: new avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_9__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_7__["default"])(options.avframeList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_8__["default"]), options.avframeListMutex),
            avpacketPool
        };
        if (options.resource) {
            task.encoder = new avcodec_wasmcodec_AudioEncoder__WEBPACK_IMPORTED_MODULE_10__["default"]({
                resource: options.resource,
                onError: (error) => {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`audio encode error, taskId: ${options.taskId}, error: ${error}`, cheap__fileName__0, 119);
                    const task = this.tasks.get(options.taskId);
                    if (task.openReject) {
                        task.openReject(error);
                        task.openReject = null;
                    }
                },
                onReceiveAVPacket(avpacket) {
                    task.avpacketCaches.push(avpacket);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 64, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](task.stats + 64) + BigInt(1));
                },
                avpacketPool: avpacketPool
            });
        }
        else {
            task.encoder = this.createWebcodecEncoder(task);
        }
        this.tasks.set(options.taskId, task);
        rightIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_5__.REQUEST, async (request) => {
            switch (request.method) {
                case 'pull': {
                    if (avpacketCaches.length) {
                        const avpacket = avpacketCaches.shift();
                        rightIPCPort.reply(request, avpacket);
                        break;
                    }
                    else if (!task.inputEnd) {
                        while (true) {
                            if (avpacketCaches.length) {
                                const avpacket = avpacketCaches.shift();
                                rightIPCPort.reply(request, avpacket);
                                break;
                            }
                            const avframe = await leftIPCPort.request('pull');
                            if (!common_util_is__WEBPACK_IMPORTED_MODULE_11__.number(avframe) || avframe > 0) {
                                const ret = task.encoder.encode(avframe);
                                if (common_util_is__WEBPACK_IMPORTED_MODULE_11__.number(avframe)) {
                                    task.avframePool.release(avframe);
                                }
                                else {
                                    avframe.close();
                                }
                                if (ret < 0) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 52, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.stats + 52) + 1);
                                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`audio encode error, taskId: ${options.taskId}, ret: ${ret}`, cheap__fileName__0, 167);
                                    rightIPCPort.reply(request, ret);
                                    break;
                                }
                                // 硬解队列中的 EncodedVideoChunk 过多会报错， 这里判断做一下延时
                                while (task.encoder instanceof avcodec_webcodec_AudioEncoder__WEBPACK_IMPORTED_MODULE_1__["default"]
                                    && task.encoder.getQueueLength() > 4) {
                                    await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_12__["default"](0);
                                }
                                continue;
                            }
                            else {
                                if (avframe === -1048576 /* IOError.END */) {
                                    await task.encoder.flush();
                                    task.inputEnd = true;
                                    if (avpacketCaches.length) {
                                        const avpacket = avpacketCaches.shift();
                                        rightIPCPort.reply(request, avpacket);
                                        break;
                                    }
                                    else {
                                        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.info(`audio encoder ended, taskId: ${task.taskId}`, cheap__fileName__0, 189);
                                        rightIPCPort.reply(request, -1048576 /* IOError.END */);
                                        break;
                                    }
                                }
                                else {
                                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`audio encoder pull avpacket error, taskId: ${options.taskId}, ret: ${avframe}`, cheap__fileName__0, 195);
                                    rightIPCPort.reply(request, avframe);
                                    break;
                                }
                            }
                        }
                        break;
                    }
                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.info(`audio encoder ended, taskId: ${task.taskId}`, cheap__fileName__0, 203);
                    rightIPCPort.reply(request, -1048576 /* IOError.END */);
                    break;
                }
            }
        });
        return 0;
    }
    async open(taskId, parameters, timeBase) {
        const task = this.tasks.get(taskId);
        if (task) {
            return new Promise(async (resolve, reject) => {
                task.openReject = reject;
                await task.encoder.open(parameters, timeBase);
                task.parameters = parameters;
                resolve();
            });
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal('task not found', cheap__fileName__0, 223);
    }
    async getExtraData(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            return task.encoder.getExtraData();
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal('task not found', cheap__fileName__0, 231);
    }
    async resetTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.encoder) {
                await task.encoder.flush();
            }
            common_util_array__WEBPACK_IMPORTED_MODULE_13__.each(task.avpacketCaches, (avpacket) => {
                task.avpacketPool.release(avpacket);
            });
            task.avpacketCaches.length = 0;
            task.inputEnd = false;
            common_util_logger__WEBPACK_IMPORTED_MODULE_2__.info(`reset audio encoder, taskId: ${task.taskId}`, cheap__fileName__0, 246);
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_14__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.rightPort.close();
            task.leftPort.close();
            task.encoder.close();
            task.avpacketCaches.forEach((avpacket) => {
                task.avpacketPool.release(avpacket);
            });
            this.tasks.delete(taskId);
        }
    }
}


/***/ }),

/***/ "./src/avpipeline/DemuxPipeline.ts":
/*!*****************************************!*\
  !*** ./src/avpipeline/DemuxPipeline.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DemuxPipeline)
/* harmony export */ });
/* unused harmony export STREAM_INDEX_ALL */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../cheap/std/collection/List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../avutil/struct/rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var avformat_AVFormatContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avformat/AVFormatContext */ "./src/avformat/AVFormatContext.ts");
/* harmony import */ var common_io_IOReader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/io/IOReader */ "./src/common/io/IOReader.ts");
/* harmony import */ var avformat_demux__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avformat/demux */ "./src/avformat/demux.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var cheap_std_buffer_SafeUint8Array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/buffer/SafeUint8Array */ "./src/cheap/std/buffer/SafeUint8Array.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! common/timer/LoopTask */ "./src/common/timer/LoopTask.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_util_bigint__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! common/util/bigint */ "./src/common/util/bigint.ts");
var cheap__fileName__2 = "src/avpipeline/DemuxPipeline.ts";






















const STREAM_INDEX_ALL = -1;
class DemuxPipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
    }
    async judgeFormat(ioReader, defaultFormat = -1 /* AVFormat.UNKNOWN */) {
        let signature = await ioReader.peekString(8);
        if (/^FLV/.test(signature)) {
            return 0 /* AVFormat.FLV */;
        }
        else if (/^DKIF/.test(signature)) {
            return 4 /* AVFormat.IVF */;
        }
        else if (/^ftyp/.test(signature.slice(4, 8))) {
            return 1 /* AVFormat.MP4 */;
        }
        else if (/^OggS/.test(signature)) {
            return 3 /* AVFormat.OGGS */;
        }
        else if (/^ID3/.test(signature)) {
            return 7 /* AVFormat.MP3 */;
        }
        else if (/^fLaC/.test(signature)) {
            return 10 /* AVFormat.FLAC */;
        }
        else if (/^RIFF/.test(signature)) {
            const dataType = (await ioReader.peekString(12)).slice(8);
            if (/^WAVE/.test(dataType)) {
                return 9 /* AVFormat.WAV */;
            }
        }
        else if ((await ioReader.peekUint32()) === 0x1A45DFA3) {
            return 5 /* AVFormat.MATROSKA */;
        }
        return defaultFormat;
    }
    createTask(options) {
        let leftIPCPort;
        let controlIPCPort;
        if (options.mainTaskId) {
            const mainTask = this.tasks.get(options.mainTaskId);
            leftIPCPort = mainTask.leftIPCPort;
            controlIPCPort = mainTask.controlIPCPort;
        }
        else {
            leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](options.leftPort);
            if (options.controlPort) {
                controlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](options.controlPort);
            }
        }
        const bufferLength = options.bufferLength || 1048576;
        const buf = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_2__.avMalloc)(bufferLength);
        if (!buf) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_3__.NO_MEMORY;
        }
        const buffer = new cheap_std_buffer_SafeUint8Array__WEBPACK_IMPORTED_MODULE_4__["default"](buf, bufferLength);
        const ioReader = new common_io_IOReader__WEBPACK_IMPORTED_MODULE_5__["default"](bufferLength, true, buffer);
        if (!options.isLive) {
            ioReader.flags |= 1 /* IOFlags.SEEKABLE */;
        }
        if (options.flags) {
            ioReader.flags |= options.flags;
        }
        ioReader.onFlush = async (buffer) => {
            const params = {
                pointer: buffer.byteOffset,
                length: buffer.length
            };
            if (options.ioloaderOptions) {
                params.ioloaderOptions = options.ioloaderOptions;
            }
            try {
                const len = await leftIPCPort.request('read', params);
                return len;
            }
            catch (error) {
                return -1048574 /* IOError.INVALID_OPERATION */;
            }
        };
        ioReader.onSeek = async (pos) => {
            try {
                const params = {
                    pos
                };
                if (options.ioloaderOptions) {
                    params.ioloaderOptions = options.ioloaderOptions;
                }
                await leftIPCPort.request('seek', params);
                return 0;
            }
            catch (error) {
                return -1048574 /* IOError.INVALID_OPERATION */;
            }
        };
        ioReader.onSize = async () => {
            try {
                return await leftIPCPort.request('size');
            }
            catch (error) {
                return BigInt(-1048574 /* IOError.INVALID_OPERATION */);
            }
        };
        const formatContext = (0,avformat_AVFormatContext__WEBPACK_IMPORTED_MODULE_6__.createAVIFormatContext)();
        formatContext.ioReader = ioReader;
        formatContext.getDecoderResource = async (mediaType, codecId) => {
            if (!controlIPCPort) {
                return;
            }
            return controlIPCPort.request('getDecoderResource', {
                codecId,
                mediaType
            });
        };
        this.tasks.set(options.taskId, {
            ...options,
            leftIPCPort,
            rightIPCPorts: new Map(),
            controlIPCPort,
            formatContext,
            ioReader,
            buffer: buf,
            cacheAVPackets: new Map(),
            cacheRequests: new Map(),
            realFormat: -1 /* AVFormat.UNKNOWN */,
            demuxEnded: false,
            loop: null,
            gopCounter: 0,
            lastKeyFramePts: BigInt(0),
            lastAudioDts: BigInt(0),
            lastVideoDts: BigInt(0),
            avpacketPool: new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_7__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_9__["default"]), options.avpacketListMutex)
        });
        return 0;
    }
    async openStream(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            await task.leftIPCPort.request('open');
            let format;
            try {
                format = await this.judgeFormat(task.ioReader, task.format);
                task.format = format;
            }
            catch (error) {
                return avutil_error__WEBPACK_IMPORTED_MODULE_3__.DATA_INVALID;
            }
            let iformat;
            switch (format) {
                case 0 /* AVFormat.FLV */:
                    {
                        iformat = new ((await Promise.all(/*! import() */[__webpack_require__.e("src_avformat_formats_flv_FlvHeader_ts-src_avformat_formats_flv_FlvScriptTag_ts"), __webpack_require__.e("src_avformat_formats_IFlvFormat_ts")]).then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IFlvFormat */ "./src/avformat/formats/IFlvFormat.ts"))).default);
                    }
                    break;
                case 1 /* AVFormat.MP4 */:
                    {
                        iformat = new ((await Promise.all(/*! import() */[__webpack_require__.e("src_avformat_formats_mov_boxType_ts-src_avformat_formats_mov_function_createFragmentTrack_ts--45bef4"), __webpack_require__.e("src_avformat_formats_IMovFormat_ts")]).then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IMovFormat */ "./src/avformat/formats/IMovFormat.ts"))).default);
                    }
                    break;
                case 2 /* AVFormat.MPEGTS */:
                    {
                        iformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IMpegtsFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IMpegtsFormat */ "./src/avformat/formats/IMpegtsFormat.ts"))).default);
                    }
                    break;
                case 4 /* AVFormat.IVF */:
                    {
                        iformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IIvfFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IIvfFormat */ "./src/avformat/formats/IIvfFormat.ts"))).default);
                    }
                    break;
                case 3 /* AVFormat.OGGS */:
                    {
                        iformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IOggsFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IOggsFormat */ "./src/avformat/formats/IOggsFormat.ts"))).default);
                    }
                    break;
                case 7 /* AVFormat.MP3 */:
                    {
                        iformat = new ((await Promise.all(/*! import() */[__webpack_require__.e("src_avformat_formats_mp3_frameHeader_ts-src_avformat_formats_mp3_id3v2_ts-src_avformat_format-cfe6eb"), __webpack_require__.e("src_avformat_formats_IMp3Format_ts")]).then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IMp3Format */ "./src/avformat/formats/IMp3Format.ts"))).default);
                    }
                    break;
                case 5 /* AVFormat.MATROSKA */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IMatroskaFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IMatroskaFormat */ "./src/avformat/formats/IMatroskaFormat.ts"))).default));
                    }
                    break;
                case 8 /* AVFormat.AAC */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IAacFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IAacFormat */ "./src/avformat/formats/IAacFormat.ts"))).default));
                    }
                    break;
                case 10 /* AVFormat.FLAC */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IFlacFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IFlacFormat */ "./src/avformat/formats/IFlacFormat.ts"))).default));
                    }
                    break;
                case 9 /* AVFormat.WAV */:
                    {
                        iformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_IWavFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/IWavFormat */ "./src/avformat/formats/IWavFormat.ts"))).default));
                    }
                    break;
                default:
                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error('format not support', cheap__fileName__2, 371);
                    return avutil_error__WEBPACK_IMPORTED_MODULE_3__.FORMAT_NOT_SUPPORT;
            }
            task.realFormat = format;
            task.formatContext.iformat = iformat;
            return avformat_demux__WEBPACK_IMPORTED_MODULE_11__.open(task.formatContext, {
                maxAnalyzeDuration: 2000,
                fastOpen: task.isLive
            });
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.fatal('task not found', cheap__fileName__2, 386);
        }
    }
    async getFormat(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            return task.realFormat;
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.fatal('task not found', cheap__fileName__2, 396);
        }
    }
    async analyzeStreams(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.analyzeStreams(task.formatContext);
            const streams = [];
            for (let i = 0; i < task.formatContext.streams.length; i++) {
                const stream = task.formatContext.streams[i];
                streams.push({
                    index: stream.index,
                    id: stream.id,
                    codecpar: stream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_12__.symbolStructAddress],
                    nbFrames: stream.nbFrames,
                    metadata: stream.metadata,
                    duration: stream.duration,
                    startTime: stream.startTime,
                    disposition: stream.disposition,
                    timeBase: stream.timeBase[cheap_symbol__WEBPACK_IMPORTED_MODULE_12__.symbolStructAddress]
                });
            }
            return {
                metadata: task.formatContext.metadata,
                format: task.realFormat,
                streams
            };
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.fatal('task not found', cheap__fileName__2, 428);
        }
    }
    async connectStreamTask(taskId, streamIndex, port) {
        const task = this.tasks.get(taskId);
        if (task) {
            const ipcPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](port);
            task.cacheAVPackets.set(streamIndex, []);
            ipcPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__.REQUEST, async (request) => {
                switch (request.method) {
                    case 'pull': {
                        const cacheAVPackets = task.cacheAVPackets.get(streamIndex);
                        if (cacheAVPackets.length) {
                            const avpacket = cacheAVPackets.shift();
                            if (task.formatContext.streams[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 32)].codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](task.stats + 32) - 1);
                            }
                            else if (task.formatContext.streams[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 32)].codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 120, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](task.stats + 120) - 1);
                            }
                            ipcPort.reply(request, avpacket);
                        }
                        else {
                            if (task.demuxEnded) {
                                ipcPort.reply(request, -1048576 /* IOError.END */);
                            }
                            else {
                                task.cacheRequests.set(streamIndex, request);
                                if (task.loop && task.loop.isStarted()) {
                                    task.loop.resetInterval();
                                }
                            }
                        }
                        break;
                    }
                }
            });
            task.rightIPCPorts.set(streamIndex, ipcPort);
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`connect stream ${streamIndex}, taskId: ${task.taskId}`, cheap__fileName__2, 470);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.fatal('task not found', cheap__fileName__2, 473);
        }
    }
    async startDemux(taskId, isLive, minQueueLength) {
        const task = this.tasks.get(taskId);
        if (task) {
            // mpegts 最小 20
            minQueueLength = Math.max(minQueueLength, task.format === 2 /* AVFormat.MPEGTS */ ? 20 : 10);
            if (task.loop) {
                task.loop.destroy();
            }
            task.loop = new common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_15__["default"](async () => {
                if (!isLive) {
                    let canDo = false;
                    task.cacheAVPackets.forEach((list) => {
                        if (list.length < minQueueLength) {
                            canDo = true;
                        }
                    });
                    if (!canDo) {
                        task.loop.emptyTask();
                        return;
                    }
                }
                const avpacket = task.avpacketPool.alloc();
                let ret = await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.readAVPacket(task.formatContext, avpacket);
                if (!ret) {
                    const streamIndex = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 32);
                    if (task.formatContext.streams[streamIndex].codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */
                        && task.cacheAVPackets.has(streamIndex)) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[17](task.stats + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](task.stats + 24) + BigInt(1));
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[17](task.stats + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](task.stats + 16) + BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 28) >>> 0));
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](task.stats + 24) > 1 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 16) > task.lastAudioDts) {
                            const list = task.cacheAVPackets.get(streamIndex);
                            if (list && list.length) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 236, Math.round(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 76) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 72)
                                    / ((Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 16) - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](list[0] + 16) & 0xffffffffn) >> 0) / list.length)));
                            }
                            else {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 236, Math.round(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 76) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 72)
                                    / (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 16) - task.lastAudioDts & 0xffffffffn) >> 0)));
                            }
                        }
                        task.lastAudioDts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 16);
                    }
                    else if (task.formatContext.streams[streamIndex].codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */
                        && task.cacheAVPackets.has(streamIndex)) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[17](task.stats + 112, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](task.stats + 112) + BigInt(1));
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[17](task.stats + 104, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](task.stats + 104) + BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 28) >>> 0));
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[17](task.stats + 176, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](task.stats + 176) + BigInt(1));
                            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](task.stats + 176) > 1 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 8) > task.lastKeyFramePts) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 96, task.gopCounter);
                                task.gopCounter = 1;
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 92, (Number((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_16__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 8) - task.lastKeyFramePts, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_18__.AV_MILLI_TIME_BASE_Q) & 0xffffffffn) >> 0));
                            }
                            task.lastKeyFramePts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 8);
                        }
                        else {
                            task.gopCounter++;
                        }
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](task.stats + 112) > 1 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 16) > task.lastVideoDts) {
                            const list = task.cacheAVPackets.get(streamIndex);
                            if (list && list.length) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 224, Math.round(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 76) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 72)
                                    / ((Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 16) - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](list[0] + 16) & 0xffffffffn) >> 0) / list.length)));
                            }
                            else {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 224, Math.round(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 76) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 72)
                                    / (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 16) - task.lastVideoDts & 0xffffffffn) >> 0)));
                            }
                        }
                        task.lastVideoDts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 16);
                    }
                    if (task.cacheRequests.has(streamIndex)) {
                        task.rightIPCPorts.get(streamIndex).reply(task.cacheRequests.get(streamIndex), avpacket);
                        task.cacheRequests.delete(streamIndex);
                    }
                    else {
                        if (task.cacheAVPackets.has(streamIndex)) {
                            task.cacheAVPackets.get(streamIndex).push(avpacket);
                            if (task.formatContext.streams[streamIndex].codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](task.stats + 32) + 1);
                            }
                            else if (task.formatContext.streams[streamIndex].codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 120, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](task.stats + 120) + 1);
                            }
                        }
                        else {
                            if (task.rightIPCPorts.has(STREAM_INDEX_ALL)) {
                                if (task.cacheRequests.has(STREAM_INDEX_ALL)) {
                                    task.rightIPCPorts.get(STREAM_INDEX_ALL).reply(task.cacheRequests.get(STREAM_INDEX_ALL), avpacket);
                                    task.cacheRequests.delete(STREAM_INDEX_ALL);
                                }
                                else {
                                    task.cacheAVPackets.get(STREAM_INDEX_ALL).push(avpacket);
                                }
                            }
                            else {
                                task.avpacketPool.release(avpacket);
                            }
                        }
                    }
                }
                else {
                    task.avpacketPool.release(avpacket);
                    if (ret !== -1048576 /* IOError.END */) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.error(`demux error, ret: ${ret}, taskId: ${taskId}`, cheap__fileName__2, 604);
                    }
                    task.demuxEnded = true;
                    common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info(`demuxer ended, taskId: ${task.taskId}`, cheap__fileName__2, 609);
                    for (let streamIndex of task.cacheRequests.keys()) {
                        const cacheAVPackets = task.cacheAVPackets.get(streamIndex);
                        if (!cacheAVPackets.length) {
                            task.rightIPCPorts.get(streamIndex).reply(task.cacheRequests.get(streamIndex), -1048576 /* IOError.END */);
                            task.cacheRequests.delete(streamIndex);
                        }
                    }
                    task.loop.stop();
                }
            }, 0, 0, true, false);
            task.loop.start();
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.debug(`start demux loop, taskId: ${task.taskId}`, cheap__fileName__2, 624);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_10__.fatal('task not found', cheap__fileName__2, 627);
        }
    }
    async seek(taskId, timestamp, flags) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.loop) {
                await task.loop.stopBeforeNextTick();
                let ret = await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.seek(task.formatContext, -1, timestamp, flags);
                if (ret >= BigInt(0)) {
                    task.cacheAVPackets.forEach((list) => {
                        common_util_array__WEBPACK_IMPORTED_MODULE_19__.each(list, (avpacket) => {
                            task.avpacketPool.release(avpacket);
                        });
                        list.length = 0;
                    });
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 32, 0);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 120, 0);
                    const avpacket = task.avpacketPool.alloc();
                    while (true) {
                        ret = await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.readAVPacket(task.formatContext, avpacket);
                        if (ret < 0 || task.cacheAVPackets.has(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 32))) {
                            break;
                        }
                    }
                    if (ret >= 0) {
                        task.demuxEnded = false;
                        const streamIndex = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 32);
                        task.cacheAVPackets.get(streamIndex).push(avpacket);
                        if (task.formatContext.streams[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 32)].codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](task.stats + 32) + 1);
                        }
                        else if (task.formatContext.streams[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](avpacket + 32)].codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 120, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](task.stats + 120) + 1);
                        }
                        task.loop.start();
                        let duration = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](avpacket + 8);
                        if (task.formatContext.streams[streamIndex].startTime !== avutil_constant__WEBPACK_IMPORTED_MODULE_18__.NOPTS_VALUE_BIGINT) {
                            duration -= task.formatContext.streams[streamIndex].startTime;
                        }
                        else {
                            duration -= task.formatContext.streams[streamIndex].firstDTS;
                        }
                        return (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_16__.avRescaleQ)(common_util_bigint__WEBPACK_IMPORTED_MODULE_20__.max(duration, BigInt(0)), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_18__.AV_MILLI_TIME_BASE_Q);
                    }
                    else {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_10__.warn(`got first packet failed after seek, taskId: ${task.taskId}`, cheap__fileName__2, 680);
                        task.avpacketPool.release(avpacket);
                        task.demuxEnded = true;
                        return timestamp;
                    }
                }
                return ret;
            }
            else {
                common_util_logger__WEBPACK_IMPORTED_MODULE_10__.info('seek before demux loop start', cheap__fileName__2, 691);
                let ret = await avformat_demux__WEBPACK_IMPORTED_MODULE_11__.seek(task.formatContext, -1, timestamp, flags);
                if (ret < 0) {
                    return ret;
                }
                return timestamp;
            }
        }
    }
    /**
     * 裁剪 avpacket 队列大小
     *
     * @param taskId
     * @param max （毫秒）
     */
    async croppingAVPacketQueue(taskId, max) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.cacheAVPackets.forEach((list, streamIndex) => {
                const lastDts = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](list[list.length - 1] + 16);
                let i = list.length - 2;
                for (i = list.length - 2; i >= 0; i--) {
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[15](list[i] + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                        if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_16__.avRescaleQ)(lastDts - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_13__.CTypeEnumRead[17](list[i] + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(list[i] + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_18__.AV_MILLI_TIME_BASE_Q) >= max) {
                            break;
                        }
                    }
                }
                if (i > 0) {
                    list.splice(0, i).forEach((avpacket) => {
                        task.avpacketPool.release(avpacket);
                    });
                    if (task.formatContext.streams[streamIndex].codecpar.codecType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 32, list.length);
                    }
                    else if (task.formatContext.streams[streamIndex].codecpar.codecType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumWrite[15](task.stats + 120, list.length);
                    }
                }
            });
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_3__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.loop) {
                await task.loop.stopBeforeNextTick();
                task.loop.destroy();
            }
            task.leftIPCPort.destroy();
            task.rightIPCPorts.forEach((ipcPort) => {
                ipcPort.destroy();
            });
            task.rightIPCPorts.clear();
            task.formatContext.destroy();
            (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_2__.avFree)(task.buffer);
            task.cacheAVPackets.forEach((list) => {
                list.forEach((avpacket) => {
                    task.avpacketPool.release(avpacket);
                });
            });
            this.tasks.delete(taskId);
        }
    }
}


/***/ }),

/***/ "./src/avpipeline/IOPipeline.ts":
/*!**************************************!*\
  !*** ./src/avpipeline/IOPipeline.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOPipeline)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avnetwork_ioLoader_FetchIOLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avnetwork/ioLoader/FetchIOLoader */ "./src/avnetwork/ioLoader/FetchIOLoader.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avnetwork_ioLoader_FileIOLoader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avnetwork/ioLoader/FileIOLoader */ "./src/avnetwork/ioLoader/FileIOLoader.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avpipeline/IOPipeline.ts";










class IOPipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
    }
    async createTask(options) {
        let ioLoader;
        switch (options.type) {
            case 0 /* IOType.Fetch */:
                ioLoader = new avnetwork_ioLoader_FetchIOLoader__WEBPACK_IMPORTED_MODULE_1__["default"](options.options);
                break;
            case 1 /* IOType.File */:
                ioLoader = new avnetwork_ioLoader_FileIOLoader__WEBPACK_IMPORTED_MODULE_2__["default"](options.options);
                break;
            case 2 /* IOType.HLS */:
                {
                    ioLoader = new (await __webpack_require__.e(/*! import() */ "src_avnetwork_ioLoader_HlsIOLoader_ts").then(__webpack_require__.bind(__webpack_require__, /*! avnetwork/ioLoader/HlsIOLoader */ "./src/avnetwork/ioLoader/HlsIOLoader.ts"))).default(options.options);
                }
                break;
            case 3 /* IOType.DASH */:
                {
                    ioLoader = new (await __webpack_require__.e(/*! import() */ "src_avnetwork_ioLoader_DashIOLoader_ts").then(__webpack_require__.bind(__webpack_require__, /*! avnetwork/ioLoader/DashIOLoader */ "./src/avnetwork/ioLoader/DashIOLoader.ts"))).default(options.options);
                }
                break;
        }
        if (!ioLoader) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_3__.INVALID_ARGUMENT;
        }
        const ipcPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__["default"](options.rightPort);
        const task = {
            ...options,
            ioLoader,
            ipcPort
        };
        ipcPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__.REQUEST, async (request) => {
            switch (request.method) {
                case 'open': {
                    try {
                        await ioLoader.open(options.info, options.range);
                        ipcPort.reply(request, {});
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.error(`loader open error, ${error}, taskId: ${options.taskId}`, cheap__fileName__0, 118);
                        ipcPort.reply(request, null, error);
                    }
                    break;
                }
                case 'read': {
                    const pointer = request.params.pointer;
                    const length = request.params.length;
                    const ioloaderOptions = request.params.ioloaderOptions;
                    const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_6__.mapSafeUint8Array)(pointer, length);
                    try {
                        const len = await ioLoader.read(buffer, ioloaderOptions);
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[17](task.stats + 192, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_8__.CTypeEnumRead[17](task.stats + 192) + BigInt(len >>> 0));
                        ipcPort.reply(request, len);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.error(`loader read error, ${error}, taskId: ${options.taskId}`, cheap__fileName__0, 139);
                        ipcPort.reply(request, avutil_error__WEBPACK_IMPORTED_MODULE_3__.DATA_INVALID);
                    }
                    break;
                }
                case 'seek': {
                    const pos = request.params.pos;
                    const ioloaderOptions = request.params.ioloaderOptions;
                    try {
                        await ioLoader.seek(pos, ioloaderOptions);
                        ipcPort.reply(request);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.error(`loader seek error, ${error}, taskId: ${options.taskId}`, cheap__fileName__0, 157);
                        ipcPort.reply(request, null, error);
                    }
                    break;
                }
                case 'size': {
                    ipcPort.reply(request, await ioLoader.size());
                    break;
                }
            }
        });
        this.tasks.set(options.taskId, task);
        return 0;
    }
    async open(id) {
        const task = this.tasks.get(id);
        if (task) {
            await task.ioLoader.open(task.info, task.range);
            return 0;
        }
    }
    async getDuration(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 2 /* IOType.HLS */ || task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getDuration();
                }
            }
            return 0;
        }
    }
    async hasAudio(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.hasAudio();
                }
            }
            return false;
        }
    }
    async hasVideo(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.hasVideo();
                }
            }
            return false;
        }
    }
    async hasSubtitle(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.hasSubtitle();
                }
            }
            return false;
        }
    }
    async getVideoList(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getVideoList();
                }
                else if (task.type === 2 /* IOType.HLS */) {
                    return task.ioLoader.getVideoList();
                }
            }
            return {
                list: [],
                selectedIndex: 0
            };
        }
    }
    async getAudioList(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getAudioList();
                }
            }
            return {
                list: [],
                selectedIndex: 0
            };
        }
    }
    async getSubtitleList(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getSubtitleList();
                }
            }
            return {
                list: [],
                selectedIndex: 0
            };
        }
    }
    async selectVideo(taskId, index) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    task.ioLoader.selectVideo(index);
                }
                else if (task.type === 2 /* IOType.HLS */) {
                    return task.ioLoader.selectVideo(index);
                }
            }
        }
    }
    async selectAudio(taskId, index) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    task.ioLoader.selectAudio(index);
                }
            }
        }
    }
    async selectSubtitle(taskId, index) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    task.ioLoader.selectSubtitle(index);
                }
            }
        }
    }
    async getMinBuffer(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            {
                if (task.type === 3 /* IOType.DASH */) {
                    return task.ioLoader.getMinBuffer();
                }
            }
            {
                if (task.type === 2 /* IOType.HLS */) {
                    return task.ioLoader.getMinBuffer();
                }
            }
            return 0;
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_3__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(id) {
        const task = this.tasks.get(id);
        if (task) {
            await task.ioLoader.stop();
            task.ipcPort.destroy();
            this.tasks.delete(id);
        }
    }
}


/***/ }),

/***/ "./src/avpipeline/MuxPipeline.ts":
/*!***************************************!*\
  !*** ./src/avpipeline/MuxPipeline.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MuxPipeline)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../cheap/std/collection/List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../avutil/struct/rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var avformat_AVFormatContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avformat/AVFormatContext */ "./src/avformat/AVFormatContext.ts");
/* harmony import */ var avformat_mux__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! avformat/mux */ "./src/avformat/mux.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! common/timer/LoopTask */ "./src/common/timer/LoopTask.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var common_io_IOWriterSync__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/io/IOWriterSync */ "./src/common/io/IOWriterSync.ts");
/* harmony import */ var avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! avutil/util/codecparameters */ "./src/avutil/util/codecparameters.ts");
var cheap__fileName__2 = "src/avpipeline/MuxPipeline.ts";






/*
 * libmedia MuxPipeline
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */













class MuxPipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
    }
    createTask(options) {
        const rightIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](options.rightPort);
        const formatContext = (0,avformat_AVFormatContext__WEBPACK_IMPORTED_MODULE_2__.createAVOFormatContext)();
        const ioWriter = new common_io_IOWriterSync__WEBPACK_IMPORTED_MODULE_3__["default"](5242880);
        ioWriter.onFlush = (data, pos) => {
            const buffer = data.slice();
            rightIPCPort.notify('write', {
                data: buffer,
                pos
            }, [buffer.buffer]);
            return 0;
        };
        ioWriter.onSeek = (pos) => {
            rightIPCPort.notify('seek', {
                pos
            });
            return 0;
        };
        formatContext.ioWriter = ioWriter;
        this.tasks.set(options.taskId, {
            ...options,
            rightIPCPort,
            formatContext,
            loop: null,
            ended: false,
            streams: [],
            avpacketPool: new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_4__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_5__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_6__["default"]), options.avpacketListMutex)
        });
        return 0;
    }
    async open(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            let oformat;
            switch (task.format) {
                case 0 /* AVFormat.FLV */:
                    {
                        oformat = new ((await Promise.all(/*! import() */[__webpack_require__.e("src_avformat_formats_flv_FlvHeader_ts-src_avformat_formats_flv_FlvScriptTag_ts"), __webpack_require__.e("src_avformat_formats_OFlvFormat_ts")]).then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/OFlvFormat */ "./src/avformat/formats/OFlvFormat.ts"))).default);
                    }
                    break;
                case 1 /* AVFormat.MP4 */:
                    {
                        oformat = new ((await Promise.all(/*! import() */[__webpack_require__.e("src_avformat_formats_mov_boxType_ts-src_avformat_formats_mov_function_createFragmentTrack_ts--45bef4"), __webpack_require__.e("src_avformat_formats_OMovFormat_ts")]).then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/OMovFormat */ "./src/avformat/formats/OMovFormat.ts"))).default);
                    }
                    break;
                case 2 /* AVFormat.MPEGTS */:
                    {
                        oformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_OMpegtsFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/OMpegtsFormat */ "./src/avformat/formats/OMpegtsFormat.ts"))).default);
                    }
                    break;
                case 4 /* AVFormat.IVF */:
                    {
                        oformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_OIvfFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/OIvfFormat */ "./src/avformat/formats/OIvfFormat.ts"))).default);
                    }
                    break;
                case 3 /* AVFormat.OGGS */:
                    {
                        oformat = new ((await __webpack_require__.e(/*! import() */ "src_avformat_formats_OOggsFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/OOggsFormat */ "./src/avformat/formats/OOggsFormat.ts"))).default);
                    }
                    break;
                case 7 /* AVFormat.MP3 */:
                    {
                        oformat = new ((await Promise.all(/*! import() */[__webpack_require__.e("src_avformat_formats_mp3_frameHeader_ts-src_avformat_formats_mp3_id3v2_ts-src_avformat_format-cfe6eb"), __webpack_require__.e("src_avformat_formats_OMp3Format_ts")]).then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/OMp3Format */ "./src/avformat/formats/OMp3Format.ts"))).default);
                    }
                    break;
                case 5 /* AVFormat.MATROSKA */:
                    {
                        oformat = new (((await __webpack_require__.e(/*! import() */ "src_avformat_formats_OMatroskaFormat_ts").then(__webpack_require__.bind(__webpack_require__, /*! avformat/formats/OMatroskaFormat */ "./src/avformat/formats/OMatroskaFormat.ts"))).default));
                    }
                    break;
                default:
                    common_util_logger__WEBPACK_IMPORTED_MODULE_7__.error('format not support', cheap__fileName__2, 186);
                    return avutil_error__WEBPACK_IMPORTED_MODULE_8__.FORMAT_NOT_SUPPORT;
            }
            task.formatContext.oformat = oformat;
            for (let i = 0; i < task.streams.length; i++) {
                const avpacket = await task.streams[i].pullIPC.request('pull');
                if (avpacket === -1048576 /* IOError.END */) {
                    task.streams[i].ended = true;
                }
                else if (avpacket < 0) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_7__.error(`pull stream ${i} avpacket error, ret: ${avpacket}`, cheap__fileName__2, 200);
                    task.streams[i].ended = true;
                }
                else {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_9__.CTypeEnumWrite[15](avpacket + 32, task.streams[i].stream.index);
                    task.streams[i].avpacket = avpacket;
                    const currentDts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_10__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[17](task.streams[i].avpacket + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_5__["default"])(task.streams[i].avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_12__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_13__.AV_MILLI_TIME_BASE_Q);
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](task.streams[i].stream.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_9__.CTypeEnumWrite[17](task.stats + 280, currentDts);
                    }
                    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](task.streams[i].stream.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_9__.CTypeEnumWrite[17](task.stats + 296, currentDts);
                    }
                }
            }
            return 0;
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.fatal('task not found', cheap__fileName__2, 218);
        }
    }
    async addStream(taskId, stream, port) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.streams.push({
                stream,
                pullIPC: new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](port),
                avpacket: 0,
                ended: false
            });
            const ostream = task.formatContext.createStream();
            ostream.id = stream.id;
            ostream.index = stream.index;
            (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_14__.copyCodecParameters)(ostream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_15__.symbolStructAddress], stream.codecpar);
            ostream.timeBase.num = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](stream.timeBase);
            ostream.timeBase.den = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](stream.timeBase + 4);
            ostream.metadata = stream.metadata;
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.fatal('task not found', cheap__fileName__2, 240);
        }
    }
    async updateAVCodecParameters(taskId, streamIndex, codecpar) {
        const task = this.tasks.get(taskId);
        if (task) {
            const stream = task.formatContext.getStreamByIndex(streamIndex);
            if (stream) {
                (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_14__.copyCodecParameters)(stream.codecpar[cheap_symbol__WEBPACK_IMPORTED_MODULE_15__.symbolStructAddress], codecpar);
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.fatal('task not found', cheap__fileName__2, 253);
        }
    }
    async start(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.loop) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_7__.fatal('task has started', cheap__fileName__2, 262);
            }
            avformat_mux__WEBPACK_IMPORTED_MODULE_16__.open(task.formatContext);
            avformat_mux__WEBPACK_IMPORTED_MODULE_16__.writeHeader(task.formatContext);
            if (!task.streams.length) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_7__.fatal('task streams not found', cheap__fileName__2, 269);
            }
            task.loop = new common_timer_LoopTask__WEBPACK_IMPORTED_MODULE_17__["default"](async () => {
                for (let i = 0; i < task.streams.length; i++) {
                    if (!task.streams[i].ended && !task.streams[i].avpacket) {
                        const avpacket = await task.streams[i].pullIPC.request('pull');
                        if (avpacket === -1048576 /* IOError.END */) {
                            task.streams[i].ended = true;
                        }
                        else if (avpacket < 0) {
                            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.error(`pull stream ${i} avpacket error, ret: ${avpacket}`, cheap__fileName__2, 281);
                            task.streams[i].ended = true;
                        }
                        else {
                            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_9__.CTypeEnumWrite[15](avpacket + 32, task.streams[i].stream.index);
                            task.streams[i].avpacket = avpacket;
                        }
                    }
                }
                let avpacket = 0;
                let dts = avutil_constant__WEBPACK_IMPORTED_MODULE_13__.NOPTS_VALUE_BIGINT;
                let index = 0;
                let type = -1 /* AVMediaType.AVMEDIA_TYPE_UNKNOWN */;
                for (let i = 0; i < task.streams.length; i++) {
                    if (task.streams[i].avpacket) {
                        const currentDts = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_10__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[17](task.streams[i].avpacket + 16), (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_5__["default"])(task.streams[i].avpacket + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_12__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_13__.AV_MILLI_TIME_BASE_Q);
                        if (dts === avutil_constant__WEBPACK_IMPORTED_MODULE_13__.NOPTS_VALUE_BIGINT || currentDts < dts) {
                            avpacket = task.streams[i].avpacket;
                            dts = currentDts;
                            index = i;
                            type = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](task.streams[i].stream.codecpar);
                        }
                    }
                }
                if (avpacket) {
                    const now = task.formatContext.ioWriter.getPos();
                    avformat_mux__WEBPACK_IMPORTED_MODULE_16__.writeAVPacket(task.formatContext, avpacket);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_9__.CTypeEnumWrite[17](task.stats + 200, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[17](task.stats + 200) + (task.formatContext.ioWriter.getPos() - now));
                    task.avpacketPool.release(avpacket);
                    task.streams[index].avpacket = 0;
                    if (type === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_9__.CTypeEnumWrite[17](task.stats + 288, dts);
                    }
                    else if (type === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_9__.CTypeEnumWrite[17](task.stats + 304, dts);
                    }
                }
                else {
                    avformat_mux__WEBPACK_IMPORTED_MODULE_16__.writeTrailer(task.formatContext);
                    avformat_mux__WEBPACK_IMPORTED_MODULE_16__.flush(task.formatContext);
                    task.rightIPCPort.notify('end');
                    common_util_logger__WEBPACK_IMPORTED_MODULE_7__.info('mux end', cheap__fileName__2, 325);
                    task.loop.stop();
                    task.ended = true;
                }
            }, 0, 0, false, false);
            task.loop.start();
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.fatal('task not found', cheap__fileName__2, 333);
        }
    }
    async pause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.loop) {
                await task.loop.stopBeforeNextTick();
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.fatal('task not found', cheap__fileName__2, 345);
        }
    }
    async unpause(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.loop && !task.loop.isStarted() && !task.ended) {
                task.loop.start();
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_7__.fatal('task not found', cheap__fileName__2, 357);
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_8__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.loop) {
                await task.loop.stopBeforeNextTick();
                task.loop.destroy();
            }
            common_util_array__WEBPACK_IMPORTED_MODULE_18__.each(task.streams, (stream) => {
                if (stream.avpacket) {
                    task.avpacketPool.release(stream.avpacket);
                    stream.avpacket = 0;
                }
                stream.pullIPC.destroy();
            });
            task.formatContext.destroy();
            this.tasks.delete(taskId);
        }
    }
}


/***/ }),

/***/ "./src/avpipeline/Pipeline.ts":
/*!************************************!*\
  !*** ./src/avpipeline/Pipeline.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Pipeline)
/* harmony export */ });
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/*
 * libmedia abstract Pipeline
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class Pipeline {
    tasks;
    constructor() {
        this.tasks = new Map();
    }
    async clear() {
        if (this.tasks.size) {
            for (const key of this.tasks.keys()) {
                await this.unregisterTask(key);
            }
        }
    }
    async setLogLevel(level) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_0__.setLevel(level);
    }
    async getTaskCount() {
        return this.tasks.size;
    }
}


/***/ }),

/***/ "./src/avpipeline/VideoDecodePipeline.ts":
/*!***********************************************!*\
  !*** ./src/avpipeline/VideoDecodePipeline.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VideoDecodePipeline)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../cheap/std/collection/List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../avutil/struct/rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var avcodec_wasmcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! avcodec/wasmcodec/VideoDecoder */ "./src/avcodec/wasmcodec/VideoDecoder.ts");
/* harmony import */ var avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avcodec/webcodec/VideoDecoder */ "./src/avcodec/webcodec/VideoDecoder.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! avutil/implement/AVFramePoolImpl */ "./src/avutil/implement/AVFramePoolImpl.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
var cheap__fileName__0 = "src/avpipeline/VideoDecodePipeline.ts";





/*
 * libmedia VideoDecodePipeline
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

















class VideoDecodePipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
    }
    createWebcodecDecoder(task, enableHardwareAcceleration = true) {
        return new avcodec_webcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_1__["default"]({
            onError: (error) => {
                if (task.hardwareRetryCount > 3 || !task.firstDecoded) {
                    if (task.targetDecoder === task.hardwareDecoder) {
                        task.targetDecoder = task.softwareDecoder;
                        task.hardwareDecoder.close();
                        task.hardwareDecoder = null;
                        task.decoderReady = this.openSoftwareDecoder(task);
                        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.warn(`video decode error width hardware(${task.hardwareRetryCount}), taskId: ${task.taskId}, error: ${error}, try to fallback to software decoder`, cheap__fileName__0, 116);
                    }
                }
                else {
                    task.hardwareRetryCount++;
                    try {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.info(`retry open hardware decoder(${task.hardwareRetryCount}), taskId: ${task.taskId}`, cheap__fileName__0, 122);
                        task.decoderReady = task.hardwareDecoder.open(task.parameters);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.warn(`retry open hardware decoder failed, fallback to software decoder, taskId: ${task.taskId}`, cheap__fileName__0, 126);
                    }
                }
                task.needKeyFrame = true;
                task.leftIPCPort.request('requestKeyframe');
            },
            onReceiveFrame(frame) {
                task.firstDecoded = true;
                task.frameCaches.push(frame);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 144, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](task.stats + 144) + BigInt(1));
                if (task.lastDecodeTimestamp) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 248, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_5__["default"])() - task.lastDecodeTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.stats + 248)));
                }
                task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_5__["default"])();
            },
            enableHardwareAcceleration
        });
    }
    createTask(options) {
        const leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__["default"](options.leftPort);
        const rightIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__["default"](options.rightPort);
        const frameCaches = [];
        const avframePool = new avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_7__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(options.avframeList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_9__["default"]), options.avframeListMutex);
        const task = {
            ...options,
            leftIPCPort,
            rightIPCPort,
            softwareDecoder: null,
            hardwareDecoder: null,
            frameCaches,
            inputEnd: false,
            targetDecoder: null,
            needKeyFrame: true,
            parameters: 0,
            hardwareRetryCount: 0,
            lastDecodeTimestamp: 0,
            firstDecoded: false,
            decoderReady: null,
            softwareDecoderOpened: false,
            avframePool,
            avpacketPool: new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_10__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_9__["default"]), options.avpacketListMutex)
        };
        task.softwareDecoder = options.resource
            ? new avcodec_wasmcodec_VideoDecoder__WEBPACK_IMPORTED_MODULE_11__["default"]({
                resource: options.resource,
                onError: (error) => {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`video decode error, taskId: ${options.taskId}, error: ${error}`, cheap__fileName__0, 184);
                    const task = this.tasks.get(options.taskId);
                    if (task.openReject) {
                        task.openReject(error);
                        task.openReject = null;
                    }
                },
                onReceiveFrame(frame) {
                    task.firstDecoded = true;
                    frameCaches.push(frame);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 144, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](task.stats + 144) + BigInt(1));
                    if (task.lastDecodeTimestamp) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 248, Math.max((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_5__["default"])() - task.lastDecodeTimestamp, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.stats + 248)));
                    }
                    task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_5__["default"])();
                },
                avframePool: avframePool
            })
            : (common_util_support__WEBPACK_IMPORTED_MODULE_12__["default"].videoDecoder ? this.createWebcodecDecoder(task, false) : null);
        if (!task.softwareDecoder) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error('software decoder not support', cheap__fileName__0, 208);
            return avutil_error__WEBPACK_IMPORTED_MODULE_13__.INVALID_OPERATE;
        }
        if (common_util_support__WEBPACK_IMPORTED_MODULE_12__["default"].videoDecoder && options.enableHardware) {
            task.hardwareDecoder = this.createWebcodecDecoder(task);
        }
        task.targetDecoder = task.hardwareDecoder || task.softwareDecoder;
        this.tasks.set(options.taskId, task);
        rightIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_6__.REQUEST, async (request) => {
            switch (request.method) {
                case 'pull': {
                    if (frameCaches.length) {
                        const frame = frameCaches.shift();
                        rightIPCPort.reply(request, frame, null, common_util_is__WEBPACK_IMPORTED_MODULE_14__.number(frame) ? null : [frame]);
                        break;
                    }
                    else if (!task.inputEnd) {
                        while (true) {
                            if (frameCaches.length) {
                                const frame = frameCaches.shift();
                                rightIPCPort.reply(request, frame, null, common_util_is__WEBPACK_IMPORTED_MODULE_14__.number(frame) ? null : [frame]);
                                break;
                            }
                            if (task.decoderReady) {
                                await task.decoderReady;
                                task.decoderReady = null;
                            }
                            const avpacket = await leftIPCPort.request('pull');
                            if (avpacket === -1048576 /* IOError.END */) {
                                if (task.targetDecoder === task.hardwareDecoder) {
                                    // 硬解的 flush 有时会卡主，这里设置 2 秒超时，若超时只能丢弃还未 flush 出来的帧了
                                    let ret = await Promise.race([
                                        new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_15__["default"](2),
                                        task.targetDecoder.flush()
                                    ]);
                                    if (common_util_is__WEBPACK_IMPORTED_MODULE_14__.number(ret)) {
                                        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.warn(`video hardware decoder flush failed, ignore it, taskId: ${task.taskId}`, cheap__fileName__0, 251);
                                    }
                                }
                                else {
                                    await task.targetDecoder.flush();
                                }
                                task.inputEnd = true;
                                // 等待 flush 出的帧入队
                                if (task.targetDecoder === task.hardwareDecoder) {
                                    await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_15__["default"](0);
                                }
                                if (frameCaches.length) {
                                    const frame = frameCaches.shift();
                                    rightIPCPort.reply(request, frame, null, task.targetDecoder === task.hardwareDecoder ? [frame] : null);
                                    break;
                                }
                                else {
                                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.info(`video decoder ended, taskId: ${task.taskId}`, cheap__fileName__0, 268);
                                    rightIPCPort.reply(request, -1048576 /* IOError.END */);
                                    break;
                                }
                            }
                            else if (avpacket > 0) {
                                if (task.needKeyFrame) {
                                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                                        task.needKeyFrame = false;
                                    }
                                    else {
                                        task.avpacketPool.release(avpacket);
                                        continue;
                                    }
                                }
                                let ret = task.targetDecoder.decode(avpacket);
                                if (ret < 0) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 136, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.stats + 136) + 1);
                                    if (task.targetDecoder === task.hardwareDecoder && task.softwareDecoder) {
                                        task.targetDecoder = task.softwareDecoder;
                                        task.hardwareDecoder.close();
                                        task.hardwareDecoder = null;
                                        await this.openSoftwareDecoder(task);
                                        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.warn(`video decode error width hardware, taskId: ${task.taskId}, error: ${ret}, try to fallback to software decoder`, cheap__fileName__0, 297);
                                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */) {
                                            ret = task.targetDecoder.decode(avpacket);
                                            if (ret >= 0) {
                                                task.avpacketPool.release(avpacket);
                                                continue;
                                            }
                                        }
                                        else {
                                            task.avpacketPool.release(avpacket);
                                            task.needKeyFrame = true;
                                            task.leftIPCPort.request('requestKeyframe');
                                            continue;
                                        }
                                    }
                                    task.avpacketPool.release(avpacket);
                                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`video decode error, taskId: ${options.taskId}, ret: ${ret}`, cheap__fileName__0, 313);
                                    rightIPCPort.reply(request, ret);
                                    break;
                                }
                                task.avpacketPool.release(avpacket);
                                // 硬解队列中的 EncodedVideoChunk 过多会报错， 这里判断做一下延时
                                while (task.targetDecoder === task.hardwareDecoder
                                    && task.hardwareDecoder.getQueueLength() > 20) {
                                    await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_15__["default"](0);
                                }
                                continue;
                            }
                            else {
                                common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`video decode pull avpacket error, taskId: ${options.taskId}, ret: ${avpacket}`, cheap__fileName__0, 327);
                                rightIPCPort.reply(request, avpacket);
                                break;
                            }
                        }
                        break;
                    }
                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.info(`video decoder ended, taskId: ${task.taskId}`, cheap__fileName__0, 334);
                    rightIPCPort.reply(request, -1048576 /* IOError.END */);
                    break;
                }
            }
        });
        return 0;
    }
    async openSoftwareDecoder(task) {
        if (task.softwareDecoder && !task.softwareDecoderOpened) {
            const parameters = task.parameters;
            let threadCount = 1;
            if ((0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_16__["default"])()) {
                let pixels = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 56) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 60);
                let framerate = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_17__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(parameters + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_18__.Rational));
                if (pixels >= 2073600 && pixels <= 2211840) {
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                        threadCount = 2;
                    }
                    if (framerate > 30) {
                        threadCount = 2;
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */
                            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                            threadCount = 4;
                        }
                    }
                    else if (framerate > 60) {
                        threadCount = 4;
                        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */
                            || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                            threadCount = 6;
                        }
                    }
                }
                else if (pixels > 2211840 && pixels <= 8294400) {
                    threadCount = 4;
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                        threadCount = 6;
                    }
                }
                else if (pixels > 8294400) {
                    threadCount = 6;
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */
                        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](parameters + 4) === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                        threadCount = 8;
                    }
                }
                threadCount = Math.min(threadCount, navigator.hardwareConcurrency);
            }
            await task.softwareDecoder.open(parameters, threadCount);
            task.softwareDecoderOpened = true;
        }
    }
    async open(taskId, parameters) {
        const task = this.tasks.get(taskId);
        if (task) {
            return new Promise(async (resolve, reject) => {
                task.openReject = reject;
                if (task.hardwareDecoder) {
                    try {
                        await task.hardwareDecoder.open(parameters);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`cannot open hardware decoder, ${error}`, cheap__fileName__0, 413);
                        task.hardwareDecoder.close();
                        task.hardwareDecoder = null;
                        task.targetDecoder = task.softwareDecoder;
                    }
                }
                task.parameters = parameters;
                if (task.targetDecoder === task.softwareDecoder) {
                    await this.openSoftwareDecoder(task);
                }
                resolve();
            });
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal('task not found', cheap__fileName__0, 429);
    }
    async setPlayRate(taskId, rate) {
        const task = this.tasks.get(taskId);
        if (task && task.softwareDecoder) {
            let discard = -16 /* AVDiscard.AVDISCARD_NONE */;
            let framerate = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_17__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(task.parameters + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_18__.Rational));
            if (framerate >= 120) {
                if (rate <= 1) {
                    discard = -16 /* AVDiscard.AVDISCARD_NONE */;
                }
                else if (rate < 1.5) {
                    discard = 8 /* AVDiscard.AVDISCARD_NONREF */;
                }
                else if (rate < 3) {
                    // 跳过所有帧间编码帧
                    discard = 8 /* AVDiscard.AVDISCARD_NONREF */;
                }
                else {
                    // 跳过所有帧间编码帧
                    discard = 32 /* AVDiscard.AVDISCARD_NONKEY */;
                }
            }
            else if (framerate >= 60) {
                if (rate < 1.5) {
                    discard = -16 /* AVDiscard.AVDISCARD_NONE */;
                }
                else if (rate < 3) {
                    discard = 8 /* AVDiscard.AVDISCARD_NONREF */;
                }
                else if (rate < 8) {
                    discard = 24 /* AVDiscard.AVDISCARD_NONINTRA */;
                }
                else {
                    discard = 32 /* AVDiscard.AVDISCARD_NONKEY */;
                }
            }
            else {
                discard = -16 /* AVDiscard.AVDISCARD_NONE */;
            }
            task.softwareDecoder.setSkipFrameDiscard(discard);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal('task not found', cheap__fileName__0, 473);
        }
    }
    async resetTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.targetDecoder === task.softwareDecoder) {
                await task.targetDecoder.flush();
            }
            // webcodec flush 有可能会卡主，这里重新创建解码器
            else if (task.targetDecoder === task.hardwareDecoder) {
                task.hardwareDecoder.close();
                task.hardwareDecoder = this.createWebcodecDecoder(task);
                await task.hardwareDecoder.open(task.parameters);
                task.targetDecoder = task.hardwareDecoder;
            }
            common_util_array__WEBPACK_IMPORTED_MODULE_19__.each(task.frameCaches, (frame) => {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_14__.number(frame)) {
                    task.avframePool.release(frame);
                }
                else {
                    frame.close();
                }
            });
            task.frameCaches.length = 0;
            task.needKeyFrame = true;
            task.inputEnd = false;
            task.lastDecodeTimestamp = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_5__["default"])();
            common_util_logger__WEBPACK_IMPORTED_MODULE_2__.info(`reset video decoder, taskId: ${task.taskId}`, cheap__fileName__0, 503);
        }
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_13__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.rightPort.close();
            task.leftPort.close();
            if (task.softwareDecoder) {
                task.softwareDecoder.close();
            }
            if (task.hardwareDecoder) {
                task.hardwareDecoder.close();
            }
            task.frameCaches.forEach((frame) => {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_14__.number(frame)) {
                    task.avframePool.release(frame);
                }
                else {
                    frame.close();
                }
            });
            this.tasks.delete(taskId);
        }
    }
    async getTasksInfo() {
        const info = [];
        this.tasks.forEach((task) => {
            info.push({
                codecId: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.parameters + 4),
                width: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.parameters + 56),
                height: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.parameters + 60),
                framerate: (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_17__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(task.parameters + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_18__.Rational)),
                hardware: task.targetDecoder === task.hardwareDecoder
            });
        });
        return info;
    }
}


/***/ }),

/***/ "./src/avpipeline/VideoEncodePipeline.ts":
/*!***********************************************!*\
  !*** ./src/avpipeline/VideoEncodePipeline.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VideoEncodePipeline)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../cheap/std/collection/List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../avutil/struct/rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avutil/implement/AVFramePoolImpl */ "./src/avutil/implement/AVFramePoolImpl.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
/* harmony import */ var avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! avutil/implement/AVPacketPoolImpl */ "./src/avutil/implement/AVPacketPoolImpl.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var avcodec_wasmcodec_VideoEncoder__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! avcodec/wasmcodec/VideoEncoder */ "./src/avcodec/wasmcodec/VideoEncoder.ts");
/* harmony import */ var avcodec_webcodec_VideoEncoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avcodec/webcodec/VideoEncoder */ "./src/avcodec/webcodec/VideoEncoder.ts");
var cheap__fileName__0 = "src/avpipeline/VideoEncodePipeline.ts";





/*
 * libmedia VideoEncodePipeline
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */















class VideoEncodePipeline extends _Pipeline__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
    }
    createWebcodecEncoder(task, enableHardwareAcceleration = true) {
        return new avcodec_webcodec_VideoEncoder__WEBPACK_IMPORTED_MODULE_1__["default"]({
            onError: (error) => {
                if (task.targetEncoder === task.hardwareEncoder) {
                    task.targetEncoder = task.softwareEncoder;
                    task.hardwareEncoder.close();
                    task.hardwareEncoder = null;
                    task.encoderReady = this.openSoftwareEncoder(task);
                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.warn(`video encode error width hardware, taskId: ${task.taskId}, error: ${error}, try to fallback to software encoder`, cheap__fileName__0, 111);
                }
            },
            onReceivePacket(avpacket, avframe) {
                task.avpacketCaches.push(avpacket);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 152, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](task.stats + 152) + BigInt(1));
                if (avframe) {
                    task.avframePool.release(avframe);
                }
            },
            enableHardwareAcceleration,
            avpacketPool: task.avpacketPool,
            avframePool: task.avframePool
        });
    }
    createTask(options) {
        const leftIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_5__["default"](options.leftPort);
        const rightIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_5__["default"](options.rightPort);
        const avpacketCaches = [];
        const avframePool = new avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_6__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_7__["default"])(options.avframeList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_8__["default"]), options.avframeListMutex);
        const avpacketPool = new avutil_implement_AVPacketPoolImpl__WEBPACK_IMPORTED_MODULE_9__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_7__["default"])(options.avpacketList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_8__["default"]), options.avpacketListMutex);
        const task = {
            ...options,
            leftIPCPort,
            rightIPCPort,
            softwareEncoder: null,
            hardwareEncoder: null,
            avpacketCaches,
            inputEnd: false,
            targetEncoder: null,
            parameters: 0,
            timeBase: null,
            encoderReady: null,
            softwareEncoderOpened: false,
            gopCounter: 0,
            avframePool,
            avpacketPool
        };
        task.softwareEncoder = options.resource
            ? new avcodec_wasmcodec_VideoEncoder__WEBPACK_IMPORTED_MODULE_10__["default"]({
                resource: options.resource,
                onError: (error) => {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`video encode error, taskId: ${options.taskId}, error: ${error}`, cheap__fileName__0, 162);
                    const task = this.tasks.get(options.taskId);
                    if (task.openReject) {
                        task.openReject(error);
                        task.openReject = null;
                    }
                },
                onReceiveAVPacket(avpacket) {
                    task.avpacketCaches.push(avpacket);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[17](task.stats + 152, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[17](task.stats + 152) + BigInt(1));
                },
                avpacketPool
            })
            : (common_util_support__WEBPACK_IMPORTED_MODULE_11__["default"].videoEncoder ? this.createWebcodecEncoder(task, false) : null);
        if (!task.softwareEncoder) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error('software encoder not support', cheap__fileName__0, 178);
            return avutil_error__WEBPACK_IMPORTED_MODULE_12__.INVALID_OPERATE;
        }
        if (common_util_support__WEBPACK_IMPORTED_MODULE_11__["default"].videoEncoder && options.enableHardware) {
            task.hardwareEncoder = this.createWebcodecEncoder(task);
        }
        task.targetEncoder = task.hardwareEncoder || task.softwareEncoder;
        this.tasks.set(options.taskId, task);
        rightIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_5__.REQUEST, async (request) => {
            switch (request.method) {
                case 'pull': {
                    if (avpacketCaches.length) {
                        const avpacket = avpacketCaches.shift();
                        rightIPCPort.reply(request, avpacket);
                        break;
                    }
                    else if (!task.inputEnd) {
                        while (true) {
                            if (avpacketCaches.length) {
                                const avpacket = avpacketCaches.shift();
                                rightIPCPort.reply(request, avpacket);
                                break;
                            }
                            if (task.encoderReady) {
                                await task.encoderReady;
                                task.encoderReady = null;
                            }
                            const avframe = await leftIPCPort.request('pull');
                            if (!common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(avframe) || avframe > 0) {
                                let ret = task.targetEncoder.encode(avframe, task.gopCounter === 0);
                                if (ret < 0) {
                                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[15](task.stats + 140, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.stats + 140) + 1);
                                    if (task.targetEncoder === task.hardwareEncoder && task.softwareEncoder) {
                                        task.targetEncoder = task.softwareEncoder;
                                        task.hardwareEncoder.close();
                                        task.hardwareEncoder = null;
                                        await this.openSoftwareEncoder(task);
                                        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.warn(`video encode error width hardware, taskId: ${task.taskId}, error: ${ret}, try to fallback to software encode`, cheap__fileName__0, 223);
                                        ret = task.targetEncoder.encode(avframe, task.gopCounter === 0);
                                    }
                                    if (ret < 0) {
                                        if (common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(avframe)) {
                                            task.avframePool.release(avframe);
                                        }
                                        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`video encode error, taskId: ${options.taskId}, ret: ${ret}`, cheap__fileName__0, 231);
                                        rightIPCPort.reply(request, ret);
                                        break;
                                    }
                                }
                                task.gopCounter++;
                                if (task.gopCounter === task.gop) {
                                    task.gopCounter = 0;
                                }
                                if (common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(avframe)) {
                                    task.avframePool.release(avframe);
                                }
                                else {
                                    avframe.close();
                                }
                                // 硬解队列中的 EncodedVideoChunk 过多会报错， 这里判断做一下延时
                                while (task.targetEncoder instanceof avcodec_webcodec_VideoEncoder__WEBPACK_IMPORTED_MODULE_1__["default"]
                                    && task.targetEncoder.getQueueLength() > 10) {
                                    await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_14__["default"](0);
                                }
                                continue;
                            }
                            else {
                                if (avframe === -1048576 /* IOError.END */) {
                                    if (task.targetEncoder === task.hardwareEncoder) {
                                        // 硬解的 flush 有时会卡主，这里设置 2 秒超时，若超时只能丢弃还未 flush 出来的帧了
                                        let ret = await Promise.race([
                                            new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_14__["default"](2),
                                            task.targetEncoder.flush()
                                        ]);
                                        if (common_util_is__WEBPACK_IMPORTED_MODULE_13__.number(ret)) {
                                            common_util_logger__WEBPACK_IMPORTED_MODULE_2__.warn(`video hardware encoder flush failed, ignore it, taskId: ${task.taskId}`, cheap__fileName__0, 263);
                                        }
                                    }
                                    else {
                                        await task.targetEncoder.flush();
                                    }
                                    task.inputEnd = true;
                                    // 等待 flush 出的帧入队
                                    if (task.targetEncoder === task.hardwareEncoder) {
                                        await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_14__["default"](0);
                                    }
                                    if (avpacketCaches.length) {
                                        const avpacket = avpacketCaches.shift();
                                        rightIPCPort.reply(request, avpacket);
                                        break;
                                    }
                                    else {
                                        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.info(`video encoder ended, taskId: ${task.taskId}`, cheap__fileName__0, 280);
                                        rightIPCPort.reply(request, -1048576 /* IOError.END */);
                                        break;
                                    }
                                }
                                else {
                                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`video encoder pull avframe error, taskId: ${options.taskId}, ret: ${avframe}`, cheap__fileName__0, 286);
                                    rightIPCPort.reply(request, avframe);
                                    break;
                                }
                            }
                        }
                        break;
                    }
                    common_util_logger__WEBPACK_IMPORTED_MODULE_2__.info(`video encoder ended, taskId: ${task.taskId}`, cheap__fileName__0, 294);
                    rightIPCPort.reply(request, -1048576 /* IOError.END */);
                    break;
                }
            }
        });
        return 0;
    }
    async openSoftwareEncoder(task) {
        if (task.softwareEncoder && !task.softwareEncoderOpened) {
            const parameters = task.parameters;
            let threadCount = 1;
            if ((0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_15__["default"])()) {
                threadCount = Math.max(threadCount, navigator.hardwareConcurrency - 2);
            }
            await task.softwareEncoder.open(parameters, task.timeBase, threadCount);
            task.softwareEncoderOpened = true;
        }
    }
    async open(taskId, parameters, timeBase) {
        const task = this.tasks.get(taskId);
        if (task) {
            return new Promise(async (resolve, reject) => {
                task.openReject = reject;
                if (task.hardwareEncoder) {
                    try {
                        await task.hardwareEncoder.open(parameters, timeBase);
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.error(`cannot open hardware encoder, ${error}`, cheap__fileName__0, 326);
                        task.hardwareEncoder.close();
                        task.hardwareEncoder = null;
                        task.targetEncoder = task.softwareEncoder;
                    }
                }
                task.parameters = parameters;
                task.timeBase = timeBase;
                if (task.targetEncoder === task.softwareEncoder) {
                    await this.openSoftwareEncoder(task);
                }
                resolve();
            });
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal('task not found', cheap__fileName__0, 343);
    }
    async resetTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.targetEncoder === task.softwareEncoder) {
                await task.targetEncoder.flush();
            }
            // webcodec flush 有可能会卡主，这里重新创建编码器
            else if (task.targetEncoder === task.hardwareEncoder) {
                task.hardwareEncoder.close();
                task.hardwareEncoder = this.createWebcodecEncoder(task);
                await task.hardwareEncoder.open(task.parameters, task.timeBase);
                task.targetEncoder = task.hardwareEncoder;
            }
            common_util_array__WEBPACK_IMPORTED_MODULE_16__.each(task.avpacketCaches, (avpacket) => {
                task.avpacketPool.release(avpacket);
            });
            task.avpacketCaches.length = 0;
            task.inputEnd = false;
            common_util_logger__WEBPACK_IMPORTED_MODULE_2__.info(`reset video encode, taskId: ${task.taskId}`, cheap__fileName__0, 365);
        }
    }
    async getExtraData(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            return task.targetEncoder.getExtraData();
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal('task not found', cheap__fileName__0, 374);
    }
    async getColorSpace(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            return task.targetEncoder.getColorSpace();
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_2__.fatal('task not found', cheap__fileName__0, 382);
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_12__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            task.rightPort.close();
            task.leftPort.close();
            if (task.softwareEncoder) {
                task.softwareEncoder.close();
            }
            if (task.hardwareEncoder) {
                task.hardwareEncoder.close();
            }
            common_util_array__WEBPACK_IMPORTED_MODULE_16__.each(task.avpacketCaches, (avpacket) => {
                task.avpacketPool.release(avpacket);
            });
            this.tasks.delete(taskId);
        }
    }
    async getTasksInfo() {
        const info = [];
        this.tasks.forEach((task) => {
            info.push({
                codecId: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.parameters + 4),
                width: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.parameters + 56),
                height: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](task.parameters + 60),
                framerate: (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_17__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_7__["default"])(task.parameters + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_18__.Rational)),
                hardware: task.targetEncoder === task.hardwareEncoder
            });
        });
        return info;
    }
}


/***/ }),

/***/ "./src/avpipeline/struct/stats.ts":
/*!****************************************!*\
  !*** ./src/avpipeline/struct/stats.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Stats)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


/*
 * libmedia stats struct defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class Stats {
    /**
     * 音频通道数
     */
    channels;
    /**
     * 音频采样率
     */
    sampleRate;
    /**
     * 音频帧大小
     */
    audioFrameSize;
    /**
     * 音频包总字节数
     */
    audioPacketBytes;
    /**
     * 音频包总数
     */
    audioPacketCount;
    /**
     * 当前音频包队列长度
     */
    audioPacketQueueLength;
    /**
     * 音频包丢弃总数
     */
    audioDropPacketCount;
    /**
     * 音频解码错误包总数
     */
    audioDecodeErrorPacketCount;
    /**
     * 音频编码错误帧总数
     */
    audioEncodeErrorFrameCount;
    /**
     * 音频解码帧总数
     */
    audioFrameDecodeCount;
    /**
     * 音频编码包总数
     */
    audioPacketEncodeCount;
    /**
     * 音频渲染帧总数
     */
    audioFrameRenderCount;
    /**
     * 音频帧丢弃总数
     */
    audioFrameDropCount;
    /**
     * 视频宽度
     */
    width;
    /**
     * 视频高度
     */
    height;
    /**
     * 视频关键帧间隔
     */
    keyFrameInterval;
    /**
     * 视频 gop 长度
     */
    gop;
    /**
     * 视频包总字节数
     */
    videoPacketBytes;
    /**
     * 视频包总数
     */
    videoPacketCount;
    /**
     * 当前视频包队列总数
     */
    videoPacketQueueLength;
    /**
     * 视频包丢弃总数
     */
    videoDropPacketCount;
    /**
     * 视频包解码错误总数
     */
    videoDecodeErrorPacketCount;
    /**
     * 视频编码错误帧总数
     */
    videoEncodeErrorFrameCount;
    /**
     * 视频解码帧总数
     */
    videoFrameDecodeCount;
    /**
     * 视频编码包总数
     */
    videoPacketEncodeCount;
    /**
     * 视频渲染帧总数
     */
    videoFrameRenderCount;
    /**
     * 视频帧丢弃总数（解码未渲染）
     */
    videoFrameDropCount;
    /**
     * 视频关键帧总数
     */
    keyFrameCount;
    /**
     * buffer 丢弃总字节数
     */
    bufferDropBytes;
    /**
     * buffer 接收总字节数
     */
    bufferReceiveBytes;
    /**
     * buffer 总输出字节数
     *
     */
    bufferOutputBytes;
    /**
     * 音频码率
     */
    audioBitrate;
    /**
     * 视频码率
     */
    videoBitrate;
    /**
     * 视频解码帧率
     */
    videoDecodeFramerate;
    /**
     * 视频渲染帧率
     */
    videoRenderFramerate;
    /**
     * 视频编码帧率（根据 dts 计算）
     */
    videoEncodeFramerate;
    /**
     * 音频解码帧率
     */
    audioDecodeFramerate;
    /**
     * 音频渲染帧率
     */
    audioRenderFramerate;
    /**
     * 音视频编码帧率（根据 dts 计算）
     */
    audioEncodeFramerate;
    /**
     * 音频最大解码帧间隔（毫秒）
     */
    audioFrameDecodeIntervalMax;
    /**
     * 音频最大渲染帧间隔（毫秒）
     */
    audioFrameRenderIntervalMax;
    /**
     * 视频最大解码帧间隔（毫秒）
     */
    videoFrameDecodeIntervalMax;
    /**
     * 视频最大渲染帧间隔（毫秒）
     */
    videoFrameRenderIntervalMax;
    /**
     * 接收带宽
     */
    bandwidth;
    /**
     * 抖动指标
     */
    jitter;
    /**
     * 音频卡顿次数
     */
    audioStutter;
    /**
     * 视频卡顿次数
     */
    videoStutter;
    /**
     * 音频 codec string
     */
    audiocodec;
    /**
     * 视频 codec string
     */
    videocodec;
    /**
     * 首个 audio mux dts
     */
    firstAudioMuxDts;
    /**
     * 上一次 audio mux dts
     */
    lastAudioMuxDts;
    /**
     * 首个 audio mux dts
     */
    firstVideoMuxDts;
    /**
     * 上一次 video mux dts
     */
    lastVideoMuxDts;
}
(function (prototype) {
    var map = new Map();
    map.set("channels", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("sampleRate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("audioFrameSize", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("audioPacketBytes", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("audioPacketCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("audioPacketQueueLength", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 32, 8: 0 });
    map.set("audioDropPacketCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 40, 8: 0 });
    map.set("audioDecodeErrorPacketCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 48, 8: 0 });
    map.set("audioEncodeErrorFrameCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 52, 8: 0 });
    map.set("audioFrameDecodeCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 56, 8: 0 });
    map.set("audioPacketEncodeCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 64, 8: 0 });
    map.set("audioFrameRenderCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 72, 8: 0 });
    map.set("audioFrameDropCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 80, 8: 0 });
    map.set("width", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 84, 8: 0 });
    map.set("height", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 88, 8: 0 });
    map.set("keyFrameInterval", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 92, 8: 0 });
    map.set("gop", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 96, 8: 0 });
    map.set("videoPacketBytes", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 104, 8: 0 });
    map.set("videoPacketCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 112, 8: 0 });
    map.set("videoPacketQueueLength", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 120, 8: 0 });
    map.set("videoDropPacketCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 128, 8: 0 });
    map.set("videoDecodeErrorPacketCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 136, 8: 0 });
    map.set("videoEncodeErrorFrameCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 140, 8: 0 });
    map.set("videoFrameDecodeCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 144, 8: 0 });
    map.set("videoPacketEncodeCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 152, 8: 0 });
    map.set("videoFrameRenderCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 160, 8: 0 });
    map.set("videoFrameDropCount", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 168, 8: 0 });
    map.set("keyFrameCount", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 176, 8: 0 });
    map.set("bufferDropBytes", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 184, 8: 0 });
    map.set("bufferReceiveBytes", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 192, 8: 0 });
    map.set("bufferOutputBytes", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 200, 8: 0 });
    map.set("audioBitrate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 208, 8: 0 });
    map.set("videoBitrate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 212, 8: 0 });
    map.set("videoDecodeFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 216, 8: 0 });
    map.set("videoRenderFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 220, 8: 0 });
    map.set("videoEncodeFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 224, 8: 0 });
    map.set("audioDecodeFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 228, 8: 0 });
    map.set("audioRenderFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 232, 8: 0 });
    map.set("audioEncodeFramerate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 236, 8: 0 });
    map.set("audioFrameDecodeIntervalMax", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 240, 8: 0 });
    map.set("audioFrameRenderIntervalMax", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 244, 8: 0 });
    map.set("videoFrameDecodeIntervalMax", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 248, 8: 0 });
    map.set("videoFrameRenderIntervalMax", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 252, 8: 0 });
    map.set("bandwidth", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 256, 8: 0 });
    map.set("jitter", { 0: 19, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 264, 8: 0 });
    map.set("audioStutter", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 272, 8: 0 });
    map.set("videoStutter", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 276, 8: 0 });
    map.set("firstAudioMuxDts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 280, 8: 0 });
    map.set("lastAudioMuxDts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 288, 8: 0 });
    map.set("firstVideoMuxDts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 296, 8: 0 });
    map.set("lastVideoMuxDts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 304, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 312);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(Stats.prototype);


/***/ }),

/***/ "./src/avtranscoder/AVTranscoder.ts":
/*!******************************************!*\
  !*** ./src/avtranscoder/AVTranscoder.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVTranscoder)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cheap/std/collection/List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var cheap_std_make__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/std/make */ "./src/cheap/std/make.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../avutil/struct/rational.ts */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var _avutil_struct_avcodecparameters_ts__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ../avutil/struct/avcodecparameters.ts */ "./src/avutil/struct/avcodecparameters.ts");
/* harmony import */ var avpipeline_IOPipeline__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! avpipeline/IOPipeline */ "./src/avpipeline/IOPipeline.ts");
/* harmony import */ var avpipeline_DemuxPipeline__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! avpipeline/DemuxPipeline */ "./src/avpipeline/DemuxPipeline.ts");
/* harmony import */ var avpipeline_VideoDecodePipeline__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! avpipeline/VideoDecodePipeline */ "./src/avpipeline/VideoDecodePipeline.ts");
/* harmony import */ var avpipeline_AudioDecodePipeline__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! avpipeline/AudioDecodePipeline */ "./src/avpipeline/AudioDecodePipeline.ts");
/* harmony import */ var cheap_thread_thread__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! cheap/thread/thread */ "./src/cheap/thread/thread.ts");
/* harmony import */ var common_function_generateUUID__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! common/function/generateUUID */ "./src/common/function/generateUUID.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var cheap_webassembly_compiler__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! cheap/webassembly/compiler */ "./src/cheap/webassembly/compiler.ts");
/* harmony import */ var common_util_url__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! common/util/url */ "./src/common/util/url.ts");
/* harmony import */ var cheap_config__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! cheap/config */ "./src/cheap/config.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");
/* harmony import */ var avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! avutil/util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var avutil_constant__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! avutil/constant */ "./src/avutil/constant.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! avcodec/function/getVideoCodec */ "./src/avcodec/function/getVideoCodec.ts");
/* harmony import */ var avpipeline_AudioEncodePipeline__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! avpipeline/AudioEncodePipeline */ "./src/avpipeline/AudioEncodePipeline.ts");
/* harmony import */ var avpipeline_VideoEncodePipeline__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! avpipeline/VideoEncodePipeline */ "./src/avpipeline/VideoEncodePipeline.ts");
/* harmony import */ var avutil_stringEnum__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! avutil/stringEnum */ "./src/avutil/stringEnum.ts");
/* harmony import */ var avpipeline_MuxPipeline__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! avpipeline/MuxPipeline */ "./src/avpipeline/MuxPipeline.ts");
/* harmony import */ var avpipeline_struct_stats__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! avpipeline/struct/stats */ "./src/avpipeline/struct/stats.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var avcodec_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! avcodec/function/getAudioCodec */ "./src/avcodec/function/getAudioCodec.ts");
/* harmony import */ var avutil_util_mem__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! avutil/util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! avutil/util/codecparameters */ "./src/avutil/util/codecparameters.ts");
/* harmony import */ var common_io_SafeFileIO__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! common/io/SafeFileIO */ "./src/common/io/SafeFileIO.ts");
/* harmony import */ var common_event_Emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/event/Emitter */ "./src/common/event/Emitter.ts");
/* harmony import */ var _eventType__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./eventType */ "./src/avtranscoder/eventType.ts");
/* harmony import */ var avutil_util_avframe__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! avutil/util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! avutil/util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var avformat_codecs_aac__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! avformat/codecs/aac */ "./src/avformat/codecs/aac.ts");
/* harmony import */ var avformat_codecs_opus__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! avformat/codecs/opus */ "./src/avformat/codecs/opus.ts");
/* harmony import */ var avformat_codecs_h264__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! avformat/codecs/h264 */ "./src/avformat/codecs/h264.ts");
/* harmony import */ var avformat_codecs_hevc__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! avformat/codecs/hevc */ "./src/avformat/codecs/hevc.ts");
/* harmony import */ var avformat_codecs_av1__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! avformat/codecs/av1 */ "./src/avformat/codecs/av1.ts");
/* harmony import */ var avformat_codecs_vp9__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! avformat/codecs/vp9 */ "./src/avformat/codecs/vp9.ts");
/* harmony import */ var common_timer_Sleep__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! common/timer/Sleep */ "./src/common/timer/Sleep.ts");
/* harmony import */ var _filter_AVFilterPipeline__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./filter/AVFilterPipeline */ "./src/avtranscoder/filter/AVFilterPipeline.ts");
/* harmony import */ var _filter_graph__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./filter/graph */ "./src/avtranscoder/filter/graph.ts");
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var common_timer_Timer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/timer/Timer */ "./src/common/timer/Timer.ts");
/* harmony import */ var common_util_string__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! common/util/string */ "./src/common/util/string.ts");
/* harmony import */ var avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! avutil/function/createMessageChannel */ "./src/avutil/function/createMessageChannel.ts");
/* harmony import */ var _Controller__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./Controller */ "./src/avtranscoder/Controller.ts");
/* harmony import */ var avformat_dump__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! avformat/dump */ "./src/avformat/dump.ts");
var cheap__fileName__12 = "src/avtranscoder/AVTranscoder.ts";






























































class AVTranscoderGlobalData {
    avpacketList;
    avframeList;
    avpacketListMutex;
    avframeListMutex;
}
(function (prototype) {
    var map = new Map();
    map.set("avpacketList", { 0: _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_0__["default"], 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("avframeList", { 0: _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_0__["default"], 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("avpacketListMutex", { 0: _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_1__.Mutex, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("avframeListMutex", { 0: _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_1__.Mutex, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 28, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructLength, 32);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructKeysMeta, map);
})(AVTranscoderGlobalData.prototype);
const defaultAVTranscoderOptions = {
    enableHardware: true
};
class AVTranscoder extends common_event_Emitter__WEBPACK_IMPORTED_MODULE_4__["default"] {
    static Resource = new Map();
    level = common_util_logger__WEBPACK_IMPORTED_MODULE_5__.INFO;
    DemuxThreadReady;
    AudioThreadReady;
    VideoThreadReady;
    MuxThreadReady;
    // 下面的线程所有 AVPlayer 实例共享
    IOThread;
    DemuxerThread;
    MuxThread;
    AudioDecoderThread;
    AudioFilterThread;
    AudioEncoderThread;
    VideoDecoderThread;
    VideoFilterThread;
    VideoEncoderThread;
    // AVTranscoder 各个线程间共享的数据
    GlobalData;
    tasks;
    options;
    reportTimer;
    constructor(options) {
        super(true);
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_6__.extend({}, defaultAVTranscoderOptions, options);
        this.GlobalData = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_7__["default"])(AVTranscoderGlobalData);
        _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_1__.init(this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 24);
        _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_1__.init(this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 28);
        this.tasks = new Map();
        this.reportTimer = new common_timer_Timer__WEBPACK_IMPORTED_MODULE_8__["default"](() => {
            this.report();
        }, 0, 1000);
        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.info(`create transcoder`, cheap__fileName__12, 277);
    }
    async getResource(type, codecId, mediaType) {
        const key = codecId != null ? `${type}-${codecId}` : type;
        if (AVTranscoder.Resource.has(key)) {
            return AVTranscoder.Resource.get(key);
        }
        const wasmUrl = this.options.getWasm(type, codecId, mediaType);
        let resource;
        if (wasmUrl) {
            if (common_util_is__WEBPACK_IMPORTED_MODULE_9__.string(wasmUrl) || common_util_is__WEBPACK_IMPORTED_MODULE_9__.arrayBuffer(wasmUrl)) {
                resource = await (0,cheap_webassembly_compiler__WEBPACK_IMPORTED_MODULE_10__["default"])({
                    source: wasmUrl
                });
                if (cheap_config__WEBPACK_IMPORTED_MODULE_11__.USE_THREADS && true && mediaType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                    resource.threadModule = await (0,cheap_webassembly_compiler__WEBPACK_IMPORTED_MODULE_10__["default"])({
                        // firefox 使用 arraybuffer 会卡主
                        source: common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].firefox ? wasmUrl : resource.buffer
                    }, {
                        child: true
                    });
                }
                delete resource.buffer;
            }
            else {
                resource = wasmUrl;
            }
            AVTranscoder.Resource.set(key, resource);
            return resource;
        }
    }
    report() {
        this.tasks.forEach((task) => {
            if (task.startTime) {
                const frameCount = task.stats.videoPacketEncodeCount || task.stats.audioPacketEncodeCount;
                const time = ((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_13__["default"])() - task.startTime);
                let dts = BigInt(0);
                let duration = BigInt(0);
                if (task.stats.lastVideoMuxDts) {
                    const stream = task.streams.find((s) => cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](s.input.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */);
                    dts = task.stats.lastVideoMuxDts - task.stats.firstVideoMuxDts;
                    if (stream.output) {
                        duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__.avRescaleQ)(stream.output.duration, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__["default"])(stream.output.timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_18__.AV_MILLI_TIME_BASE_Q);
                    }
                    else {
                        duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__.avRescaleQ)(stream.input.duration, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__["default"])(stream.input.timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_18__.AV_MILLI_TIME_BASE_Q);
                    }
                }
                if (task.stats.lastAudioMuxDts && !dts) {
                    const stream = task.streams.find((s) => cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](s.input.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */);
                    dts = task.stats.lastAudioMuxDts - task.stats.firstAudioMuxDts;
                    if (stream.output) {
                        duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__.avRescaleQ)(stream.output.duration, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__["default"])(stream.output.timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_18__.AV_MILLI_TIME_BASE_Q);
                    }
                    else {
                        duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__.avRescaleQ)(stream.input.duration, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__["default"])(stream.input.timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational), avutil_constant__WEBPACK_IMPORTED_MODULE_18__.AV_MILLI_TIME_BASE_Q);
                    }
                }
                const fps = time ? (Number(frameCount) / (time / 1000)) : Number(frameCount);
                const ms = (Number(dts % BigInt(1000) & 0xffffffffn) >> 0);
                const secs = (Number(dts / BigInt(1000) % BigInt(60) & 0xffffffffn) >> 0);
                const mins = (Number(dts / BigInt(1000) / BigInt(60) % BigInt(60) & 0xffffffffn) >> 0);
                const hours = (Number(dts / BigInt(1000) / BigInt(3600) & 0xffffffffn) >> 0);
                const size = Number(task.stats.bufferOutputBytes) / 1000;
                const bitrate = (dts ? size * 8 / (Number(dts) / 1000) : 0);
                const speed = (Number(dts) / 1000 / (time / 1000) || -1);
                let progress = duration ? ((Number(dts) / Number(duration) * 100)) : 0;
                if (progress > 100) {
                    progress = 100;
                }
                common_util_logger__WEBPACK_IMPORTED_MODULE_5__.info(`[${task.taskId}] frame=${frameCount} fps=${fps.toFixed(2)} size=${size}kB time=${common_util_string__WEBPACK_IMPORTED_MODULE_19__.format('%02d:%02d:%02d.%03d', hours, mins, secs, ms)} bitrate=${bitrate.toFixed(2)}kbps speed=${speed.toFixed(2)}x progress=${progress.toFixed(2)}%`, cheap__fileName__12, 358);
                if (this.options.onprogress) {
                    this.options.onprogress(task.taskId, progress);
                }
            }
        });
    }
    async startDemuxPipeline() {
        if (this.DemuxThreadReady) {
            return this.DemuxThreadReady;
        }
        return this.DemuxThreadReady = new Promise(async (resolve) => {
            this.IOThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_20__.createThreadFromClass)(avpipeline_IOPipeline__WEBPACK_IMPORTED_MODULE_21__["default"], {
                name: 'IOThread'
            }, /*require.resolve*/(/*! ../avpipeline/IOPipeline.ts */ "./src/avpipeline/IOPipeline.ts")).run();
            this.IOThread.setLogLevel(this.level);
            this.DemuxerThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_20__.createThreadFromClass)(avpipeline_DemuxPipeline__WEBPACK_IMPORTED_MODULE_22__["default"], {
                name: 'DemuxerThread'
            }, /*require.resolve*/(/*! ../avpipeline/DemuxPipeline.ts */ "./src/avpipeline/DemuxPipeline.ts")).run();
            this.DemuxerThread.setLogLevel(this.level);
            resolve();
        });
    }
    async startVideoPipeline() {
        if (this.VideoThreadReady) {
            return this.VideoThreadReady;
        }
        return this.VideoThreadReady = new Promise(async (resolve) => {
            this.VideoDecoderThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_20__.createThreadFromClass)(avpipeline_VideoDecodePipeline__WEBPACK_IMPORTED_MODULE_23__["default"], {
                name: 'VideoDecoderThread',
                disableWorker: common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].safari && !common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].version, '16.1', true)
            }, /*require.resolve*/(/*! ../avpipeline/VideoDecodePipeline.ts */ "./src/avpipeline/VideoDecodePipeline.ts")).run();
            this.VideoDecoderThread.setLogLevel(this.level);
            this.VideoFilterThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_20__.createThreadFromClass)(_filter_AVFilterPipeline__WEBPACK_IMPORTED_MODULE_24__["default"], {
                name: 'VideoFilterThread',
                disableWorker: common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].safari && !common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].version, '16.1', true)
            }, /*require.resolve*/(/*! ./filter/AVFilterPipeline.ts */ "./src/avtranscoder/filter/AVFilterPipeline.ts")).run();
            this.VideoFilterThread.setLogLevel(this.level);
            this.VideoEncoderThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_20__.createThreadFromClass)(avpipeline_VideoEncodePipeline__WEBPACK_IMPORTED_MODULE_25__["default"], {
                name: 'VideoEncoderThread',
                disableWorker: common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].safari && !common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].version, '16.1', true)
            }, /*require.resolve*/(/*! ../avpipeline/VideoEncodePipeline.ts */ "./src/avpipeline/VideoEncodePipeline.ts")).run();
            this.VideoEncoderThread.setLogLevel(this.level);
            resolve();
        });
    }
    async startAudioPipeline() {
        if (this.AudioThreadReady) {
            return this.AudioThreadReady;
        }
        return this.AudioThreadReady = new Promise(async (resolve) => {
            this.AudioDecoderThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_20__.createThreadFromClass)(avpipeline_AudioDecodePipeline__WEBPACK_IMPORTED_MODULE_26__["default"], {
                name: 'AudioDecoderThread',
                disableWorker: common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].safari && !common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].version, '16.1', true)
            }, /*require.resolve*/(/*! ../avpipeline/AudioDecodePipeline.ts */ "./src/avpipeline/AudioDecodePipeline.ts")).run();
            this.AudioDecoderThread.setLogLevel(this.level);
            this.AudioFilterThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_20__.createThreadFromClass)(_filter_AVFilterPipeline__WEBPACK_IMPORTED_MODULE_24__["default"], {
                name: 'AudioFilterThread',
                disableWorker: common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].safari && !common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].version, '16.1', true)
            }, /*require.resolve*/(/*! ./filter/AVFilterPipeline.ts */ "./src/avtranscoder/filter/AVFilterPipeline.ts")).run();
            this.AudioFilterThread.setLogLevel(this.level);
            this.AudioEncoderThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_20__.createThreadFromClass)(avpipeline_AudioEncodePipeline__WEBPACK_IMPORTED_MODULE_27__["default"], {
                name: 'AudioEncoderThread',
                disableWorker: common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].safari && !common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_12__["default"].version, '16.1', true)
            }, /*require.resolve*/(/*! ../avpipeline/AudioEncodePipeline.ts */ "./src/avpipeline/AudioEncodePipeline.ts")).run();
            this.AudioEncoderThread.setLogLevel(this.level);
            resolve();
        });
    }
    async startMuxPipeline() {
        if (this.MuxThreadReady) {
            return this.MuxThreadReady;
        }
        return this.MuxThreadReady = new Promise(async (resolve) => {
            this.MuxThread = await (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_20__.createThreadFromClass)(avpipeline_MuxPipeline__WEBPACK_IMPORTED_MODULE_28__["default"], {
                name: 'MuxThread',
                disableWorker: !common_util_support__WEBPACK_IMPORTED_MODULE_29__["default"].workerMSE
            }, /*require.resolve*/(/*! ../avpipeline/MuxPipeline.ts */ "./src/avpipeline/MuxPipeline.ts")).run();
            this.MuxThread.setLogLevel(this.level);
            resolve();
        });
    }
    isHls(task) {
        if (task.ext) {
            return task.ext === 'm3u8' || task.ext === 'm3u';
        }
        return task.options.input.protocol === 'hls';
    }
    isDash(task) {
        if (task.ext) {
            return task.ext === 'mpd';
        }
        return task.options.input.protocol === 'dash';
    }
    async ready() {
        await this.startDemuxPipeline();
        await this.startAudioPipeline();
        await this.startVideoPipeline();
        await this.startMuxPipeline();
        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.info('AVTranscoder pipelines started', cheap__fileName__12, 470);
    }
    copyAVStreamInterface(task, stream) {
        const newStream = common_util_object__WEBPACK_IMPORTED_MODULE_6__.extend({}, stream);
        newStream.codecpar = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_30__.avMallocz)(168);
        (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_31__.copyCodecParameters)(newStream.codecpar, stream.codecpar);
        newStream.timeBase = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_30__.avMallocz)(8);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.timeBase + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.timeBase + 4));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.timeBase, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.timeBase));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[20](newStream.codecpar + 12)) {
            (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_30__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[20](newStream.codecpar + 12));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[20](newStream.codecpar + 12, 0);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 16, 0);
        }
        if (task.options.duration) {
            newStream.duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__.avRescaleQ)(BigInt(Math.floor(task.options.duration)), avutil_constant__WEBPACK_IMPORTED_MODULE_18__.AV_MILLI_TIME_BASE_Q, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__["default"])(newStream.timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational));
        }
        return newStream;
    }
    async setTaskInput(task) {
        const taskId = task.taskId;
        const taskOptions = task.options;
        const ioloader2DemuxerChannel = task.ioloader2DemuxerChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_33__["default"])();
        const stats = task.stats;
        let ret = 0;
        let ext;
        if (common_util_is__WEBPACK_IMPORTED_MODULE_9__.string(taskOptions.input.file)) {
            ext = common_util_url__WEBPACK_IMPORTED_MODULE_34__.parse(taskOptions.input.file).file.split('.').pop();
            // 注册一个 url io 任务
            ret = await this.IOThread.registerTask
                .transfer(ioloader2DemuxerChannel.port1)
                .invoke({
                type: avutil_stringEnum__WEBPACK_IMPORTED_MODULE_35__.Ext2IOLoader[ext] ?? 0 /* IOType.Fetch */,
                info: {
                    url: taskOptions.input.file
                },
                range: {
                    from: -1,
                    to: -1
                },
                taskId,
                options: {
                    isLive: false
                },
                rightPort: ioloader2DemuxerChannel.port1,
                stats: stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress]
            });
        }
        else if (taskOptions.input.file instanceof File) {
            ext = taskOptions.input.file.name.split('.').pop();
            // 注册一个文件 io 任务
            ret = await this.IOThread.registerTask
                .transfer(ioloader2DemuxerChannel.port1)
                .invoke({
                type: 1 /* IOType.File */,
                info: {
                    file: taskOptions.input.file
                },
                range: {
                    from: -1,
                    to: -1
                },
                taskId,
                options: {
                    isLive: false
                },
                rightPort: ioloader2DemuxerChannel.port1,
                stats: stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress]
            });
        }
        else {
            const ipcPort = task.inputIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_36__["default"](ioloader2DemuxerChannel.port1);
            ipcPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_36__.REQUEST, async (request) => {
                switch (request.method) {
                    case 'open': {
                        ipcPort.reply(request, {});
                        break;
                    }
                    case 'read': {
                        const pointer = request.params.pointer;
                        const length = request.params.length;
                        const buffer = (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_37__.mapSafeUint8Array)(pointer, length);
                        try {
                            const len = await task.options.input.file.readToBuffer(length, buffer);
                            task.stats.bufferReceiveBytes += BigInt(Math.floor(len));
                            ipcPort.reply(request, len);
                        }
                        catch (error) {
                            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.error(`loader read error, ${error}, taskId: ${task.taskId}`, cheap__fileName__12, 569);
                            ipcPort.reply(request, avutil_error__WEBPACK_IMPORTED_MODULE_38__.DATA_INVALID);
                        }
                        break;
                    }
                    case 'seek': {
                        const pos = request.params.pos;
                        try {
                            await task.options.input.file.seek(pos);
                            ipcPort.reply(request);
                        }
                        catch (error) {
                            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.error(`loader seek error, ${error}, taskId: ${task.taskId}`, cheap__fileName__12, 586);
                            ipcPort.reply(request, null, error);
                        }
                        break;
                    }
                    case 'size': {
                        ipcPort.reply(request, await task.options.input.file.fileSize());
                        break;
                    }
                }
            });
        }
        if (ext) {
            task.ext = ext;
        }
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`register io task failed, ret: ${ret}, taskId: ${taskId}`, cheap__fileName__12, 605);
        }
    }
    async setTaskOutput(task) {
        const muxer2OutputChannel = task.muxer2OutputChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_33__["default"])();
        const ipcPort = task.outputIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_36__["default"](muxer2OutputChannel.port2);
        let format;
        if (task.options.output.format) {
            format = avutil_stringEnum__WEBPACK_IMPORTED_MODULE_35__.Format2AVFormat[task.options.output.format];
        }
        else if (task.options.output.file instanceof FileSystemFileHandle) {
            let ext = task.options.output.file.name.split('.').pop();
            format = avutil_stringEnum__WEBPACK_IMPORTED_MODULE_35__.Ext2Format[ext];
        }
        if (!common_util_is__WEBPACK_IMPORTED_MODULE_9__.number(format)) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal('invalid output format', cheap__fileName__12, 624);
        }
        task.format = format;
        let ret = await this.MuxThread.registerTask.transfer(muxer2OutputChannel.port1)
            .invoke({
            taskId: task.taskId,
            format,
            avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
            avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 24,
            stats: task.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
            rightPort: muxer2OutputChannel.port1
        });
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`register mux task failed, ret: ${ret}, taskId: ${task.taskId}`, cheap__fileName__12, 640);
        }
        let ioWriter;
        if (task.options.output.file instanceof FileSystemFileHandle) {
            ioWriter = task.safeFileIO = new common_io_SafeFileIO__WEBPACK_IMPORTED_MODULE_39__["default"](task.options.output.file);
            await task.safeFileIO.ready();
        }
        else {
            ioWriter = {
                write: (buffer) => {
                    task.options.output.file.writeBuffer(buffer);
                },
                appendBufferByPosition: (buffer, pos) => {
                    task.options.output.file.flush();
                    task.options.output.file.writeBuffer(buffer);
                    task.options.output.file.flushToPos(BigInt(Math.floor(pos)));
                },
                seek: (pos) => {
                    task.options.output.file.seek(BigInt(Math.floor(pos)));
                },
                close: () => {
                    task.options.output.file.flush();
                }
            };
        }
        ipcPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_36__.NOTIFY, async (request) => {
            switch (request.method) {
                case 'write': {
                    try {
                        if (request.params.pos != null) {
                            ioWriter.appendBufferByPosition(request.params.data, Number(request.params.pos));
                        }
                        else {
                            ioWriter.write(request.params.data);
                        }
                        if (task.options.output.file instanceof FileSystemFileHandle) {
                            if (task.safeFileIO.writeQueueSize > 5) {
                                await this.MuxThread.pause(task.taskId);
                                while (task.safeFileIO.writeQueueSize > 5) {
                                    await new common_timer_Sleep__WEBPACK_IMPORTED_MODULE_40__["default"](0);
                                }
                                await this.MuxThread.unpause(task.taskId);
                            }
                        }
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.error(`ioWriter write error, ${error}, taskId: ${task.taskId}`, cheap__fileName__12, 694);
                    }
                    break;
                }
                case 'seek': {
                    const pos = request.params.pos;
                    try {
                        ioWriter.seek(Number(pos));
                    }
                    catch (error) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.error(`ioWriter seek error, ${error}, taskId: ${task.taskId}`, cheap__fileName__12, 707);
                    }
                    break;
                }
                case 'end': {
                    await ioWriter.close();
                    await this.clearTask(task);
                    this.fire(_eventType__WEBPACK_IMPORTED_MODULE_41__.TASK_ENDED, [task.taskId]);
                }
            }
        });
    }
    async analyzeInputStreams(task) {
        const taskId = task.taskId;
        const ioloader2DemuxerChannel = task.ioloader2DemuxerChannel;
        const ext = task.ext;
        const stats = task.stats;
        let ret = 0;
        let subTaskId;
        if ( true && this.isDash(task)) {
            await this.IOThread.open(taskId);
            const hasAudio = await this.IOThread.hasAudio(taskId);
            const hasVideo = await this.IOThread.hasVideo(taskId);
            if (hasAudio && hasVideo) {
                // dash 因为音视频各自独立，因此这里注册两个解封装任务
                subTaskId = (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_42__["default"])();
                await this.DemuxerThread.registerTask
                    .transfer(ioloader2DemuxerChannel.port2, task.controller.getDemuxerRenderControlPort())
                    .invoke({
                    taskId,
                    leftPort: ioloader2DemuxerChannel.port2,
                    controlPort: task.controller.getDemuxerRenderControlPort(),
                    format: avutil_stringEnum__WEBPACK_IMPORTED_MODULE_35__.Ext2Format[ext],
                    stats: stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
                    isLive: false,
                    flags: 2 /* IOFlags.SLICE */,
                    ioloaderOptions: {
                        mediaType: 'audio'
                    },
                    avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
                    avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 24,
                });
                await this.DemuxerThread.registerTask({
                    taskId: subTaskId,
                    mainTaskId: taskId,
                    flags: 2 /* IOFlags.SLICE */,
                    format: avutil_stringEnum__WEBPACK_IMPORTED_MODULE_35__.Ext2Format[ext],
                    stats: stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
                    isLive: false,
                    ioloaderOptions: {
                        mediaType: 'video'
                    },
                    avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
                    avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 24
                });
            }
            else {
                // dash 只有一个媒体类型
                await this.DemuxerThread.registerTask
                    .transfer(ioloader2DemuxerChannel.port2, task.controller.getDemuxerRenderControlPort())
                    .invoke({
                    taskId,
                    leftPort: ioloader2DemuxerChannel.port2,
                    controlPort: task.controller.getDemuxerRenderControlPort(),
                    format: avutil_stringEnum__WEBPACK_IMPORTED_MODULE_35__.Ext2Format[ext],
                    stats: stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
                    isLive: false,
                    flags: 2 /* IOFlags.SLICE */,
                    ioloaderOptions: {
                        mediaType: hasAudio ? 'audio' : 'video'
                    },
                    avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
                    avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 24,
                });
            }
        }
        else {
            await this.DemuxerThread.registerTask
                .transfer(ioloader2DemuxerChannel.port2, task.controller.getDemuxerRenderControlPort())
                .invoke({
                taskId,
                leftPort: ioloader2DemuxerChannel.port2,
                controlPort: task.controller.getDemuxerRenderControlPort(),
                format: avutil_stringEnum__WEBPACK_IMPORTED_MODULE_35__.Ext2Format[ext],
                stats: stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
                isLive: false,
                flags: this.isHls(task) ? 2 /* IOFlags.SLICE */ : 0,
                avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
                avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 24
            });
        }
        ret = await this.DemuxerThread.openStream(taskId);
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`open stream failed, ret: ${ret}, taskId: ${taskId}`, cheap__fileName__12, 804);
        }
        let formatContext = await this.DemuxerThread.analyzeStreams(taskId);
        if (common_util_is__WEBPACK_IMPORTED_MODULE_9__.number(formatContext) || !formatContext.streams.length) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`analyze stream failed, ret: ${formatContext}`, cheap__fileName__12, 808);
        }
        if ( true && subTaskId) {
            ret = await this.DemuxerThread.openStream(subTaskId);
            if (ret < 0) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`open stream failed, ret: ${ret}, taskId: ${taskId}`, cheap__fileName__12, 814);
            }
            const subFormatContext = await this.DemuxerThread.analyzeStreams(subTaskId);
            if (common_util_is__WEBPACK_IMPORTED_MODULE_9__.number(subFormatContext) || !subFormatContext.streams.length) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`analyze stream failed, ret: ${subFormatContext}`, cheap__fileName__12, 818);
            }
            formatContext.streams = formatContext.streams.concat(subFormatContext.streams);
        }
        if (subTaskId) {
            task.subTaskId = subTaskId;
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.info('\n' + (0,avformat_dump__WEBPACK_IMPORTED_MODULE_43__["default"])([formatContext], [{
                from: common_util_is__WEBPACK_IMPORTED_MODULE_9__.string(task.options.input.file) ? task.options.input.file : (task.options.input.file instanceof File ? task.options.input.file.name : 'ioReader'),
                tag: 'Input'
            }]), cheap__fileName__12, 827);
        {
            // m3u8 和 dash 的 duration 来自于协议本身
            if (this.isHls(task) || this.isDash(task)) {
                const duration = (await this.IOThread.getDuration(taskId)) * 1000;
                if (duration > 0) {
                    for (let i = 0; i < formatContext.streams.length; i++) {
                        formatContext.streams[i].duration = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__.avRescaleQ)(BigInt(Math.floor(duration)), avutil_constant__WEBPACK_IMPORTED_MODULE_18__.AV_MILLI_TIME_BASE_Q, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__["default"])(formatContext.streams[i].timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational));
                    }
                }
            }
        }
        return formatContext;
    }
    async handleAudioStream(stream, task) {
        const audioConfig = task.options.output.audio;
        if (audioConfig?.disable) {
            return;
        }
        else if (audioConfig?.codec === 'copy' && !(task.options.start || task.options.duration)) {
            const demuxer2MuxerChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_33__["default"])();
            await this.DemuxerThread.connectStreamTask
                .transfer(demuxer2MuxerChannel.port1)
                .invoke(task.taskId, stream.index, demuxer2MuxerChannel.port1);
            await this.MuxThread.addStream
                .transfer(demuxer2MuxerChannel.port2)
                .invoke(task.taskId, stream, demuxer2MuxerChannel.port2);
            task.streams.push({
                input: stream,
                demuxer2MuxerChannel
            });
        }
        else {
            const demuxer2DecoderChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_33__["default"])();
            const encoder2MuxerChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_33__["default"])();
            const decoder2FilterChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_33__["default"])();
            const filter2EncoderChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_33__["default"])();
            const newStream = this.copyAVStreamInterface(task, stream);
            const taskId = (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_42__["default"])();
            if (audioConfig) {
                if (audioConfig.codec) {
                    const codecId = avutil_stringEnum__WEBPACK_IMPORTED_MODULE_35__.AudioCodecString2CodecId[audioConfig.codec];
                    if (!common_util_is__WEBPACK_IMPORTED_MODULE_9__.number(codecId)) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`invalid codec name(${audioConfig.codec})`, cheap__fileName__12, 884);
                    }
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 4, codecId);
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4) !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar + 4)) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 48, avutil_constant__WEBPACK_IMPORTED_MODULE_18__.NOPTS_VALUE);
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 52, avutil_constant__WEBPACK_IMPORTED_MODULE_18__.NOPTS_VALUE);
                    }
                }
                if (audioConfig.bitrate) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[17](newStream.codecpar + 32, BigInt(Math.floor(audioConfig.bitrate)));
                }
                if (audioConfig.channels) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 116, audioConfig.channels);
                }
                if (audioConfig.sampleRate) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 136, audioConfig.sampleRate);
                }
                if (audioConfig.sampleFmt) {
                    const sampleFmt = avutil_stringEnum__WEBPACK_IMPORTED_MODULE_35__.SampleFmtString2SampleFormat[audioConfig.sampleFmt];
                    if (!common_util_is__WEBPACK_IMPORTED_MODULE_9__.number(sampleFmt)) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`invalid sampleFmt name(${audioConfig.sampleFmt})`, cheap__fileName__12, 905);
                    }
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 28, sampleFmt);
                }
                if (audioConfig.profile) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 48, audioConfig.profile);
                }
            }
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 48) === avutil_constant__WEBPACK_IMPORTED_MODULE_18__.NOPTS_VALUE) {
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4) === 86018 /* AVCodecID.AV_CODEC_ID_AAC */) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 48, 2 /* aac.MPEG4AudioObjectTypes.AAC_LC */);
                }
                else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4) === 86017 /* AVCodecID.AV_CODEC_ID_MP3 */) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 48, 34);
                }
            }
            await this.DemuxerThread.connectStreamTask
                .transfer(demuxer2DecoderChannel.port1)
                .invoke(task.taskId, stream.index, demuxer2DecoderChannel.port1);
            let decoderResource = await this.getResource('decoder', cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar));
            if (!decoderResource) {
                if (common_util_support__WEBPACK_IMPORTED_MODULE_29__["default"].audioDecoder) {
                    const isSupport = await AudioDecoder.isConfigSupported({
                        codec: (0,avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_44__["default"])(stream.codecpar),
                        sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar + 136),
                        numberOfChannels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar + 116)
                    });
                    if (!isSupport.supported) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`AudioDecoder codecId ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar + 4)} not support`, cheap__fileName__12, 936);
                    }
                }
                else {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`audio decoder codecId ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar + 4)} not support`, cheap__fileName__12, 940);
                }
            }
            // 注册一个音频解码任务
            await this.AudioDecoderThread.registerTask
                .transfer(demuxer2DecoderChannel.port2, decoder2FilterChannel.port1)
                .invoke({
                taskId: taskId,
                resource: decoderResource,
                leftPort: demuxer2DecoderChannel.port2,
                rightPort: decoder2FilterChannel.port1,
                stats: task.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
                avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
                avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 24,
                avframeList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 12,
                avframeListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 28,
                timeBase: {
                    num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.timeBase),
                    den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.timeBase + 4)
                }
            });
            await this.AudioDecoderThread.open(taskId, stream.codecpar);
            let resamplerResource = await this.getResource('resampler');
            if (!resamplerResource) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal('resampler not found', cheap__fileName__12, 967);
            }
            const vertices = [];
            const edges = [];
            let input;
            let output;
            const resampleNode = (0,_filter_graph__WEBPACK_IMPORTED_MODULE_45__.createGraphDesVertex)('resampler', {
                resource: resamplerResource,
                output: {
                    channels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 116),
                    sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 136),
                    format: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 28)
                }
            });
            vertices.push(resampleNode);
            input = {
                id: resampleNode.id,
                port: decoder2FilterChannel.port2
            };
            output = {
                id: resampleNode.id,
                port: filter2EncoderChannel.port1
            };
            if (task.options.start || task.options.duration) {
                const start = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__.avRescaleQ)(BigInt(Math.floor(task.options.start || 0)), avutil_constant__WEBPACK_IMPORTED_MODULE_18__.AV_MILLI_TIME_BASE_Q, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__["default"])(stream.timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational));
                const rangeNode = (0,_filter_graph__WEBPACK_IMPORTED_MODULE_45__.createGraphDesVertex)('range', {
                    start: start,
                    end: task.options.duration
                        ? ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__.avRescaleQ)(BigInt(Math.floor(task.options.duration)), avutil_constant__WEBPACK_IMPORTED_MODULE_18__.AV_MILLI_TIME_BASE_Q, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__["default"])(stream.timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational)) + start)
                        : -BigInt(1)
                });
                vertices.push(rangeNode);
                input = {
                    id: rangeNode.id,
                    port: decoder2FilterChannel.port2
                };
                edges.push({
                    parent: rangeNode.id,
                    child: resampleNode.id
                });
            }
            await this.AudioFilterThread.registerTask
                .transfer(decoder2FilterChannel.port2, filter2EncoderChannel.port1)
                .invoke({
                taskId: taskId,
                graph: {
                    vertices: vertices,
                    edges: edges
                },
                inputPorts: [input],
                outputPorts: [output],
                stats: task.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
                avframeList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 12,
                avframeListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 28,
            });
            let encoderResource = await this.getResource('encoder', cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar));
            if (!encoderResource) {
                if (common_util_support__WEBPACK_IMPORTED_MODULE_29__["default"].audioEncoder) {
                    const isSupport = await AudioEncoder.isConfigSupported({
                        codec: (0,avcodec_function_getAudioCodec__WEBPACK_IMPORTED_MODULE_46__["default"])(newStream.codecpar),
                        sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 136),
                        numberOfChannels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 116),
                        bitrate: (Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[17](newStream.codecpar + 32) & 0xffffffffn) >> 0),
                        bitrateMode: 'constant'
                    });
                    if (!isSupport.supported) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`AudioEncoder codecId ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4)} not support`, cheap__fileName__12, 1038);
                    }
                }
                else {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`audio encoder codecId ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4)} not support`, cheap__fileName__12, 1042);
                }
            }
            // 注册一个音频编码任务
            await this.AudioEncoderThread.registerTask
                .transfer(filter2EncoderChannel.port2, encoder2MuxerChannel.port1)
                .invoke({
                taskId: taskId,
                resource: encoderResource,
                leftPort: filter2EncoderChannel.port2,
                rightPort: encoder2MuxerChannel.port1,
                stats: task.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
                avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
                avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 24,
                avframeList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 12,
                avframeListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 28,
            });
            await this.AudioEncoderThread.open(taskId, newStream.codecpar, { num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.timeBase), den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.timeBase + 4) });
            await this.MuxThread.addStream
                .transfer(encoder2MuxerChannel.port2)
                .invoke(task.taskId, newStream, encoder2MuxerChannel.port2);
            task.streams.push({
                taskId,
                input: stream,
                output: newStream,
                demuxer2DecoderChannel,
                decoder2FilterChannel,
                filter2EncoderChannel,
                encoder2MuxerChannel
            });
        }
    }
    async handleVideoStream(stream, task) {
        const videoConfig = task.options.output.video;
        if (videoConfig?.disable) {
            return;
        }
        else if (videoConfig?.codec === 'copy' && !(task.options.start || task.options.duration)) {
            const demuxer2MuxerChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_33__["default"])();
            await this.DemuxerThread.connectStreamTask
                .transfer(demuxer2MuxerChannel.port1)
                .invoke(task.subTaskId || task.taskId, stream.index, demuxer2MuxerChannel.port1);
            await this.MuxThread.addStream
                .transfer(demuxer2MuxerChannel.port2)
                .invoke(task.taskId, stream, demuxer2MuxerChannel.port2);
            task.streams.push({
                input: stream,
                demuxer2MuxerChannel
            });
        }
        else {
            const demuxer2DecoderChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_33__["default"])();
            const encoder2MuxerChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_33__["default"])();
            const decoder2FilterChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_33__["default"])();
            const filter2EncoderChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_33__["default"])();
            const newStream = this.copyAVStreamInterface(task, stream);
            const taskId = (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_42__["default"])();
            if (videoConfig) {
                if (videoConfig.codec) {
                    const codecId = avutil_stringEnum__WEBPACK_IMPORTED_MODULE_35__.VideoCodecString2CodecId[videoConfig.codec];
                    if (!common_util_is__WEBPACK_IMPORTED_MODULE_9__.number(codecId)) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`invalid codec name(${videoConfig.codec})`, cheap__fileName__12, 1113);
                    }
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 4, codecId);
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4) !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar + 4)) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 48, avutil_constant__WEBPACK_IMPORTED_MODULE_18__.NOPTS_VALUE);
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 52, avutil_constant__WEBPACK_IMPORTED_MODULE_18__.NOPTS_VALUE);
                    }
                }
                if (videoConfig.width) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 56, videoConfig.width);
                }
                if (videoConfig.height) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 60, videoConfig.height);
                }
                if (videoConfig.bitrate) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[17](newStream.codecpar + 32, BigInt(Math.floor(videoConfig.bitrate)));
                }
                if (videoConfig.pixfmt) {
                    const pixfmt = avutil_stringEnum__WEBPACK_IMPORTED_MODULE_35__.PixfmtString2AVPixelFormat[videoConfig.pixfmt];
                    if (!common_util_is__WEBPACK_IMPORTED_MODULE_9__.number(pixfmt)) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`invalid pixfmt name(${videoConfig.pixfmt})`, cheap__fileName__12, 1134);
                    }
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 28, pixfmt);
                }
                if (videoConfig.framerate) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 72, videoConfig.framerate >>> 0);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 76, 1);
                }
                if (videoConfig.aspect) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 68, videoConfig.aspect.den);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 64, videoConfig.aspect.num);
                }
                if (videoConfig.profile) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 48, videoConfig.profile);
                }
                if (videoConfig.level) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 52, videoConfig.level);
                }
                if (videoConfig.delay) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 104, videoConfig.delay);
                }
            }
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 48) === avutil_constant__WEBPACK_IMPORTED_MODULE_18__.NOPTS_VALUE) {
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4) === 27 /* AVCodecID.AV_CODEC_ID_H264 */) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 48, 100 /* h264.H264Profile.kHigh */);
                }
                else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 48, 1 /* hevc.HEVCProfile.Main */);
                }
                else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */) {
                }
                else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4) === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 48, 0 /* av1.AV1Profile.Main */);
                }
                else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4) === 167 /* AVCodecID.AV_CODEC_ID_VP9 */) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 48, 0 /* vp9.VP9Profile.Profile0 */);
                }
            }
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 52) === avutil_constant__WEBPACK_IMPORTED_MODULE_18__.NOPTS_VALUE) {
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4) === 27 /* AVCodecID.AV_CODEC_ID_H264 */) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 52, avformat_codecs_h264__WEBPACK_IMPORTED_MODULE_47__.getLevelByResolution(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 56), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 60), (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__["default"])(newStream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational))));
                }
                else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 52, avformat_codecs_hevc__WEBPACK_IMPORTED_MODULE_48__.getLevelByResolution(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 48), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 56), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 60), (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__["default"])(newStream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational)), Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[17](newStream.codecpar + 32))));
                }
                else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */) {
                }
                else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4) === 225 /* AVCodecID.AV_CODEC_ID_AV1 */) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 52, avformat_codecs_av1__WEBPACK_IMPORTED_MODULE_49__.getLevelByResolution(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 56), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 60), (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__["default"])(newStream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational))));
                }
                else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4) === 167 /* AVCodecID.AV_CODEC_ID_VP9 */) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 52, avformat_codecs_vp9__WEBPACK_IMPORTED_MODULE_50__.getLevelByResolution(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 56), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 60), (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__["default"])(newStream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational))));
                }
            }
            if (!videoConfig || videoConfig.delay == null) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 104, 4);
            }
            if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4) === 27 /* AVCodecID.AV_CODEC_ID_H264 */
                || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4) === 173 /* AVCodecID.AV_CODEC_ID_HEVC */
                || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4) === 196 /* AVCodecID.AV_CODEC_ID_VVC */) {
                if (task.format === 2 /* AVFormat.MPEGTS */) {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 160, 2 /* BitFormat.ANNEXB */);
                }
                else {
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](newStream.codecpar + 160, 1 /* BitFormat.AVCC */);
                }
            }
            await this.DemuxerThread.connectStreamTask
                .transfer(demuxer2DecoderChannel.port1)
                .invoke(task.subTaskId || task.taskId, stream.index, demuxer2DecoderChannel.port1);
            let decoderResource = await this.getResource('decoder', cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar));
            if (!decoderResource) {
                if (common_util_support__WEBPACK_IMPORTED_MODULE_29__["default"].videoDecoder) {
                    const isSupport = await VideoDecoder.isConfigSupported({
                        codec: (0,avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_44__["default"])(stream.codecpar)
                    });
                    if (!isSupport.supported) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`VideoDecoder codecId ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar + 4)} not support`, cheap__fileName__12, 1225);
                    }
                }
                else {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`video decoder codecId ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.codecpar + 4)} not support`, cheap__fileName__12, 1229);
                }
            }
            // 注册一个视频解码任务
            await this.VideoDecoderThread.registerTask
                .transfer(demuxer2DecoderChannel.port2, decoder2FilterChannel.port1)
                .invoke({
                taskId: taskId,
                resource: decoderResource,
                leftPort: demuxer2DecoderChannel.port2,
                rightPort: decoder2FilterChannel.port1,
                stats: task.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
                enableHardware: this.options.enableHardware,
                avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
                avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 24,
                avframeList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 12,
                avframeListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 28
            });
            await this.VideoDecoderThread.open(taskId, stream.codecpar);
            let scalerResource = await this.getResource('scaler');
            if (!scalerResource) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal('scaler not found', cheap__fileName__12, 1252);
            }
            const vertices = [];
            const edges = [];
            let input;
            let output;
            let rangeNodeId;
            const scaleNode = (0,_filter_graph__WEBPACK_IMPORTED_MODULE_45__.createGraphDesVertex)('scaler', {
                resource: scalerResource,
                output: {
                    width: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 56),
                    height: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 60),
                    format: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 28)
                }
            });
            vertices.push(scaleNode);
            input = {
                id: scaleNode.id,
                port: decoder2FilterChannel.port2
            };
            output = {
                id: scaleNode.id,
                port: filter2EncoderChannel.port1
            };
            if (task.options.start || task.options.duration) {
                const start = (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__.avRescaleQ)(BigInt(Math.floor(task.options.start || 0)), avutil_constant__WEBPACK_IMPORTED_MODULE_18__.AV_MILLI_TIME_BASE_Q, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__["default"])(stream.timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational));
                const rangeNode = (0,_filter_graph__WEBPACK_IMPORTED_MODULE_45__.createGraphDesVertex)('range', {
                    start: start,
                    end: task.options.duration
                        ? ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__.avRescaleQ)(BigInt(Math.floor(task.options.duration)), avutil_constant__WEBPACK_IMPORTED_MODULE_18__.AV_MILLI_TIME_BASE_Q, (0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__["default"])(stream.timeBase, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational)) + start)
                        : -BigInt(1)
                });
                vertices.push(rangeNode);
                input = {
                    id: rangeNode.id,
                    port: decoder2FilterChannel.port2
                };
                edges.push({
                    parent: rangeNode.id,
                    child: scaleNode.id
                });
                rangeNodeId = rangeNode.id;
            }
            if ((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__["default"])(stream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational)) > (0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__["default"])(newStream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational))) {
                const framerateNode = (0,_filter_graph__WEBPACK_IMPORTED_MODULE_45__.createGraphDesVertex)('framerate', {
                    framerate: {
                        num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 72),
                        den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 76)
                    },
                    timeBase: {
                        num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.timeBase),
                        den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](stream.timeBase + 4)
                    }
                });
                vertices.push(framerateNode);
                edges.length = 0;
                if (rangeNodeId) {
                    edges.push({
                        parent: rangeNodeId,
                        child: framerateNode.id
                    });
                    edges.push({
                        parent: framerateNode.id,
                        child: scaleNode.id
                    });
                }
                else {
                    input = {
                        id: framerateNode.id,
                        port: decoder2FilterChannel.port2
                    };
                    edges.push({
                        parent: framerateNode.id,
                        child: scaleNode.id
                    });
                }
            }
            await this.VideoFilterThread.registerTask
                .transfer(decoder2FilterChannel.port2, filter2EncoderChannel.port1)
                .invoke({
                taskId: taskId,
                graph: {
                    vertices,
                    edges
                },
                inputPorts: [input],
                outputPorts: [output],
                stats: task.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
                avframeList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 12,
                avframeListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 28,
            });
            let encoderResource = await this.getResource('encoder', cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar));
            if (!encoderResource) {
                if (common_util_support__WEBPACK_IMPORTED_MODULE_29__["default"].videoEncoder) {
                    const isSupport = await VideoEncoder.isConfigSupported({
                        codec: (0,avcodec_function_getVideoCodec__WEBPACK_IMPORTED_MODULE_44__["default"])(newStream.codecpar),
                        width: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 56),
                        height: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 60)
                    });
                    if (!isSupport.supported) {
                        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`VideoEncoder codecId ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4)} not support`, cheap__fileName__12, 1361);
                    }
                }
                else {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`video encoder codecId ${cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.codecpar + 4)} not support`, cheap__fileName__12, 1365);
                }
            }
            // 注册一个视频编码任务
            await this.VideoEncoderThread.registerTask
                .transfer(filter2EncoderChannel.port2, encoder2MuxerChannel.port1)
                .invoke({
                taskId: taskId,
                resource: encoderResource,
                leftPort: filter2EncoderChannel.port2,
                rightPort: encoder2MuxerChannel.port1,
                stats: task.stats[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
                enableHardware: this.options.enableHardware,
                avpacketList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress],
                avpacketListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 24,
                avframeList: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 12,
                avframeListMutex: this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 28,
                gop: (((0,avutil_util_rational__WEBPACK_IMPORTED_MODULE_15__.avQ2D)((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__["default"])(newStream.codecpar + 72, _avutil_struct_rational_ts__WEBPACK_IMPORTED_MODULE_17__.Rational)) * (videoConfig?.keyFrameInterval ?? 5000) / 1000) >> 0)
            });
            await this.VideoEncoderThread.open(taskId, newStream.codecpar, { num: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.timeBase), den: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](newStream.timeBase + 4) });
            await this.MuxThread.addStream.transfer(encoder2MuxerChannel.port2)
                .invoke(task.taskId, newStream, encoder2MuxerChannel.port2);
            task.streams.push({
                taskId,
                input: stream,
                output: newStream,
                demuxer2DecoderChannel,
                decoder2FilterChannel,
                filter2EncoderChannel,
                encoder2MuxerChannel
            });
        }
    }
    async handleCopyStream(stream, task) {
        const demuxer2MuxerChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_33__["default"])();
        await this.DemuxerThread.connectStreamTask
            .transfer(demuxer2MuxerChannel.port1)
            .invoke(task.subTaskId || task.taskId, stream.index, demuxer2MuxerChannel.port1);
        await this.MuxThread.addStream
            .transfer(demuxer2MuxerChannel.port2)
            .invoke(task.taskId, stream, demuxer2MuxerChannel.port2);
        task.streams.push({
            input: stream,
            demuxer2MuxerChannel
        });
    }
    async clearTask(task) {
        this.MuxThread.unregisterTask(task.taskId);
        for (let i = 0; i < task.streams.length; i++) {
            if (task.streams[i].taskId) {
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](task.streams[i].input.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                    await this.AudioEncoderThread.unregisterTask(task.streams[i].taskId);
                    await this.AudioFilterThread.unregisterTask(task.streams[i].taskId);
                    await this.AudioDecoderThread.unregisterTask(task.streams[i].taskId);
                }
                else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](task.streams[i].input.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                    await this.VideoEncoderThread.unregisterTask(task.streams[i].taskId);
                    await this.VideoFilterThread.unregisterTask(task.streams[i].taskId);
                    await this.VideoDecoderThread.unregisterTask(task.streams[i].taskId);
                }
            }
            if (task.streams[i].output) {
                (0,avutil_util_codecparameters__WEBPACK_IMPORTED_MODULE_31__.freeCodecParameters)(task.streams[i].output.codecpar);
                (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_30__.avFree)(task.streams[i].output.timeBase);
            }
        }
        this.DemuxerThread.unregisterTask(task.taskId);
        if (task.subTaskId) {
            this.DemuxerThread.unregisterTask(task.subTaskId);
        }
        this.IOThread.unregisterTask(task.taskId);
        if (task.inputIPCPort) {
            task.inputIPCPort.destroy();
        }
        if (task.outputIPCPort) {
            task.outputIPCPort.destroy();
        }
        if (task.safeFileIO) {
            task.safeFileIO.destroy();
        }
        if (task.stats) {
            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_51__["default"])(task.stats);
        }
        this.tasks.delete(task.taskId);
        if (!this.tasks.size) {
            this.reportTimer.stop();
        }
    }
    async addTask(taskOptions) {
        if (taskOptions.output.audio?.disable && taskOptions.output.video?.disable) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal('audio and video are all disable', cheap__fileName__12, 1467);
        }
        const taskId = (0,common_function_generateUUID__WEBPACK_IMPORTED_MODULE_42__["default"])();
        const stats = (0,cheap_std_make__WEBPACK_IMPORTED_MODULE_7__["default"])(avpipeline_struct_stats__WEBPACK_IMPORTED_MODULE_52__["default"]);
        const task = {
            taskId,
            startTime: 0,
            options: taskOptions,
            ioloader2DemuxerChannel: null,
            muxer2OutputChannel: null,
            stats,
            format: -1 /* AVFormat.UNKNOWN */,
            streams: [],
            formatContext: null,
            controller: new _Controller__WEBPACK_IMPORTED_MODULE_53__["default"](this)
        };
        try {
            await this.setTaskInput(task);
            await this.setTaskOutput(task);
            const formatContext = task.formatContext = await this.analyzeInputStreams(task);
            for (let i = 0; i < formatContext.streams.length; i++) {
                const mediaType = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](formatContext.streams[i].codecpar);
                if (mediaType === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                    await this.handleAudioStream(formatContext.streams[i], task);
                }
                else if (mediaType === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                    await this.handleVideoStream(formatContext.streams[i], task);
                }
                else {
                    await this.handleCopyStream(formatContext.streams[i], task);
                }
            }
            const oformatContext = {
                streams: [],
                format: task.format,
                metadata: {}
            };
            let mappingDump = '\nStream mapping:\n';
            task.streams.forEach((stream) => {
                if (stream.output) {
                    oformatContext.streams.push(stream.output);
                    mappingDump += `  Stream #0:${stream.input.index} -> #0:${stream.output.index} (${(0,avformat_dump__WEBPACK_IMPORTED_MODULE_43__.dumpCodecName)(stream.input)} -> ${(0,avformat_dump__WEBPACK_IMPORTED_MODULE_43__.dumpCodecName)(stream.output)})\n`;
                }
                else {
                    oformatContext.streams.push(stream.input);
                    mappingDump += `  Stream #0:${stream.input.index} -> #0:${stream.output.index} (${(0,avformat_dump__WEBPACK_IMPORTED_MODULE_43__.dumpCodecName)(stream.input)} -> copy)\n`;
                }
            });
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.info(mappingDump, cheap__fileName__12, 1520);
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.info('\n' + (0,avformat_dump__WEBPACK_IMPORTED_MODULE_43__["default"])([oformatContext], [{
                    from: task.options.output.file instanceof FileSystemFileHandle ? task.options.output.file.name : 'IOWriter',
                    tag: 'Output'
                }]), cheap__fileName__12, 1521);
            this.tasks.set(taskId, task);
            return taskId;
        }
        catch (error) {
            await this.clearTask(task);
            throw error;
        }
    }
    async startTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            if (task.options.start) {
                await this.DemuxerThread.seek(task.taskId, BigInt(Math.floor(task.options.start)), 16 /* AVSeekFlags.TIMESTAMP */);
            }
            await this.DemuxerThread.startDemux(taskId, false, 10);
            await this.MuxThread.open(taskId);
            const streams = task.streams;
            for (let i = 0; i < streams.length; i++) {
                if (!streams[i].output) {
                    continue;
                }
                let buffer;
                let updated = false;
                if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](streams[i].output.codecpar) === 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */) {
                    buffer = await this.AudioEncoderThread.getExtraData(streams[i].taskId);
                }
                else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](streams[i].output.codecpar) === 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */) {
                    buffer = await this.VideoEncoderThread.getExtraData(streams[i].taskId);
                    const colorSpace = await this.VideoEncoderThread.getColorSpace(streams[i].taskId);
                    if (colorSpace) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](streams[i].output.codecpar + 96, colorSpace.colorSpace);
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](streams[i].output.codecpar + 88, colorSpace.colorPrimaries);
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](streams[i].output.codecpar + 92, colorSpace.colorTrc);
                        updated = true;
                    }
                }
                if (!buffer) {
                    const codecId = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_14__.CTypeEnumRead[15](streams[i].output.codecpar + 4);
                    if (codecId === 86018 /* AVCodecID.AV_CODEC_ID_AAC */) {
                        buffer = avformat_codecs_aac__WEBPACK_IMPORTED_MODULE_54__.avCodecParameters2Extradata((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__["default"])(streams[i].output.codecpar, _avutil_struct_avcodecparameters_ts__WEBPACK_IMPORTED_MODULE_55__["default"]));
                    }
                    else if (codecId === 86076 /* AVCodecID.AV_CODEC_ID_OPUS */) {
                        buffer = avformat_codecs_opus__WEBPACK_IMPORTED_MODULE_56__.avCodecParameters2Extradata((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_16__["default"])(streams[i].output.codecpar, _avutil_struct_avcodecparameters_ts__WEBPACK_IMPORTED_MODULE_55__["default"]));
                    }
                }
                if (buffer) {
                    const extradata = (0,avutil_util_mem__WEBPACK_IMPORTED_MODULE_30__.avMalloc)(buffer.length);
                    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_37__.memcpyFromUint8Array)(extradata, buffer.length, buffer);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[20](streams[i].output.codecpar + 12, extradata);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_32__.CTypeEnumWrite[15](streams[i].output.codecpar + 16, buffer.length);
                    updated = true;
                }
                if (updated) {
                    await this.MuxThread.updateAVCodecParameters(task.taskId, streams[i].output.index, streams[i].output.codecpar);
                }
            }
            await this.MuxThread.start(taskId);
            task.startTime = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_13__["default"])();
            if (!this.reportTimer.isStarted()) {
                this.reportTimer.start();
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`task ${taskId} not found`, cheap__fileName__12, 1593);
        }
    }
    async pauseTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            await this.MuxThread.pause(taskId);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`task ${taskId} not found`, cheap__fileName__12, 1603);
        }
    }
    async unpauseTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            await this.MuxThread.unpause(taskId);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`task ${taskId} not found`, cheap__fileName__12, 1613);
        }
    }
    async cancelTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            await this.MuxThread.unpause(taskId);
            await this.clearTask(task);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_5__.fatal(`task ${taskId} not found`, cheap__fileName__12, 1624);
        }
    }
    async destroy() {
        if (this.MuxThread) {
            await this.MuxThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_20__.closeThread)(this.MuxThread);
        }
        if (this.AudioEncoderThread) {
            await this.AudioEncoderThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_20__.closeThread)(this.AudioEncoderThread);
        }
        if (this.AudioFilterThread) {
            await this.AudioFilterThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_20__.closeThread)(this.AudioFilterThread);
        }
        if (this.AudioDecoderThread) {
            await this.AudioDecoderThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_20__.closeThread)(this.AudioDecoderThread);
        }
        if (this.VideoEncoderThread) {
            await this.VideoEncoderThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_20__.closeThread)(this.VideoEncoderThread);
        }
        if (this.VideoFilterThread) {
            await this.VideoFilterThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_20__.closeThread)(this.VideoFilterThread);
        }
        if (this.VideoDecoderThread) {
            await this.VideoDecoderThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_20__.closeThread)(this.VideoDecoderThread);
        }
        if (this.DemuxerThread) {
            await this.DemuxerThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_20__.closeThread)(this.DemuxerThread);
        }
        if (this.IOThread) {
            await this.IOThread.clear();
            (0,cheap_thread_thread__WEBPACK_IMPORTED_MODULE_20__.closeThread)(this.IOThread);
        }
        this.VideoEncoderThread = null;
        this.VideoFilterThread = null;
        this.VideoDecoderThread = null;
        this.AudioEncoderThread = null;
        this.AudioFilterThread = null;
        this.AudioDecoderThread = null;
        this.DemuxerThread = null;
        this.IOThread = null;
        this.MuxThread = null;
        if (this.GlobalData) {
            this.GlobalData.avframeList.clear((avframe) => {
                (0,avutil_util_avframe__WEBPACK_IMPORTED_MODULE_57__.unrefAVFrame)(avframe);
            }, 20);
            this.GlobalData.avpacketList.clear((avpacket) => {
                (0,avutil_util_avpacket__WEBPACK_IMPORTED_MODULE_58__.unrefAVPacket)(avpacket);
            }, 20);
            _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_1__.destroy(this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 24);
            _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_1__.destroy(this.GlobalData[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] + 28);
            (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_51__["default"])(this.GlobalData);
            this.GlobalData = null;
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.info('AVTranscoder pipelines stopped', cheap__fileName__12, 1691);
    }
    setLogLevel(level) {
        this.level = level;
        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.setLevel(level);
        if (this.IOThread) {
            this.IOThread.setLogLevel(level);
        }
        if (this.DemuxerThread) {
            this.DemuxerThread.setLogLevel(level);
        }
        if (this.AudioDecoderThread) {
            this.AudioDecoderThread.setLogLevel(level);
        }
        if (this.AudioFilterThread) {
            this.AudioFilterThread.setLogLevel(level);
        }
        if (this.AudioEncoderThread) {
            this.AudioEncoderThread.setLogLevel(level);
        }
        if (this.VideoDecoderThread) {
            this.VideoDecoderThread.setLogLevel(level);
        }
        if (this.VideoFilterThread) {
            this.VideoFilterThread.setLogLevel(level);
        }
        if (this.VideoEncoderThread) {
            this.VideoEncoderThread.setLogLevel(level);
        }
        if (this.MuxThread) {
            this.MuxThread.setLogLevel(level);
        }
        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.info(`set log level: ${level}`, cheap__fileName__12, 1727);
    }
    async onGetDecoderResource(mediaType, codecId) {
        return this.getResource('decoder', codecId, mediaType);
    }
}


/***/ }),

/***/ "./src/avtranscoder/Controller.ts":
/*!****************************************!*\
  !*** ./src/avtranscoder/Controller.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Controller)
/* harmony export */ });
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avutil/function/createMessageChannel */ "./src/avutil/function/createMessageChannel.ts");
/*
 * libmedia AVTranscoder Controller
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


class Controller {
    demuxerControlChannel;
    demuxerControlIPCPort;
    observer;
    constructor(observer) {
        this.observer = observer;
        this.demuxerControlChannel = (0,avutil_function_createMessageChannel__WEBPACK_IMPORTED_MODULE_0__["default"])();
        this.demuxerControlIPCPort = new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](this.demuxerControlChannel.port2);
        this.demuxerControlIPCPort.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__.REQUEST, async (request) => {
            switch (request.method) {
                case 'getDecoderResource':
                    this.demuxerControlIPCPort.reply(request, await this.observer.onGetDecoderResource(request.params.mediaType, request.params.codecId));
                    break;
            }
        });
    }
    getDemuxerRenderControlPort() {
        return this.demuxerControlChannel.port1;
    }
    destroy() {
        if (this.demuxerControlIPCPort) {
            this.demuxerControlIPCPort.destroy();
        }
        this.demuxerControlChannel = null;
    }
}


/***/ }),

/***/ "./src/avtranscoder/eventType.ts":
/*!***************************************!*\
  !*** ./src/avtranscoder/eventType.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TASK_ENDED: () => (/* binding */ TASK_ENDED)
/* harmony export */ });
const TASK_ENDED = 'task-ended';


/***/ }),

/***/ "./src/avtranscoder/filter/AVFilterPipeline.ts":
/*!*****************************************************!*\
  !*** ./src/avtranscoder/filter/AVFilterPipeline.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVFilterPipeline)
/* harmony export */ });
/* harmony import */ var _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../cheap/std/collection/List.ts */ "./src/cheap/std/collection/List.ts");
/* harmony import */ var cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/structAccess */ "./src/cheap/std/structAccess.ts");
/* harmony import */ var avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avutil/implement/AVFramePoolImpl */ "./src/avutil/implement/AVFramePoolImpl.ts");
/* harmony import */ var avutil_error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! avutil/error */ "./src/avutil/error.ts");
/* harmony import */ var avpipeline_Pipeline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avpipeline/Pipeline */ "./src/avpipeline/Pipeline.ts");
/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./graph */ "./src/avtranscoder/filter/graph.ts");
/* harmony import */ var avfilter_AVFilterNode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! avfilter/AVFilterNode */ "./src/avfilter/AVFilterNode.ts");







class AVFilterPipeline extends avpipeline_Pipeline__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
    }
    async createTask(options) {
        const avframePool = new avutil_implement_AVFramePoolImpl__WEBPACK_IMPORTED_MODULE_1__["default"]((0,cheap_std_structAccess__WEBPACK_IMPORTED_MODULE_2__["default"])(options.avframeList, _cheap_std_collection_List_ts__WEBPACK_IMPORTED_MODULE_3__["default"]), options.avframeListMutex);
        const filterGraph = (0,_graph__WEBPACK_IMPORTED_MODULE_4__.createFilterGraph)(options.graph, avframePool);
        if (!(0,_graph__WEBPACK_IMPORTED_MODULE_4__.checkFilterGraphInvalid)(filterGraph, options.inputPorts, options.outputPorts)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_5__.INVALID_OPERATE;
        }
        const filterPorts = [];
        for (let i = 0; i < options.inputPorts.length; i++) {
            const port = new avfilter_AVFilterNode__WEBPACK_IMPORTED_MODULE_6__.AVFilterNodePort(options.inputPorts[i].port);
            filterPorts.push(port);
            const next = filterGraph.inputs.find((vertex) => {
                return vertex.id === options.inputPorts[i].id;
            });
            const { port: nextPort, index } = next.filter.getFreeInputNodePort();
            port.connect(nextPort);
            next.filter.addInputPeer(this, index);
        }
        for (let i = 0; i < options.outputPorts.length; i++) {
            const port = new avfilter_AVFilterNode__WEBPACK_IMPORTED_MODULE_6__.AVFilterNodePort(options.outputPorts[i].port);
            filterPorts.push(port);
            const prev = filterGraph.outputs.find((vertex) => {
                return vertex.id === options.outputPorts[i].id;
            });
            const { port: prevPort, index } = prev.filter.getFreeOutputNodePort();
            prevPort.connect(port);
            prev.filter.addOutputPeer(this, index);
        }
        for (let i = 0; i < filterGraph.vertices.length; i++) {
            await filterGraph.vertices[i].filter.ready();
        }
        this.tasks.set(options.taskId, {
            ...options,
            filterGraph,
            filterPorts,
            avframePool
        });
        return 0;
    }
    async registerTask(options) {
        if (this.tasks.has(options.taskId)) {
            return avutil_error__WEBPACK_IMPORTED_MODULE_5__.INVALID_OPERATE;
        }
        return this.createTask(options);
    }
    async unregisterTask(taskId) {
        const task = this.tasks.get(taskId);
        if (task) {
            for (let i = 0; i < task.filterGraph.vertices.length; i++) {
                task.filterGraph.vertices[i].filter.disconnect();
                await task.filterGraph.vertices[i].filter.destroy();
            }
            this.tasks.delete(taskId);
        }
    }
}


/***/ }),

/***/ "./src/avtranscoder/filter/graph.ts":
/*!******************************************!*\
  !*** ./src/avtranscoder/filter/graph.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   checkFilterGraphInvalid: () => (/* binding */ checkFilterGraphInvalid),
/* harmony export */   createFilterGraph: () => (/* binding */ createFilterGraph),
/* harmony export */   createGraphDesVertex: () => (/* binding */ createGraphDesVertex)
/* harmony export */ });
/* harmony import */ var avfilter_RangeFilterNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! avfilter/RangeFilterNode */ "./src/avfilter/RangeFilterNode.ts");
/* harmony import */ var avfilter_audio_ResampleFilterNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! avfilter/audio/ResampleFilterNode */ "./src/avfilter/audio/ResampleFilterNode.ts");
/* harmony import */ var avfilter_video_FramerateFilterNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! avfilter/video/FramerateFilterNode */ "./src/avfilter/video/FramerateFilterNode.ts");
/* harmony import */ var avfilter_video_ScaleFilterNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! avfilter/video/ScaleFilterNode */ "./src/avfilter/video/ScaleFilterNode.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/avtranscoder/filter/graph.ts";





function createFilter(vertex, avframePool) {
    const options = vertex.options;
    if (avframePool) {
        options.avframePool = avframePool;
    }
    switch (vertex.type) {
        case 'resampler':
            return new avfilter_audio_ResampleFilterNode__WEBPACK_IMPORTED_MODULE_0__["default"](options);
        case 'scaler':
            return new avfilter_video_ScaleFilterNode__WEBPACK_IMPORTED_MODULE_1__["default"](options);
        case 'range':
            return new avfilter_RangeFilterNode__WEBPACK_IMPORTED_MODULE_2__["default"](options);
        case 'framerate':
            return new avfilter_video_FramerateFilterNode__WEBPACK_IMPORTED_MODULE_3__["default"](options);
        default:
            throw new Error(`invalid GraphNodeType, ${vertex.type}`);
    }
}
let id = 0;
function createGraphDesVertex(type, options) {
    return {
        id: id++,
        type,
        options
    };
}
function createFilterGraph(des, avframePool) {
    const vertices = [];
    const inputs = [];
    const outputs = [];
    const map = new Map();
    const hasChildMap = new Map();
    const hasParentMap = new Map();
    des.vertices.forEach((vertex) => {
        const node = {
            id: vertex.id,
            filter: createFilter(vertex, avframePool),
            children: [],
            parents: []
        };
        map.set(node.id, node);
        vertices.push(node);
    });
    des.edges.forEach((edge, index) => {
        const parent = map.get(edge.parent);
        const child = map.get(edge.child);
        if (!parent) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal(`${index} edge parent(${edge.parent}) not found`, cheap__fileName__0, 125);
        }
        if (!child) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_4__.fatal(`${index} edge child(${edge.child}) not found`, cheap__fileName__0, 128);
        }
        parent.children.push(child);
        child.parents.push(parent);
        hasChildMap.set(parent.id, true);
        hasParentMap.set(child.id, true);
        parent.filter.connect(child.filter);
    });
    des.vertices.forEach((vertex) => {
        if (!hasParentMap.has(vertex.id)) {
            inputs.push(map.get(vertex.id));
        }
        if (!hasChildMap.has(vertex.id)) {
            outputs.push(map.get(vertex.id));
        }
    });
    return {
        vertices,
        edges: des.edges,
        inputs,
        outputs
    };
}
function checkFilterGraphInvalid(graph, inputs, output) {
    const inputsMap = new Map();
    const outputsMap = new Map();
    for (let i = 0; i < inputs.length; i++) {
        if (inputsMap.has(inputs[i].id)) {
            inputsMap.set(inputs[i].id, inputsMap.get(inputs[i].id) + 1);
        }
        else {
            inputsMap.set(inputs[i].id, 1);
        }
    }
    for (let i = 0; i < output.length; i++) {
        if (outputsMap.has(output[i].id)) {
            outputsMap.set(output[i].id, outputsMap.get(output[i].id) + 1);
        }
        else {
            outputsMap.set(output[i].id, 1);
        }
    }
    for (let i = 0; i < graph.inputs.length; i++) {
        if (graph.inputs[i].filter.getInputCount() > (inputsMap.get(graph.inputs[i].id) ?? 0)) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_4__.error(`input filter(${graph.inputs[i].id}) only has ${inputsMap.get(graph.inputs[i].id)} input channel port`, cheap__fileName__0, 178);
            return false;
        }
    }
    for (let i = 0; i < graph.outputs.length; i++) {
        if (graph.outputs[i].filter.getOutputCount() > (outputsMap.get(graph.outputs[i].id) ?? 0)) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_4__.error(`output filter(${graph.outputs[i].id}) only has ${outputsMap.get(graph.outputs[i].id)} output channel port`, cheap__fileName__0, 185);
            return false;
        }
    }
    for (let i = 0; i < graph.vertices.length; i++) {
        if (graph.vertices[i].children.length && graph.vertices[i].parents.length) {
            if (graph.vertices[i].filter.getOutputCount() !== graph.vertices[i].children.length) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_4__.error(`filter(${graph.vertices[i].id}) only has ${graph.vertices[i].children.length} output channel port`, cheap__fileName__0, 193);
                return false;
            }
            if (graph.vertices[i].filter.getInputCount() !== graph.vertices[i].parents.length) {
                common_util_logger__WEBPACK_IMPORTED_MODULE_4__.error(`filter(${graph.vertices[i].id}) only has ${graph.vertices[i].parents.length} input channel port`, cheap__fileName__0, 197);
                return false;
            }
        }
    }
    return true;
}


/***/ }),

/***/ "./src/avutil/constant.ts":
/*!********************************!*\
  !*** ./src/avutil/constant.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AV_MILLI_TIME_BASE_Q: () => (/* binding */ AV_MILLI_TIME_BASE_Q),
/* harmony export */   AV_TIME_BASE: () => (/* binding */ AV_TIME_BASE),
/* harmony export */   AV_TIME_BASE_Q: () => (/* binding */ AV_TIME_BASE_Q),
/* harmony export */   INT32_MAX: () => (/* binding */ INT32_MAX),
/* harmony export */   NOPTS_VALUE: () => (/* binding */ NOPTS_VALUE),
/* harmony export */   NOPTS_VALUE_BIGINT: () => (/* binding */ NOPTS_VALUE_BIGINT),
/* harmony export */   UINT16_MAX: () => (/* binding */ UINT16_MAX),
/* harmony export */   UINT32_MAX: () => (/* binding */ UINT32_MAX)
/* harmony export */ });
/* unused harmony exports AV_MILLI_TIME_BASE, AV_TIME_BASE1_Q, INT8_MAX, INT16_MAX, INT8_MIN, INT16_MIN, INT32_MIN, UINT8_MAX */
/* harmony import */ var _struct_rational__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./struct/rational */ "./src/avutil/struct/rational.ts");
/*
 * libmedia constant
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

const NOPTS_VALUE_BIGINT = -BigInt(1);
const NOPTS_VALUE = -1;
const AV_TIME_BASE = 1000000;
const AV_MILLI_TIME_BASE = 1000;
/**
 * 微秒时间基
 */
const AV_TIME_BASE_Q = new _struct_rational__WEBPACK_IMPORTED_MODULE_0__.Rational({ den: AV_TIME_BASE, num: 1 });
/**
 * 毫秒时间基
 */
const AV_MILLI_TIME_BASE_Q = new _struct_rational__WEBPACK_IMPORTED_MODULE_0__.Rational({ den: AV_MILLI_TIME_BASE, num: 1 });
/**
 * 秒时间基
 */
const AV_TIME_BASE1_Q = new _struct_rational__WEBPACK_IMPORTED_MODULE_0__.Rational({ den: 1, num: 1 });
const INT8_MAX = 127;
const INT16_MAX = 32767;
const INT32_MAX = 2147483647;
const INT8_MIN = -128;
const INT16_MIN = -32768;
const INT32_MIN = -INT32_MAX - 1;
const UINT8_MAX = 255;
const UINT16_MAX = 65535;
const UINT32_MAX = 4294967295;


/***/ }),

/***/ "./src/avutil/error.ts":
/*!*****************************!*\
  !*** ./src/avutil/error.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DATA_INVALID: () => (/* binding */ DATA_INVALID),
/* harmony export */   EOF: () => (/* binding */ EOF),
/* harmony export */   FORMAT_NOT_SUPPORT: () => (/* binding */ FORMAT_NOT_SUPPORT),
/* harmony export */   INVALID_ARGUMENT: () => (/* binding */ INVALID_ARGUMENT),
/* harmony export */   INVALID_OPERATE: () => (/* binding */ INVALID_OPERATE),
/* harmony export */   NO_MEMORY: () => (/* binding */ NO_MEMORY)
/* harmony export */ });
/* unused harmony exports EAGAIN, CODEC_NOT_SUPPORT */
/*
 * libmedia error defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const FORMAT_NOT_SUPPORT = -1;
const DATA_INVALID = -2;
const INVALID_ARGUMENT = -3;
const NO_MEMORY = -4;
const INVALID_OPERATE = -5;
const EAGAIN = -6;
const EOF = -7;
const CODEC_NOT_SUPPORT = -8;


/***/ }),

/***/ "./src/avutil/function/audioData2AVFrame.ts":
/*!**************************************************!*\
  !*** ./src/avutil/function/audioData2AVFrame.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   audioData2AVFrame: () => (/* binding */ audioData2AVFrame)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _util_avframe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var _util_sample__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/sample */ "./src/avutil/util/sample.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");


/* libmedia AudioData to AVFrame utils
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function mapFormat(format) {
    switch (format) {
        case 'u8':
            return 0 /* AVSampleFormat.AV_SAMPLE_FMT_U8 */;
        case 's16':
            return 1 /* AVSampleFormat.AV_SAMPLE_FMT_S16 */;
        case 's32':
            return 2 /* AVSampleFormat.AV_SAMPLE_FMT_S32 */;
        case 'f32':
            return 3 /* AVSampleFormat.AV_SAMPLE_FMT_FLT */;
        case 'u8-planar':
            return 5 /* AVSampleFormat.AV_SAMPLE_FMT_U8P */;
        case 's16-planar':
            return 6 /* AVSampleFormat.AV_SAMPLE_FMT_S16P */;
        case 's32-planar':
            return 7 /* AVSampleFormat.AV_SAMPLE_FMT_S32P */;
        case 'f32-planar':
            return 8 /* AVSampleFormat.AV_SAMPLE_FMT_FLTP */;
        default:
            throw new Error('not support');
    }
}
function audioData2AVFrame(audioData, avframe = 0) {
    if (avframe === 0) {
        avframe = (0,_util_avframe__WEBPACK_IMPORTED_MODULE_0__.createAVFrame)();
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avframe + 152, audioData.sampleRate);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avframe + 76, audioData.numberOfFrames);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avframe + 292, audioData.numberOfChannels);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avframe + 80, mapFormat(audioData.format));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avframe + 104, BigInt(Math.floor(audioData.timestamp)));
    (0,_util_avframe__WEBPACK_IMPORTED_MODULE_0__.getAudioBuffer)(avframe);
    const planar = (0,_util_sample__WEBPACK_IMPORTED_MODULE_2__.sampleFormatIsPlanar)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avframe + 80));
    const planes = planar ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avframe + 292) : 1;
    for (let i = 0; i < planes; i++) {
        audioData.copyTo((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](avframe + 64) + (i * 4)), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avframe + 32)), {
            planeIndex: i
        });
    }
    return avframe;
}


/***/ }),

/***/ "./src/avutil/function/avframe2AudioData.ts":
/*!**************************************************!*\
  !*** ./src/avutil/function/avframe2AudioData.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   avframe2AudioData: () => (/* binding */ avframe2AudioData)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _util_sample__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/sample */ "./src/avutil/util/sample.ts");
/* harmony import */ var _util_rational__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");

/*
 * libmedia AVFrame to AudioData utils
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




function mapFormat(avframe) {
    switch (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avframe + 80)) {
        case 0 /* AVSampleFormat.AV_SAMPLE_FMT_U8 */:
            return 'u8';
        case 1 /* AVSampleFormat.AV_SAMPLE_FMT_S16 */:
            return 's16';
        case 2 /* AVSampleFormat.AV_SAMPLE_FMT_S32 */:
            return 's32';
        case 3 /* AVSampleFormat.AV_SAMPLE_FMT_FLT */:
            return 'f32';
        case 5 /* AVSampleFormat.AV_SAMPLE_FMT_U8P */:
            return 'u8-planar';
        case 6 /* AVSampleFormat.AV_SAMPLE_FMT_S16P */:
            return 's16-planar';
        case 7 /* AVSampleFormat.AV_SAMPLE_FMT_S32P */:
            return 's32-planar';
        case 8 /* AVSampleFormat.AV_SAMPLE_FMT_FLTP */:
            return 'f32-planar';
        default:
            throw new Error('not support');
    }
}
function mapBuffer(format, data) {
    switch (format) {
        case 0 /* AVSampleFormat.AV_SAMPLE_FMT_U8 */:
        case 5 /* AVSampleFormat.AV_SAMPLE_FMT_U8P */:
            return data;
        case 1 /* AVSampleFormat.AV_SAMPLE_FMT_S16 */:
        case 6 /* AVSampleFormat.AV_SAMPLE_FMT_S16P */:
            return new Int16Array(data.buffer);
        case 2 /* AVSampleFormat.AV_SAMPLE_FMT_S32 */:
        case 7 /* AVSampleFormat.AV_SAMPLE_FMT_S32P */:
            return new Int32Array(data.buffer);
        case 3 /* AVSampleFormat.AV_SAMPLE_FMT_FLT */:
        case 8 /* AVSampleFormat.AV_SAMPLE_FMT_FLTP */:
            return new Float32Array(data.buffer);
        default:
            throw new Error('not support');
    }
}
function mapTypeBuffer(format, pointer, size) {
    switch (format) {
        case 0 /* AVSampleFormat.AV_SAMPLE_FMT_U8 */:
        case 5 /* AVSampleFormat.AV_SAMPLE_FMT_U8P */:
            return (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(pointer, size);
        case 1 /* AVSampleFormat.AV_SAMPLE_FMT_S16 */:
        case 6 /* AVSampleFormat.AV_SAMPLE_FMT_S16P */:
            return (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapInt16Array)(pointer, size >>> 1);
        case 2 /* AVSampleFormat.AV_SAMPLE_FMT_S32 */:
        case 7 /* AVSampleFormat.AV_SAMPLE_FMT_S32P */:
            return (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapInt32Array)(pointer, size >>> 2);
        case 3 /* AVSampleFormat.AV_SAMPLE_FMT_FLT */:
        case 8 /* AVSampleFormat.AV_SAMPLE_FMT_FLTP */:
            return (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapFloat32Array)(pointer, size >>> 2);
        default:
            throw new Error('not support');
    }
}
function avframe2AudioData(avframe, timeBase) {
    const planar = (0,_util_sample__WEBPACK_IMPORTED_MODULE_2__.sampleFormatIsPlanar)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avframe + 80));
    const planes = planar ? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avframe + 292) : 1;
    let data;
    const sampleSize = (0,_util_sample__WEBPACK_IMPORTED_MODULE_2__.getBytesPerSample)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avframe + 80));
    if (planar) {
        const linesize = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avframe + 76) * sampleSize;
        const buffer = new Uint8Array(planes * linesize);
        let offset = 0;
        for (let i = 0; i < planes; i++) {
            buffer.set((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avframe + 4 * (i)), linesize), offset);
            offset += linesize;
        }
        data = mapBuffer(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avframe + 80), buffer);
    }
    else {
        data = mapTypeBuffer(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avframe + 80), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avframe), sampleSize * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avframe + 76) * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avframe + 292));
    }
    const audioData = new AudioData({
        data,
        format: mapFormat(avframe),
        sampleRate: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avframe + 152),
        numberOfFrames: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avframe + 76),
        numberOfChannels: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avframe + 292),
        timestamp: Number(timeBase ? (0,_util_rational__WEBPACK_IMPORTED_MODULE_3__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avframe + 104), timeBase, _constant__WEBPACK_IMPORTED_MODULE_4__.AV_TIME_BASE_Q) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avframe + 104))
    });
    return audioData;
}


/***/ }),

/***/ "./src/avutil/function/avframe2VideoFrame.ts":
/*!***************************************************!*\
  !*** ./src/avutil/function/avframe2VideoFrame.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   avframe2VideoFrame: () => (/* binding */ avframe2VideoFrame)
/* harmony export */ });
/* unused harmony exports avPixelFormat2Format, getVideoColorSpaceInit */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var _util_rational__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/rational */ "./src/avutil/util/rational.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");





function avPixelFormat2Format(pixfmt) {
    switch (pixfmt) {
        case 0 /* AVPixelFormat.AV_PIX_FMT_YUV420P */:
            return 'I420';
        case 33 /* AVPixelFormat.AV_PIX_FMT_YUVA420P */:
            return 'I420A';
        case 4 /* AVPixelFormat.AV_PIX_FMT_YUV422P */:
            return 'I422';
        case 5 /* AVPixelFormat.AV_PIX_FMT_YUV444P */:
            return 'I444';
        case 28 /* AVPixelFormat.AV_PIX_FMT_BGRA */:
            return 'BGRA';
        case 26 /* AVPixelFormat.AV_PIX_FMT_RGBA */:
            return 'RGBA';
        case 23 /* AVPixelFormat.AV_PIX_FMT_NV12 */:
            return 'NV12';
        default:
            return null;
    }
}
function getVideoColorSpaceInit(avframe) {
    const init = {
        fullRange: false,
        matrix: null,
        primaries: null,
        transfer: null
    };
    switch (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 220)) {
        case 1 /* AVColorSpace.AVCOL_SPC_BT709 */:
            init.matrix = 'bt709';
            break;
        case 6 /* AVColorSpace.AVCOL_SPC_SMPTE170M */:
            init.matrix = 'smpte170m';
            break;
        case 5 /* AVColorSpace.AVCOL_SPC_BT470BG */:
            init.matrix = 'bt470bg';
            break;
        case 0 /* AVColorSpace.AVCOL_SPC_RGB */:
            init.matrix = 'rgb';
            break;
        default:
            init.matrix = 'bt709';
            break;
    }
    switch (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 212)) {
        case 1 /* AVColorPrimaries.AVCOL_PRI_BT709 */:
            init.primaries = 'bt709';
            break;
        case 5 /* AVColorPrimaries.AVCOL_PRI_BT470BG */:
            init.primaries = 'bt470bg';
            break;
        case 6 /* AVColorPrimaries.AVCOL_PRI_SMPTE170M */:
            init.primaries = 'smpte170m';
            break;
        default:
            init.primaries = 'bt709';
            break;
    }
    switch (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 216)) {
        case 1 /* AVColorTransferCharacteristic.AVCOL_TRC_BT709 */:
            init.transfer = 'bt709';
            break;
        case 13 /* AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_1 */:
            init.transfer = 'iec61966-2-1';
            break;
        case 6 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE170M */:
            init.transfer = 'smpte170m';
            break;
        default:
            init.transfer = 'bt709';
            break;
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 208) === 2 /* AVColorRange.AVCOL_RANGE_JPEG */) {
        init.fullRange = true;
    }
    return init;
}
function avframe2VideoFrame(avframe, timeBase) {
    let height = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 72);
    const des = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_2__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 80)];
    const layout = [];
    for (let i = 0; i < des.nbComponents; i++) {
        layout.push({
            offset: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avframe + 4 * (i)),
            stride: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 32 + 4 * (i))
        });
    }
    const init = {
        codedWidth: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 68),
        codedHeight: height,
        timestamp: Number(timeBase ? (0,_util_rational__WEBPACK_IMPORTED_MODULE_3__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avframe + 104), timeBase, _constant__WEBPACK_IMPORTED_MODULE_4__.AV_TIME_BASE_Q) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avframe + 104)),
        format: avPixelFormat2Format(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 80)),
        duration: Number(timeBase ? (0,_util_rational__WEBPACK_IMPORTED_MODULE_3__.avRescaleQ)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avframe + 312), timeBase, _constant__WEBPACK_IMPORTED_MODULE_4__.AV_TIME_BASE_Q) : cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](avframe + 312)),
        layout,
        colorSpace: getVideoColorSpaceInit(avframe),
        visibleRect: {
            x: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 276),
            y: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 268),
            width: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 68) - (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 276) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 280)),
            height: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 72) - (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 268) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avframe + 272))
        }
    };
    return new VideoFrame((0,cheap_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)(), init);
}


/***/ }),

/***/ "./src/avutil/function/avpacket2EncodedAudioChunk.ts":
/*!***********************************************************!*\
  !*** ./src/avutil/function/avpacket2EncodedAudioChunk.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ avpacket2EncodedAudioChunk)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");


function avpacket2EncodedAudioChunk(avpacket, pts) {
    const timestamp = Number(pts ?? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8));
    const key = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */;
    return new EncodedAudioChunk({
        type: key ? 'key' : 'delta',
        timestamp,
        data: (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28))
    });
}


/***/ }),

/***/ "./src/avutil/function/avpacket2EncodedVideoChunk.ts":
/*!***********************************************************!*\
  !*** ./src/avutil/function/avpacket2EncodedVideoChunk.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ avpacket2EncodedVideoChunk)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");


function avpacket2EncodedVideoChunk(avpacket, pts) {
    const timestamp = Number(pts ?? cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[17](avpacket + 8));
    const key = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 36) & 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */;
    return new EncodedVideoChunk({
        type: key ? 'key' : 'delta',
        timestamp,
        data: (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](avpacket + 28))
    });
}


/***/ }),

/***/ "./src/avutil/function/createMessageChannel.ts":
/*!*****************************************************!*\
  !*** ./src/avutil/function/createMessageChannel.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ createMessageChannel)
/* harmony export */ });
/* harmony import */ var cheap_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/config */ "./src/cheap/config.ts");
/* harmony import */ var common_network_FakeMessageChannel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/FakeMessageChannel */ "./src/common/network/FakeMessageChannel.ts");
/*
 * libmedia create MessageChannel
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function createMessageChannel() {
    if (cheap_config__WEBPACK_IMPORTED_MODULE_0__.USE_THREADS && true) {
        return new MessageChannel();
    }
    return new common_network_FakeMessageChannel__WEBPACK_IMPORTED_MODULE_1__["default"]();
}


/***/ }),

/***/ "./src/avutil/function/encodedAudioChunk2AVPacket.ts":
/*!***********************************************************!*\
  !*** ./src/avutil/function/encodedAudioChunk2AVPacket.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ encodedAudioChunk2AVPacket)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _util_avpacket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");


/* libmedia EncodedAudioChunk to AVPacket utils
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




function encodedAudioChunk2AVPacket(chunk, avpacket = 0, metadata) {
    if (avpacket === 0) {
        avpacket = (0,_util_avpacket__WEBPACK_IMPORTED_MODULE_0__.createAVPacket)();
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avpacket + 8, BigInt(Math.floor(chunk.timestamp))), cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avpacket + 16, BigInt(Math.floor(chunk.timestamp)));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avpacket + 48, BigInt(Math.floor(chunk.duration)));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avpacket + 76, _constant__WEBPACK_IMPORTED_MODULE_2__.AV_TIME_BASE);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avpacket + 72, 1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avpacket + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](avpacket + 36) | 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */);
    const data = (0,_util_mem__WEBPACK_IMPORTED_MODULE_4__.avMalloc)(chunk.byteLength);
    chunk.copyTo((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.mapUint8Array)(data, chunk.byteLength));
    (0,_util_avpacket__WEBPACK_IMPORTED_MODULE_0__.addAVPacketData)(avpacket, data, chunk.byteLength);
    if (metadata) {
        if (metadata.decoderConfig?.description) {
            let buffer;
            if (metadata.decoderConfig.description instanceof ArrayBuffer) {
                buffer = new Uint8Array(metadata.decoderConfig.description);
            }
            else {
                buffer = new Uint8Array(metadata.decoderConfig.description.buffer);
            }
            const extradata = (0,_util_mem__WEBPACK_IMPORTED_MODULE_4__.avMalloc)(buffer.length);
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memcpyFromUint8Array)(extradata, buffer.length, buffer);
            (0,_util_avpacket__WEBPACK_IMPORTED_MODULE_0__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradata, buffer.length);
        }
    }
}


/***/ }),

/***/ "./src/avutil/function/encodedVideoChunk2AVPacket.ts":
/*!***********************************************************!*\
  !*** ./src/avutil/function/encodedVideoChunk2AVPacket.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ encodedVideoChunk2AVPacket)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _util_avpacket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");


/* libmedia EncodedVideoChunk to AVPacket utils
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




function encodedVideoChunk2AVPacket(chunk, avpacket = 0, metadata) {
    if (avpacket === 0) {
        avpacket = (0,_util_avpacket__WEBPACK_IMPORTED_MODULE_0__.createAVPacket)();
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avpacket + 8, BigInt(Math.floor(chunk.timestamp)));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avpacket + 76, _constant__WEBPACK_IMPORTED_MODULE_2__.AV_TIME_BASE);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avpacket + 72, 1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](avpacket + 48, BigInt(Math.floor(chunk.duration)));
    const data = (0,_util_mem__WEBPACK_IMPORTED_MODULE_3__.avMalloc)(chunk.byteLength);
    chunk.copyTo((0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.mapUint8Array)(data, chunk.byteLength));
    (0,_util_avpacket__WEBPACK_IMPORTED_MODULE_0__.addAVPacketData)(avpacket, data, chunk.byteLength);
    if (metadata) {
        if (metadata.decoderConfig?.description) {
            let buffer;
            if (metadata.decoderConfig.description instanceof ArrayBuffer) {
                buffer = new Uint8Array(metadata.decoderConfig.description);
            }
            else {
                buffer = new Uint8Array(metadata.decoderConfig.description.buffer);
            }
            const extradata = (0,_util_mem__WEBPACK_IMPORTED_MODULE_3__.avMalloc)(buffer.length);
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.memcpyFromUint8Array)(extradata, buffer.length, buffer);
            (0,_util_avpacket__WEBPACK_IMPORTED_MODULE_0__.addAVPacketSideData)(avpacket, 1 /* AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA */, extradata, buffer.length);
        }
        if (metadata.alphaSideData) {
            const extradata = (0,_util_mem__WEBPACK_IMPORTED_MODULE_3__.avMalloc)(metadata.alphaSideData.byteLength);
            let buffer;
            if (metadata.alphaSideData instanceof ArrayBuffer) {
                buffer = new Uint8Array(metadata.alphaSideData);
            }
            else {
                buffer = new Uint8Array(metadata.alphaSideData.buffer);
            }
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.memcpyFromUint8Array)(extradata, buffer.length, buffer);
            (0,_util_avpacket__WEBPACK_IMPORTED_MODULE_0__.addAVPacketSideData)(avpacket, 15 /* AVPacketSideDataType.AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL */, extradata, buffer.length);
        }
    }
    if (chunk.type === 'key') {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](avpacket + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](avpacket + 36) | 1 /* AVPacketFlags.AV_PKT_FLAG_KEY */);
    }
}


/***/ }),

/***/ "./src/avutil/function/videoFrame2AVFrame.ts":
/*!***************************************************!*\
  !*** ./src/avutil/function/videoFrame2AVFrame.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapColorPrimaries: () => (/* binding */ mapColorPrimaries),
/* harmony export */   mapColorSpace: () => (/* binding */ mapColorSpace),
/* harmony export */   mapColorTrc: () => (/* binding */ mapColorTrc),
/* harmony export */   mapFormat: () => (/* binding */ mapFormat),
/* harmony export */   videoFrame2AVFrame: () => (/* binding */ videoFrame2AVFrame)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _util_avframe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/avframe */ "./src/avutil/util/avframe.ts");
/* harmony import */ var _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");


/* libmedia VideoFrame to AVFrame utils
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function mapFormat(format) {
    switch (format) {
        case 'BGRA':
            return 28 /* AVPixelFormat.AV_PIX_FMT_BGRA */;
        case 'BGRX':
            return 121 /* AVPixelFormat.AV_PIX_FMT_BGR0 */;
        case 'I420':
            return 0 /* AVPixelFormat.AV_PIX_FMT_YUV420P */;
        case 'I420A':
            return 33 /* AVPixelFormat.AV_PIX_FMT_YUVA420P */;
        case 'I422':
            return 4 /* AVPixelFormat.AV_PIX_FMT_YUV422P */;
        case 'I444':
            return 5 /* AVPixelFormat.AV_PIX_FMT_YUV444P */;
        case 'NV12':
            return 23 /* AVPixelFormat.AV_PIX_FMT_NV12 */;
        case 'RGBA':
            return 26 /* AVPixelFormat.AV_PIX_FMT_RGBA */;
        case 'RGBX':
            return 119 /* AVPixelFormat.AV_PIX_FMT_RGB0 */;
        default:
            throw new Error('not support');
    }
}
function mapColorSpace(colorSpace) {
    switch (colorSpace) {
        case 'bt709':
            return 1 /* AVColorSpace.AVCOL_SPC_BT709 */;
        case 'smpte170m':
            return 6 /* AVColorSpace.AVCOL_SPC_SMPTE170M */;
        case 'bt470bg':
            return 5 /* AVColorSpace.AVCOL_SPC_BT470BG */;
        case 'rgb':
            return 0 /* AVColorSpace.AVCOL_SPC_RGB */;
        default:
            return 1 /* AVColorSpace.AVCOL_SPC_BT709 */;
    }
}
function mapColorPrimaries(colorPrimaries) {
    switch (colorPrimaries) {
        case 'bt709':
            return 1 /* AVColorPrimaries.AVCOL_PRI_BT709 */;
        case 'bt470bg':
            return 5 /* AVColorPrimaries.AVCOL_PRI_BT470BG */;
        case 'smpte170m':
            return 6 /* AVColorPrimaries.AVCOL_PRI_SMPTE170M */;
        default:
            return 1 /* AVColorPrimaries.AVCOL_PRI_BT709 */;
    }
}
function mapColorTrc(colorTrc) {
    switch (colorTrc) {
        case 'bt709':
            return 1 /* AVColorTransferCharacteristic.AVCOL_TRC_BT709 */;
        case 'iec61966-2-1':
            return 13 /* AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_1 */;
        case 'smpte170m':
            return 6 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE170M */;
        default:
            return 1 /* AVColorTransferCharacteristic.AVCOL_TRC_BT709 */;
    }
}
function videoFrame2AVFrame(videoFrame, avframe = 0) {
    if (avframe === 0) {
        avframe = (0,_util_avframe__WEBPACK_IMPORTED_MODULE_1__.createAVFrame)();
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avframe + 80, mapFormat(videoFrame.format));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avframe + 104, BigInt(Math.floor(videoFrame.timestamp)));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avframe + 68, videoFrame.codedWidth);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avframe + 72, videoFrame.codedHeight);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avframe + 312, BigInt(Math.floor(videoFrame.duration)));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avframe + 220, mapColorSpace(videoFrame.colorSpace.matrix));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avframe + 212, mapColorPrimaries(videoFrame.colorSpace.primaries));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avframe + 216, mapColorTrc(videoFrame.colorSpace.transfer));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avframe + 208, videoFrame.colorSpace.fullRange ? 2 /* AVColorRange.AVCOL_RANGE_JPEG */ : 1 /* AVColorRange.AVCOL_RANGE_MPEG */);
    if (videoFrame.visibleRect) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avframe + 276, videoFrame.visibleRect.left);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avframe + 280, videoFrame.visibleRect.right);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avframe + 268, videoFrame.visibleRect.top);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avframe + 272, videoFrame.visibleRect.bottom);
    }
    (0,_util_avframe__WEBPACK_IMPORTED_MODULE_1__.getVideoBuffer)(avframe);
    const des = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_3__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avframe + 80)];
    const layout = [];
    for (let i = 0; i < des.nbComponents; i++) {
        if (des.comp[i].plane >= i) {
            layout.push({
                offset: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](avframe + 4 * (i)),
                stride: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](avframe + 32 + 4 * (i))
            });
        }
    }
    videoFrame.copyTo((0,cheap_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)(), {
        layout
    });
    return avframe;
}


/***/ }),

/***/ "./src/avutil/implement/AVFramePoolImpl.ts":
/*!*************************************************!*\
  !*** ./src/avutil/implement/AVFramePoolImpl.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVFramePoolImpl)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _util_avframe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/avframe */ "./src/avutil/util/avframe.ts");


/*
 * libmedia AVFrame pool implement
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */





class AVFramePoolImpl {
    list;
    mutex;
    constructor(list, mutex) {
        this.list = list;
        this.mutex = mutex;
    }
    alloc() {
        let avframe = this.list.find((avframe) => {
            return cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(avframe + 320, -1, 1, 16, 2) === -1;
        }, 20);
        if (!avframe) {
            avframe = (0,_util_mem__WEBPACK_IMPORTED_MODULE_1__.avMallocz)(328);
            (0,_util_avframe__WEBPACK_IMPORTED_MODULE_2__.getAVFrameDefault)(avframe);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[16](avframe + 320, 1);
            {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__.lock(this.mutex);
            }
            this.list.push(avframe, 20);
            {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__.unlock(this.mutex);
            }
        }
        return avframe;
    }
    release(avframe) {
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(avframe + 320, 16, 2) <= 0) {
            return;
        }
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(avframe + 320, 1, 16, 2) === 1) {
            (0,_util_avframe__WEBPACK_IMPORTED_MODULE_2__.unrefAVFrame)(avframe);
            cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(avframe + 320, -1, 16, 2);
        }
    }
}


/***/ }),

/***/ "./src/avutil/implement/AVPacketPoolImpl.ts":
/*!**************************************************!*\
  !*** ./src/avutil/implement/AVPacketPoolImpl.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVPacketPoolImpl)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _util_avpacket__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/avpacket */ "./src/avutil/util/avpacket.ts");







class AVPacketPoolImpl {
    list;
    mutex;
    constructor(list, mutex) {
        this.list = list;
        this.mutex = mutex;
    }
    alloc() {
        let avpacket = this.list.find((avpacket) => {
            return cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(avpacket + 88, -1, 1, 16, 2) === -1;
        }, 20);
        if (!avpacket) {
            avpacket = (0,_util_mem__WEBPACK_IMPORTED_MODULE_1__.avMallocz)(96);
            (0,_util_avpacket__WEBPACK_IMPORTED_MODULE_2__.getAVPacketDefault)(avpacket);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[16](avpacket + 88, 1);
            {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__.lock(this.mutex);
            }
            this.list.push(avpacket, 20);
            {
                cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_4__.unlock(this.mutex);
            }
        }
        return avpacket;
    }
    release(avpacket) {
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(avpacket + 88, 16, 2) <= 0) {
            return;
        }
        if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(avpacket + 88, 1, 16, 2) === 1) {
            (0,_util_avpacket__WEBPACK_IMPORTED_MODULE_2__.unrefAVPacket)(avpacket);
            cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(avpacket + 88, -1, 16, 2);
        }
    }
}


/***/ }),

/***/ "./src/avutil/pixelFormatDescriptor.ts":
/*!*********************************************!*\
  !*** ./src/avutil/pixelFormatDescriptor.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PixelFormatDescriptorsMap: () => (/* binding */ PixelFormatDescriptorsMap)
/* harmony export */ });
/*
 * libmedia pixel format descriptor
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const PixelFormatDescriptorsMap = {
    /**
     * 1 字节
     */
    [0 /* AVPixelFormat.AV_PIX_FMT_YUV420P */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [12 /* AVPixelFormat.AV_PIX_FMT_YUVJ420P */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [4 /* AVPixelFormat.AV_PIX_FMT_YUV422P */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [13 /* AVPixelFormat.AV_PIX_FMT_YUVJ422P */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [5 /* AVPixelFormat.AV_PIX_FMT_YUV444P */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [14 /* AVPixelFormat.AV_PIX_FMT_YUVJ444P */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [23 /* AVPixelFormat.AV_PIX_FMT_NV12 */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 2,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 2,
                offset: 1,
                shift: 0,
                depth: 8
            }
        ]
    },
    /**
     * 2 字节 yuv420
     */
    [59 /* AVPixelFormat.AV_PIX_FMT_YUV420P9BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            }
        ]
    },
    [60 /* AVPixelFormat.AV_PIX_FMT_YUV420P9LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            }
        ]
    },
    [61 /* AVPixelFormat.AV_PIX_FMT_YUV420P10BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            }
        ]
    },
    [62 /* AVPixelFormat.AV_PIX_FMT_YUV420P10LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            }
        ]
    },
    [122 /* AVPixelFormat.AV_PIX_FMT_YUV420P12BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            }
        ]
    },
    [123 /* AVPixelFormat.AV_PIX_FMT_YUV420P12LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            }
        ]
    },
    [124 /* AVPixelFormat.AV_PIX_FMT_YUV420P14BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            }
        ]
    },
    [125 /* AVPixelFormat.AV_PIX_FMT_YUV420P14LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            }
        ]
    },
    [46 /* AVPixelFormat.AV_PIX_FMT_YUV420P16BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            }
        ]
    },
    [45 /* AVPixelFormat.AV_PIX_FMT_YUV420P16LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            }
        ]
    },
    /**
     * 2 字节 yuv422
     */
    [69 /* AVPixelFormat.AV_PIX_FMT_YUV422P9BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            }
        ]
    },
    [70 /* AVPixelFormat.AV_PIX_FMT_YUV422P9LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            }
        ]
    },
    [63 /* AVPixelFormat.AV_PIX_FMT_YUV422P10BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            }
        ]
    },
    [64 /* AVPixelFormat.AV_PIX_FMT_YUV422P10LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            }
        ]
    },
    [126 /* AVPixelFormat.AV_PIX_FMT_YUV422P12BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            }
        ]
    },
    [127 /* AVPixelFormat.AV_PIX_FMT_YUV422P12LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            }
        ]
    },
    [128 /* AVPixelFormat.AV_PIX_FMT_YUV422P14BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            }
        ]
    },
    [129 /* AVPixelFormat.AV_PIX_FMT_YUV422P14LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            }
        ]
    },
    [48 /* AVPixelFormat.AV_PIX_FMT_YUV422P16BE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            }
        ]
    },
    [47 /* AVPixelFormat.AV_PIX_FMT_YUV422P16LE */]: {
        nbComponents: 3,
        log2ChromaW: 1,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            }
        ]
    },
    /**
     * 2 字节 yuv444
     */
    [65 /* AVPixelFormat.AV_PIX_FMT_YUV444P9BE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            }
        ]
    },
    [66 /* AVPixelFormat.AV_PIX_FMT_YUV444P9LE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 9
            }
        ]
    },
    [67 /* AVPixelFormat.AV_PIX_FMT_YUV444P10BE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            }
        ]
    },
    [68 /* AVPixelFormat.AV_PIX_FMT_YUV444P10LE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 10
            }
        ]
    },
    [130 /* AVPixelFormat.AV_PIX_FMT_YUV444P12BE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            }
        ]
    },
    [131 /* AVPixelFormat.AV_PIX_FMT_YUV444P12LE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 12
            }
        ]
    },
    [132 /* AVPixelFormat.AV_PIX_FMT_YUV444P14BE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            }
        ]
    },
    [133 /* AVPixelFormat.AV_PIX_FMT_YUV444P14LE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 14
            }
        ]
    },
    [50 /* AVPixelFormat.AV_PIX_FMT_YUV444P16BE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 1 /* PixelFormatFlags.BIG_ENDIAN */ | 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            }
        ]
    },
    [49 /* AVPixelFormat.AV_PIX_FMT_YUV444P16LE */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 16 /* PixelFormatFlags.PLANER */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 16
            }
        ]
    },
    [26 /* AVPixelFormat.AV_PIX_FMT_RGBA */]: {
        nbComponents: 4,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 32 /* PixelFormatFlags.RGB */ | 128 /* PixelFormatFlags.ALPHA */,
        comp: [
            {
                plane: 0,
                step: 4,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 1,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 2,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 3,
                shift: 0,
                depth: 8
            }
        ]
    },
    [119 /* AVPixelFormat.AV_PIX_FMT_RGB0 */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 32 /* PixelFormatFlags.RGB */,
        comp: [
            {
                plane: 0,
                step: 4,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 1,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 2,
                shift: 0,
                depth: 8
            }
        ]
    },
    [28 /* AVPixelFormat.AV_PIX_FMT_BGRA */]: {
        nbComponents: 4,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 32 /* PixelFormatFlags.RGB */ | 128 /* PixelFormatFlags.ALPHA */,
        comp: [
            {
                plane: 0,
                step: 4,
                offset: 2,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 1,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 3,
                shift: 0,
                depth: 8
            }
        ]
    },
    [121 /* AVPixelFormat.AV_PIX_FMT_BGR0 */]: {
        nbComponents: 3,
        log2ChromaW: 0,
        log2ChromaH: 0,
        flags: 32 /* PixelFormatFlags.RGB */,
        comp: [
            {
                plane: 0,
                step: 4,
                offset: 2,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 1,
                shift: 0,
                depth: 8
            },
            {
                plane: 0,
                step: 4,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    },
    [33 /* AVPixelFormat.AV_PIX_FMT_YUVA420P */]: {
        nbComponents: 4,
        log2ChromaW: 1,
        log2ChromaH: 1,
        flags: 16 /* PixelFormatFlags.PLANER */ | 128 /* PixelFormatFlags.ALPHA */,
        comp: [
            {
                plane: 0,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 1,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 2,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            },
            {
                plane: 3,
                step: 1,
                offset: 0,
                shift: 0,
                depth: 8
            }
        ]
    }
};


/***/ }),

/***/ "./src/avutil/sampleFormatDescriptor.ts":
/*!**********************************************!*\
  !*** ./src/avutil/sampleFormatDescriptor.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVSampleFormatDescriptors: () => (/* binding */ AVSampleFormatDescriptors)
/* harmony export */ });
const AVSampleFormatDescriptors = {
    [0 /* AVSampleFormat.AV_SAMPLE_FMT_U8 */]: {
        bits: 8,
        planar: false
    },
    [1 /* AVSampleFormat.AV_SAMPLE_FMT_S16 */]: {
        bits: 16,
        planar: false
    },
    [2 /* AVSampleFormat.AV_SAMPLE_FMT_S32 */]: {
        bits: 32,
        planar: false
    },
    [10 /* AVSampleFormat.AV_SAMPLE_FMT_S64 */]: {
        bits: 64,
        planar: false
    },
    [3 /* AVSampleFormat.AV_SAMPLE_FMT_FLT */]: {
        bits: 32,
        planar: false
    },
    [4 /* AVSampleFormat.AV_SAMPLE_FMT_DBL */]: {
        bits: 64,
        planar: false
    },
    [5 /* AVSampleFormat.AV_SAMPLE_FMT_U8P */]: {
        bits: 8,
        planar: true
    },
    [6 /* AVSampleFormat.AV_SAMPLE_FMT_S16P */]: {
        bits: 16,
        planar: true
    },
    [7 /* AVSampleFormat.AV_SAMPLE_FMT_S32P */]: {
        bits: 32,
        planar: true
    },
    [11 /* AVSampleFormat.AV_SAMPLE_FMT_S64P */]: {
        bits: 64,
        planar: true
    },
    [8 /* AVSampleFormat.AV_SAMPLE_FMT_FLTP */]: {
        bits: 32,
        planar: true
    },
    [9 /* AVSampleFormat.AV_SAMPLE_FMT_DBLP */]: {
        bits: 64,
        planar: true
    },
};


/***/ }),

/***/ "./src/avutil/stringEnum.ts":
/*!**********************************!*\
  !*** ./src/avutil/stringEnum.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AudioCodecString2CodecId: () => (/* binding */ AudioCodecString2CodecId),
/* harmony export */   Ext2Format: () => (/* binding */ Ext2Format),
/* harmony export */   Ext2IOLoader: () => (/* binding */ Ext2IOLoader),
/* harmony export */   Format2AVFormat: () => (/* binding */ Format2AVFormat),
/* harmony export */   PixfmtString2AVPixelFormat: () => (/* binding */ PixfmtString2AVPixelFormat),
/* harmony export */   SampleFmtString2SampleFormat: () => (/* binding */ SampleFmtString2SampleFormat),
/* harmony export */   VideoCodecString2CodecId: () => (/* binding */ VideoCodecString2CodecId),
/* harmony export */   colorRange2AVColorRange: () => (/* binding */ colorRange2AVColorRange),
/* harmony export */   colorSpace2AVColorSpace: () => (/* binding */ colorSpace2AVColorSpace),
/* harmony export */   disposition2AVDisposition: () => (/* binding */ disposition2AVDisposition),
/* harmony export */   mediaType2AVMediaType: () => (/* binding */ mediaType2AVMediaType)
/* harmony export */ });
/* unused harmony exports colorPrimaries2AVColorPrimaries, colorTrc2AVColorTransferCharacteristic */
const Ext2Format = {
    'flv': 0 /* AVFormat.FLV */,
    'mp4': 1 /* AVFormat.MOV */,
    'mov': 1 /* AVFormat.MOV */,
    'ts': 2 /* AVFormat.MPEGTS */,
    'ivf': 4 /* AVFormat.IVF */,
    'opus': 3 /* AVFormat.OGGS */,
    'ogg': 3 /* AVFormat.OGGS */,
    'm3u8': 2 /* AVFormat.MPEGTS */,
    'm3u': 2 /* AVFormat.MPEGTS */,
    'mpd': 1 /* AVFormat.MOV */,
    'mp3': 7 /* AVFormat.MP3 */,
    'mkv': 5 /* AVFormat.MATROSKA */,
    'mka': 5 /* AVFormat.MATROSKA */,
    'webm': 5 /* AVFormat.WEBM */,
    'aac': 8 /* AVFormat.AAC */,
    'flac': 10 /* AVFormat.FLAC */,
    'wav': 9 /* AVFormat.WAV */
};
const Ext2IOLoader = {
    'm3u8': 2 /* IOType.HLS */,
    'm3u': 2 /* IOType.HLS */,
    'mpd': 3 /* IOType.DASH */
};
const VideoCodecString2CodecId = {
    'copy': 0 /* AVCodecID.AV_CODEC_ID_NONE */,
    'h264': 27 /* AVCodecID.AV_CODEC_ID_H264 */,
    'avc': 27 /* AVCodecID.AV_CODEC_ID_H264 */,
    'hevc': 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    'h265': 173 /* AVCodecID.AV_CODEC_ID_HEVC */,
    'vvc': 196 /* AVCodecID.AV_CODEC_ID_VVC */,
    'h266': 196 /* AVCodecID.AV_CODEC_ID_VVC */,
    'av1': 225 /* AVCodecID.AV_CODEC_ID_AV1 */,
    'vp9': 167 /* AVCodecID.AV_CODEC_ID_VP9 */,
    'vp8': 139 /* AVCodecID.AV_CODEC_ID_VP8 */,
    'mpeg4': 12 /* AVCodecID.AV_CODEC_ID_MPEG4 */
};
const AudioCodecString2CodecId = {
    'copy': 0 /* AVCodecID.AV_CODEC_ID_NONE */,
    'aac': 86018 /* AVCodecID.AV_CODEC_ID_AAC */,
    'mp3': 86017 /* AVCodecID.AV_CODEC_ID_MP3 */,
    'opus': 86076 /* AVCodecID.AV_CODEC_ID_OPUS */,
    'flac': 86028 /* AVCodecID.AV_CODEC_ID_FLAC */,
    'speex': 86051 /* AVCodecID.AV_CODEC_ID_SPEEX */,
    'vorbis': 86021 /* AVCodecID.AV_CODEC_ID_VORBIS */
};
const PixfmtString2AVPixelFormat = {
    'yuv420p': 0 /* AVPixelFormat.AV_PIX_FMT_YUV420P */,
    'yuv422p': 4 /* AVPixelFormat.AV_PIX_FMT_YUV422P */,
    'yuv444p': 5 /* AVPixelFormat.AV_PIX_FMT_YUV444P */,
    'yuv420p10le': 62 /* AVPixelFormat.AV_PIX_FMT_YUV420P10LE */,
    'yuv422p10le': 64 /* AVPixelFormat.AV_PIX_FMT_YUV422P10LE */,
    'yuv444p10le': 68 /* AVPixelFormat.AV_PIX_FMT_YUV444P10LE */,
    'yuv420p10be': 61 /* AVPixelFormat.AV_PIX_FMT_YUV420P10BE */,
    'yuv422p10be': 63 /* AVPixelFormat.AV_PIX_FMT_YUV422P10BE */,
    'yuv444p10be': 67 /* AVPixelFormat.AV_PIX_FMT_YUV444P10BE */,
};
const SampleFmtString2SampleFormat = {
    'u8': 0 /* AVSampleFormat.AV_SAMPLE_FMT_U8 */,
    'u8p': 5 /* AVSampleFormat.AV_SAMPLE_FMT_U8P */,
    's16': 1 /* AVSampleFormat.AV_SAMPLE_FMT_S16 */,
    's16p': 6 /* AVSampleFormat.AV_SAMPLE_FMT_S16P */,
    's32': 2 /* AVSampleFormat.AV_SAMPLE_FMT_S32 */,
    's32p': 7 /* AVSampleFormat.AV_SAMPLE_FMT_S32P */,
    's64': 10 /* AVSampleFormat.AV_SAMPLE_FMT_S64 */,
    's64p': 11 /* AVSampleFormat.AV_SAMPLE_FMT_S64P */,
    'float': 3 /* AVSampleFormat.AV_SAMPLE_FMT_FLT */,
    'floatp': 8 /* AVSampleFormat.AV_SAMPLE_FMT_FLTP */,
    'double': 4 /* AVSampleFormat.AV_SAMPLE_FMT_DBL */,
    'doublep': 9 /* AVSampleFormat.AV_SAMPLE_FMT_DBLP */,
};
const Format2AVFormat = {
    'flv': 0 /* AVFormat.FLV */,
    'mp4': 1 /* AVFormat.MOV */,
    'mov': 1 /* AVFormat.MOV */,
    'ts': 2 /* AVFormat.MPEGTS */,
    'mpegts': 2 /* AVFormat.MPEGTS */,
    'ivf': 4 /* AVFormat.IVF */,
    'opus': 3 /* AVFormat.OGGS */,
    'ogg': 3 /* AVFormat.OGGS */,
    'm3u8': 2 /* AVFormat.MPEGTS */,
    'm3u': 2 /* AVFormat.MPEGTS */,
    'mpd': 1 /* AVFormat.MOV */,
    'mp3': 7 /* AVFormat.MP3 */,
    'mkv': 5 /* AVFormat.MATROSKA */,
    'matroska': 5 /* AVFormat.MATROSKA */,
    'mka': 5 /* AVFormat.MATROSKA */,
    'webm': 5 /* AVFormat.WEBM */,
    'aac': 8 /* AVFormat.AAC */,
    'flac': 10 /* AVFormat.FLAC */,
    'wav': 9 /* AVFormat.WAV */
};
const colorRange2AVColorRange = {
    'tv': 1 /* AVColorRange.AVCOL_RANGE_MPEG */,
    'pc': 2 /* AVColorRange.AVCOL_RANGE_JPEG */
};
const colorSpace2AVColorSpace = {
    'bt709': 1 /* AVColorSpace.AVCOL_SPC_BT709 */,
    'fcc': 4 /* AVColorSpace.AVCOL_SPC_FCC */,
    'bt470bg': 5 /* AVColorSpace.AVCOL_SPC_BT470BG */,
    'smpte170m': 6 /* AVColorSpace.AVCOL_SPC_SMPTE170M */,
    'smpte240m': 7 /* AVColorSpace.AVCOL_SPC_SMPTE240M */,
    'ycgco': 8 /* AVColorSpace.AVCOL_SPC_YCGCO */,
    'gbr': 0 /* AVColorSpace.AVCOL_SPC_RGB */,
    'bt2020ncl': 9 /* AVColorSpace.AVCOL_SPC_BT2020_NCL */
};
const colorPrimaries2AVColorPrimaries = {
    'bt709': 1 /* AVColorPrimaries.AVCOL_PRI_BT709 */,
    'bt470m': 4 /* AVColorPrimaries.AVCOL_PRI_BT470M */,
    'bt470bg': 5 /* AVColorPrimaries.AVCOL_PRI_BT470BG */,
    'smpte170m': 6 /* AVColorPrimaries.AVCOL_PRI_SMPTE170M */,
    'smpte240m': 7 /* AVColorPrimaries.AVCOL_PRI_SMPTE240M */,
    'smpte428': 10 /* AVColorPrimaries.AVCOL_PRI_SMPTE428 */,
    'film': 8 /* AVColorPrimaries.AVCOL_PRI_FILM */,
    'smpte431': 11 /* AVColorPrimaries.AVCOL_PRI_SMPTE431 */,
    'smpte432': 12 /* AVColorPrimaries.AVCOL_PRI_SMPTE432 */,
    'bt2020': 9 /* AVColorPrimaries.AVCOL_PRI_BT2020 */,
    'jedec-p22': 22 /* AVColorPrimaries.AVCOL_PRI_JEDEC_P22 */,
    'ebu3213': 22 /* AVColorPrimaries.AVCOL_PRI_EBU3213 */
};
const colorTrc2AVColorTransferCharacteristic = {
    'bt709': 1 /* AVColorTransferCharacteristic.AVCOL_TRC_BT709 */,
    'gamma22': 4 /* AVColorTransferCharacteristic.AVCOL_TRC_GAMMA22 */,
    'gamma28': 5 /* AVColorTransferCharacteristic.AVCOL_TRC_GAMMA28 */,
    'smpte170m': 6 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE170M */,
    'smpte240m': 7 /* AVColorTransferCharacteristic.AVCOL_TRC_SMPTE240M */,
    'srgb': 13 /* AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_1 */,
    'xvycc': 11 /* AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_4 */,
    'bt2020-10': 14 /* AVColorTransferCharacteristic.AVCOL_TRC_BT2020_10 */,
    'bt2020-12': 15 /* AVColorTransferCharacteristic.AVCOL_TRC_BT2020_12 */
};
const mediaType2AVMediaType = {
    'Audio': 1 /* AVMediaType.AVMEDIA_TYPE_AUDIO */,
    'Video': 0 /* AVMediaType.AVMEDIA_TYPE_VIDEO */,
    'Subtitle': 3 /* AVMediaType.AVMEDIA_TYPE_SUBTITLE */,
    'Attachment': 4 /* AVMediaType.AVMEDIA_TYPE_ATTACHMENT */,
    'Data': 2 /* AVMediaType.AVMEDIA_TYPE_DATA */
};
const disposition2AVDisposition = {
    'default': 1 /* AVDisposition.DEFAULT */,
    'dub': 2 /* AVDisposition.DUB */,
    'original': 4 /* AVDisposition.ORIGINAL */,
    'comment': 8 /* AVDisposition.COMMENT */,
    'lyrics': 16 /* AVDisposition.LYRICS */,
    'karaoke': 32 /* AVDisposition.KARAOKE */,
    'forced': 64 /* AVDisposition.FORCED */,
    'hearing impaired': 128 /* AVDisposition.HEARING_IMPAIRED */,
    'visual impaired': 256 /* AVDisposition.VISUAL_IMPAIRED */,
    'clean effects': 512 /* AVDisposition.CLEAN_EFFECTS */,
    'attached pic': 1024 /* AVDisposition.ATTACHED_PIC */,
    'timed thumbnails': 2048 /* AVDisposition.TIMED_THUMBNAILS */,
    'captions': 65536 /* AVDisposition.CAPTIONS */,
    'descriptions': 131072 /* AVDisposition.DESCRIPTIONS */,
    'metadata': 262144 /* AVDisposition.METADATA */,
    'dependent': 524288 /* AVDisposition.DEPENDENT */,
    'still image': 1048576 /* AVDisposition.STILL_IMAGE */
};


/***/ }),

/***/ "./src/avutil/struct/audiosample.ts":
/*!******************************************!*\
  !*** ./src/avutil/struct/audiosample.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVChannelLayout: () => (/* binding */ AVChannelLayout)
/* harmony export */ });
/* unused harmony export AVChannelCustom */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


class AVChannelCustom {
    id;
    name;
    opaque;
}
(function (prototype) {
    var map = new Map();
    map.set("id", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("name", { 0: 4, 1: 0, 2: 0, 3: 1, 4: 16, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 24);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(AVChannelCustom.prototype);
class AVChannelLayout {
    /**
     * Channel order used in this layout.
     * This is a mandatory field.
     */
    order;
    /**
     * Number of channels in this layout. Mandatory field.
     */
    nbChannels;
    /**
     * Details about which channels are present in this layout.
     * For AV_CHANNEL_ORDER_UNSPEC, this field is undefined and must not be
     * used.
     */
    u;
    /**
     * For some private data of the user.
     */
    opaque;
}
(function (prototype) {
    var map = new Map();
    map.set("order", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("nbChannels", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("u", { 0: (function (prototype) {
            var map = new Map();
            map.set("mask", { 0: 10, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
            map.set("map", { 0: AVChannelCustom, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
            (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
            (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 8);
            (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 8);
            (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
            return prototype;
        })({}), 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 24);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(AVChannelLayout.prototype);


/***/ }),

/***/ "./src/avutil/struct/avbuffer.ts":
/*!***************************************!*\
  !*** ./src/avutil/struct/avbuffer.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVBufferRef: () => (/* binding */ AVBufferRef)
/* harmony export */ });
/* unused harmony exports AVBuffer, AVBufferPool, BufferPoolEntry */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../cheap/thread/mutex.ts */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");
var cheap__BufferPoolEntry__16;



/*
 * libmedia AVBuffer defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */

class AVBuffer {
    /**
     * data described by this buffer
     */
    data = 0;
    /**
     * size of data in bytes
     */
    size = 0;
    /**
     *  number of existing AVBufferRef instances referring to this buffer
     */
    refcount = 0;
    /**
     * a callback for freeing the data
     */
    free = 0;
    /**
     * an opaque pointer, to be used by the freeing callback
     */
    opaque = 0;
    /**
     * A combination of AV_BUFFER_FLAG_*
     */
    flags = 0 /* AVBufferFlags.NONE */;
    /**
     * A combination of BUFFER_FLAG_*
     */
    flagsInternal = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("refcount", { 0: 9, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("free", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("flags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    map.set("flagsInternal", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 28);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(AVBuffer.prototype);
function avbufferDefaultFree(opaque, data) {
    (0,_util_mem__WEBPACK_IMPORTED_MODULE_2__.avFree)(data);
}
class AVBufferRef {
    buffer = 0;
    /**
     * The data buffer. It is considered writable if and only if
     * this is the only reference to the buffer, in which case
     * av_buffer_is_writable() returns 1.
     */
    data = 0;
    /**
     * Size of data in bytes.
     */
    size = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("buffer", { 0: AVBuffer, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 12);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(AVBufferRef.prototype);
class AVBufferPool {
    mutex;
    pool = 0;
    /**
     *  number of existing AVBufferRef instances referring to this buffer
     */
    refcount = 0;
    /**
     * Size of data in bytes.
     */
    size = 0;
    /**
     * an opaque pointer, to be used by the freeing callback
     */
    opaque = 0;
    alloc = 0;
    alloc2 = 0;
    poolFree = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("mutex", { 0: _cheap_thread_mutex_ts__WEBPACK_IMPORTED_MODULE_3__.Mutex, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("pool", { 0: cheap__BufferPoolEntry__16, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("refcount", { 0: 9, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("alloc", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    map.set("alloc2", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("poolFree", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 28, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 32);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(AVBufferPool.prototype);
class BufferPoolEntry {
    data = 0;
    /**
     * an opaque pointer, to be used by the freeing callback
     */
    opaque = 0;
    /**
     * a callback for freeing the data
     */
    free = 0;
    pool = 0;
    next = 0;
    /*
     * An AVBuffer structure to (re)use as AVBuffer for subsequent uses
     * of this BufferPoolEntry.
     */
    buffer;
}
(function (prototype) {
    var map = new Map();
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("free", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("pool", { 0: AVBufferPool, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("next", { 0: BufferPoolEntry, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("buffer", { 0: AVBuffer, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 48);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(BufferPoolEntry.prototype);
cheap__BufferPoolEntry__16 = BufferPoolEntry;


/***/ }),

/***/ "./src/avutil/struct/avcodecparameters.ts":
/*!************************************************!*\
  !*** ./src/avutil/struct/avcodecparameters.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AVCodecParameters)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _avpacket_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./avpacket.ts */ "./src/avutil/struct/avpacket.ts");
/* harmony import */ var _rational__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rational */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _audiosample_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./audiosample.ts */ "./src/avutil/struct/audiosample.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var _util_codecparameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/codecparameters */ "./src/avutil/util/codecparameters.ts");





/*
 * libmedia AVCodecParameters defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




/**
 * FFmpeg AVCodecParameters 定义
 */
class AVCodecParameters {
    /**
     * General type of the encoded data.
     */
    codecType = -1 /* AVMediaType.AVMEDIA_TYPE_UNKNOWN */;
    /**
     * Specific type of the encoded data (the codec used).
     */
    codecId = 0 /* AVCodecID.AV_CODEC_ID_NONE */;
    /**
     * Additional information about the codec (corresponds to the AVI FOURCC).
     */
    codecTag = 0;
    /**
     * Extra binary data needed for initializing the decoder, codec-dependent.
     *
     * Must be allocated with av_malloc() and will be freed by
     * avcodec_parameters_free(). The allocated size of extradata must be at
     * least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding
     * bytes zeroed.
     */
    extradata = 0;
    extradataSize = 0;
    /**
     * Additional data associated with the entire stream.
     *
     * Should be allocated with av_packet_side_data_new() or
     * av_packet_side_data_add(), and will be freed by avcodec_parameters_free().
     */
    codedSideData = 0;
    /**
     * Amount of entries in @ref coded_side_data.
     */
    nbCodedSideData = 0;
    /**
     * - video: the pixel format, the value corresponds to enum AVPixelFormat.
     * - audio: the sample format, the value corresponds to enum AVSampleFormat.
     */
    format = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    /**
     * The average bitrate of the encoded data (in bits per second).
     */
    bitRate = BigInt(0);
    /**
     * The number of bits per sample in the codedwords.
     *
     * This is basically the bitrate per sample. It is mandatory for a bunch of
     * formats to actually decode them. It's the number of bits for one sample in
     * the actual coded bitstream.
     *
     * This could be for example 4 for ADPCM
     * For PCM formats this matches bits_per_raw_sample
     * Can be 0
     */
    bitsPerCodedSample = 0;
    /**
     * This is the number of valid bits in each output sample. If the
     * sample format has more bits, the least significant bits are additional
     * padding bits, which are always 0. Use right shifts to reduce the sample
     * to its actual size. For example, audio formats with 24 bit samples will
     * have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32.
     * To get the original sample use "(int32_t)sample >> 8"."
     *
     * For ADPCM this might be 12 or 16 or similar
     * Can be 0
     */
    bitsPerRawSample = 0;
    /**
     * Codec-specific bitstream restrictions that the stream conforms to.
     */
    profile = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    level = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    /**
     * Video only. The dimensions of the video frame in pixels.
     */
    width = 0;
    height = 0;
    /**
     * Video only. The aspect ratio (width / height) which a single pixel
     * should have when displayed.
     *
     * When the aspect ratio is unknown / undefined, the numerator should be
     * set to 0 (the denominator may have any value).
     */
    sampleAspectRatio = new _rational__WEBPACK_IMPORTED_MODULE_1__.Rational({ den: 1, num: 1 });
    /**
     * Video only. Number of frames per second, for streams with constant frame
     * durations. Should be set to { 0, 1 } when some frames have differing
     * durations or if the value is not known.
     *
     * @note This field correponds to values that are stored in codec-level
     * headers and is typically overridden by container/transport-layer
     * timestamps, when available. It should thus be used only as a last resort,
     * when no higher-level timing information is available.
     */
    framerate = new _rational__WEBPACK_IMPORTED_MODULE_1__.Rational({ den: 1, num: 0 });
    /**
     * Video only. The order of the fields in interlaced video.
     */
    fieldOrder = 0 /* AVFieldOrder.AV_FIELD_UNKNOWN */;
    /**
     * Video only. Additional colorspace characteristics.
     */
    colorRange = 0 /* AVColorRange.AVCOL_RANGE_UNSPECIFIED */;
    colorPrimaries = 2 /* AVColorPrimaries.AVCOL_PRI_UNSPECIFIED */;
    colorTrc = 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */;
    colorSpace = 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */;
    chromaLocation = 0 /* AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED */;
    /**
     * Video only. Number of delayed frames.
     */
    videoDelay = 0;
    /**
     * Audio only. The channel layout and number of channels.
     */
    chLayout;
    /**
     * Audio only. The number of audio samples per second.
     */
    sampleRate = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    /**
     * Audio only. The number of bytes per coded audio frame, required by some
     * formats.
     *
     * Corresponds to nBlockAlign in WAVEFORMATEX.
     */
    blockAlign = 0;
    /**
     * Audio only. Audio frame size, if known. Required by some formats to be static.
     */
    frameSize = 0;
    /**
     * Audio only. The amount of padding (in samples) inserted by the encoder at
     * the beginning of the audio. I.e. this number of leading decoded samples
     * must be discarded by the caller to get the original audio without leading
     * padding.
     */
    initialPadding = 0;
    /**
     * Audio only. The amount of padding (in samples) appended by the encoder to
     * the end of the audio. I.e. this number of decoded samples must be
     * discarded by the caller from the end of the stream to get the original
     * audio without any trailing padding.
     */
    trailingPadding = 0;
    /**
     * Audio only. Number of samples to skip after a discontinuity.
     */
    seekPreroll = 0;
    /**
     * 码流格式
     * 对于 h264/h265 标记是 annexb 还是 avcc 格式
     */
    bitFormat = 0;
    destroy() {
        (0,_util_codecparameters__WEBPACK_IMPORTED_MODULE_2__.freeCodecParameters)(this[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress]);
        this[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress] = 0;
    }
}
(function (prototype) {
    var map = new Map();
    map.set("codecType", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("codecId", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("codecTag", { 0: 8, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("extradata", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("extradataSize", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("codedSideData", { 0: _avpacket_ts__WEBPACK_IMPORTED_MODULE_4__.AVPacketSideData, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 20, 8: 0 });
    map.set("nbCodedSideData", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("format", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 28, 8: 0 });
    map.set("bitRate", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 32, 8: 0 });
    map.set("bitsPerCodedSample", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 40, 8: 0 });
    map.set("bitsPerRawSample", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 44, 8: 0 });
    map.set("profile", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 48, 8: 0 });
    map.set("level", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 52, 8: 0 });
    map.set("width", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 56, 8: 0 });
    map.set("height", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 60, 8: 0 });
    map.set("sampleAspectRatio", { 0: _rational__WEBPACK_IMPORTED_MODULE_1__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 64, 8: 0 });
    map.set("framerate", { 0: _rational__WEBPACK_IMPORTED_MODULE_1__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 72, 8: 0 });
    map.set("fieldOrder", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 80, 8: 0 });
    map.set("colorRange", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 84, 8: 0 });
    map.set("colorPrimaries", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 88, 8: 0 });
    map.set("colorTrc", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 92, 8: 0 });
    map.set("colorSpace", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 96, 8: 0 });
    map.set("chromaLocation", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 100, 8: 0 });
    map.set("videoDelay", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 104, 8: 0 });
    map.set("chLayout", { 0: _audiosample_ts__WEBPACK_IMPORTED_MODULE_5__.AVChannelLayout, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 112, 8: 0 });
    map.set("sampleRate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 136, 8: 0 });
    map.set("blockAlign", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 140, 8: 0 });
    map.set("frameSize", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 144, 8: 0 });
    map.set("initialPadding", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 148, 8: 0 });
    map.set("trailingPadding", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 152, 8: 0 });
    map.set("seekPreroll", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 156, 8: 0 });
    map.set("bitFormat", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 160, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructLength, 168);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_6__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructKeysMeta, map);
})(AVCodecParameters.prototype);


/***/ }),

/***/ "./src/avutil/struct/avdict.ts":
/*!*************************************!*\
  !*** ./src/avutil/struct/avdict.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVDictionary: () => (/* binding */ AVDictionary)
/* harmony export */ });
/* unused harmony export AVDictionaryEntry */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


/*
 * libmedia AVDictionary defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class AVDictionaryEntry {
    key = 0;
    value = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("key", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("value", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(AVDictionaryEntry.prototype);
class AVDictionary {
    count = 0;
    elems = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("count", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("elems", { 0: AVDictionaryEntry, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(AVDictionary.prototype);


/***/ }),

/***/ "./src/avutil/struct/avframe.ts":
/*!**************************************!*\
  !*** ./src/avutil/struct/avframe.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AV_NUM_DATA_POINTERS: () => (/* binding */ AV_NUM_DATA_POINTERS)
/* harmony export */ });
/* unused harmony exports AVFrameSideData, AVMasteringDisplayMetadata, AVContentLightMetadata, default, AVFrameRef */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _avdict_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./avdict.ts */ "./src/avutil/struct/avdict.ts");
/* harmony import */ var _avbuffer_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./avbuffer.ts */ "./src/avutil/struct/avbuffer.ts");
/* harmony import */ var _rational_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rational */ "./src/avutil/struct/rational.ts");
/* harmony import */ var cheap_std_unmake__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/std/unmake */ "./src/cheap/std/unmake.ts");
/* harmony import */ var _audiosample_ts__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./audiosample.ts */ "./src/avutil/struct/audiosample.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var _util_avframe__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/avframe */ "./src/avutil/util/avframe.ts");







/*
 * libmedia AVFrame defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */




const AV_NUM_DATA_POINTERS = 8;
class AVFrameSideData {
    type = 0;
    data = 0;
    size = 0;
    metadata = 0;
    buf = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("type", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("metadata", { 0: _avdict_ts__WEBPACK_IMPORTED_MODULE_0__.AVDictionary, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    map.set("buf", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_1__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructLength, 20);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructKeysMeta, map);
})(AVFrameSideData.prototype);
class AVMasteringDisplayMetadata {
    /**
     * CIE 1931 xy chromaticity coords of color primaries (r, g, b order).
     */
    displayPrimaries;
    /**
     * CIE 1931 xy chromaticity coords of white point.
     */
    whitePoint;
    /**
     * Min luminance of mastering display (cd/m^2).
     */
    minLuminance;
    /**
     * Max luminance of mastering display (cd/m^2).
     */
    maxLuminance;
    /**
     * Flag indicating whether the display primaries (and white point) are set.
     */
    hasPrimaries;
    /**
     * Flag indicating whether the luminance (min_ and max_) have been set.
     */
    hasLuminance;
}
(function (prototype) {
    var map = new Map();
    map.set("displayPrimaries", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational, 1: 0, 2: 0, 3: 1, 4: 6, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("whitePoint", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational, 1: 0, 2: 0, 3: 1, 4: 2, 5: 0, 6: 0, 7: 48, 8: 0 });
    map.set("minLuminance", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 64, 8: 0 });
    map.set("maxLuminance", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 72, 8: 0 });
    map.set("hasPrimaries", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 80, 8: 0 });
    map.set("hasLuminance", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 84, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructLength, 88);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructKeysMeta, map);
})(AVMasteringDisplayMetadata.prototype);
class AVContentLightMetadata {
    /**
     * Max content light level (cd/m^2).
     */
    maxCLL;
    /**
     * Max average light level per frame (cd/m^2).
     */
    maxFALL;
}
(function (prototype) {
    var map = new Map();
    map.set("maxCLL", { 0: 8, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("maxFALL", { 0: 8, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructKeysMeta, map);
})(AVContentLightMetadata.prototype);
/**
 * FFmpeg AVFrame 定义
 */
class AVFrame {
    /**
     * pointer to the picture/channel planes.
     * This might be different from the first allocated byte
     *
     * Some decoders access areas outside 0,0 - width, height, please
     * see avcodec_align_dimensions2(). Some filters and swscale can read
     * up to 16 bytes beyond the planes, if these filters are to be used,
     * then 16 extra bytes must be allocated.
     *
     * NOTE: Except for hwaccel formats, pointers not needed by the format
     * MUST be set to NULL.
     */
    data = new Array(AV_NUM_DATA_POINTERS).fill(0, 0, AV_NUM_DATA_POINTERS);
    /**
     * For video, size in bytes of each picture line.
     * For audio, size in bytes of each plane.
     *
     * For audio, only linesize[0] may be set. For planar audio, each channel
     * plane must be the same size.
     *
     * For video the linesizes should be multiples of the CPUs alignment
     * preference, this is 16 or 32 for modern desktop CPUs.
     * Some code requires such alignment other code can be slower without
     * correct alignment, for yet other it makes no difference.
     *
     * @note The linesize may be larger than the size of usable data -- there
     * may be extra padding present for performance reasons.
     */
    linesize = new Array(AV_NUM_DATA_POINTERS).fill(0, 0, AV_NUM_DATA_POINTERS);
    /**
     * pointers to the data planes/channels.
     *
     * For video, this should simply point to data[].
     *
     * For planar audio, each channel has a separate data pointer, and
     * linesize[0] contains the size of each channel buffer.
     * For packed audio, there is just one data pointer, and linesize[0]
     * contains the total size of the buffer for all channels.
     *
     * Note: Both data and extended_data should always be set in a valid frame,
     * but for planar audio with more channels that can fit in data,
     * extended_data must be used in order to access all channels.
     */
    extendedData = 0;
    /**
     * @name Video dimensions
     * Video frames only. The coded dimensions (in pixels) of the video frame,
     * i.e. the size of the rectangle that contains some well-defined values.
     *
     * @note The part of the frame intended for display/presentation is further
     * restricted by the @ref cropping "Cropping rectangle".
     *
     */
    width = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE;
    height = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE;
    /**
     * number of audio samples (per channel) described by this frame
     */
    nbSamples = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE;
    /**
     * format of the frame, -1 if unknown or unset
     * Values correspond to enum AVPixelFormat for video frames,
     * enum AVSampleFormat for audio)
     */
    format = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE;
    /**
     * 1 -> keyframe, 0-> not
     *
     * @deprecated Use AV_FRAME_FLAG_KEY instead
     */
    keyFrame = 0;
    /**
     * Picture type of the frame.
     */
    pictType = 0 /* AVPictureType.AV_PICTURE_TYPE_NONE */;
    /**
     * Sample aspect ratio for the video frame, 0/1 if unknown/unspecified.
     */
    sampleAspectRatio = new _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational({ den: 1, num: 0 });
    /**
     * Presentation timestamp in time_base units (time when frame should be shown to user).
     */
    pts = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE_BIGINT;
    /**
     * DTS copied from the AVPacket that triggered returning this frame. (if frame threading isn't used)
     * This is also the Presentation time of this AVFrame calculated from
     * only AVPacket.dts values without pts values.
     */
    pktDts = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE_BIGINT;
    /**
     * Time base for the timestamps in this frame.
     * In the future, this field may be set on frames output by decoders or
     * filters, but its value will be by default ignored on input to encoders
     * or filters.
     */
    timeBase;
    /**
     * quality (between 1 (good) and FF_LAMBDA_MAX (bad))
     */
    quality = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE;
    /**
     * Frame owner's private data.
     *
     * This field may be set by the code that allocates/owns the frame data.
     * It is then not touched by any library functions, except:
     * - it is copied to other references by av_frame_copy_props() (and hence by
     *   av_frame_ref());
     * - it is set to NULL when the frame is cleared by av_frame_unref()
     * - on the caller's explicit request. E.g. libavcodec encoders/decoders
     *   will copy this field to/from @ref AVPacket "AVPackets" if the caller sets
     *   @ref AV_CODEC_FLAG_COPY_OPAQUE.
     *
     * @see opaque_ref the reference-counted analogue
     */
    opaque = 0;
    /**
     * Number of fields in this frame which should be repeated, i.e. the total
     * duration of this frame should be repeat_pict + 2 normal field durations.
     *
     * For interlaced frames this field may be set to 1, which signals that this
     * frame should be presented as 3 fields: beginning with the first field (as
     * determined by AV_FRAME_FLAG_TOP_FIELD_FIRST being set or not), followed
     * by the second field, and then the first field again.
     *
     * For progressive frames this field may be set to a multiple of 2, which
     * signals that this frame's duration should be (repeat_pict + 2) / 2
     * normal frame durations.
     *
     * @note This field is computed from MPEG2 repeat_first_field flag and its
     * associated flags, H.264 pic_struct from picture timing SEI, and
     * their analogues in other codecs. Typically it should only be used when
     * higher-layer timing information is not available.
     */
    repeatPict = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE;
    /**
     * The content of the picture is interlaced.
     *
     * @deprecated Use AV_FRAME_FLAG_INTERLACED instead
     */
    interlacedFrame = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE;
    /**
     * If the content is interlaced, is top field displayed first.
     *
     * @deprecated Use AV_FRAME_FLAG_TOP_FIELD_FIRST instead
     */
    topFieldFirst = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE;
    /**
     * Tell user application that palette has changed from previous frame.
     *  @deprecated
     */
    paletteHasChanged = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE;
    /**
     * Sample rate of the audio data.
     */
    sampleRate = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE;
    /**
     * AVBuffer references backing the data for this frame. If all elements of
     * this array are NULL, then this frame is not reference counted. This array
     * must be filled contiguously -- if buf[i] is non-NULL then buf[j] must
     * also be non-NULL for all j < i.
     *
     * There may be at most one AVBuffer per data plane, so for video this array
     * always contains all the references. For planar audio with more than
     * AV_NUM_DATA_POINTERS channels, there may be more buffers than can fit in
     * this array. Then the extra AVBufferRef pointers are stored in the
     * extended_buf array.
     */
    buf = new Array(AV_NUM_DATA_POINTERS).fill(0, 0, AV_NUM_DATA_POINTERS);
    /**
     * For planar audio which requires more than AV_NUM_DATA_POINTERS
     * AVBufferRef pointers, this array will hold all the references which
     * cannot fit into AVFrame.buf.
     *
     * Note that this is different from AVFrame.extended_data, which always
     * contains all the pointers. This array only contains the extra pointers,
     * which cannot fit into AVFrame.buf.
     *
     * This array is always allocated using av_malloc() by whoever constructs
     * the frame. It is freed in av_frame_unref().
     */
    extendedBuf = 0;
    /**
     * Number of elements in extended_buf.
     */
    nbExtendedBuf = 0;
    sideData = 0;
    nbSideData = 0;
    /**
     * Frame flags, a combination of @ref lavu_frame_flags
     */
    flags = 0 /* AVFrameFlags.AV_FRAME_FLAG_NONE */;
    /**
     * MPEG vs JPEG YUV range.
     * - encoding: Set by user
     * - decoding: Set by libavcodec
     */
    colorRange = 0 /* AVColorRange.AVCOL_RANGE_UNSPECIFIED */;
    colorPrimaries = 2 /* AVColorPrimaries.AVCOL_PRI_UNSPECIFIED */;
    colorTrc = 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */;
    /**
     * YUV colorspace type.
     * - encoding: Set by user
     * - decoding: Set by libavcodec
     */
    colorSpace = 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */;
    chromaLocation = 0 /* AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED */;
    /**
     * frame timestamp estimated using various heuristics, in stream time base
     * - encoding: unused
     * - decoding: set by libavcodec, read by user.
     */
    bestEffortTimestamp = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE_BIGINT;
    /**
     * reordered pos from the last AVPacket that has been input into the decoder
     * - encoding: unused
     * - decoding: Read by user.
     * @deprecated use AV_CODEC_FLAG_COPY_OPAQUE to pass through arbitrary user
     *             data from packets to frames
     */
    pktPos = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE_BIGINT;
    /**
     * metadata.
     * - encoding: Set by user.
     * - decoding: Set by libavcodec.
     */
    metadata = 0;
    /**
     * decode error flags of the frame, set to a combination of
     * FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there
     * were errors during the decoding.
     * - encoding: unused
     * - decoding: set by libavcodec, read by user.
     */
    decodeErrorFlags = 0 /* FFDecodeError.NONE */;
    /**
     * size of the corresponding packet containing the compressed
     * frame.
     * It is set to a negative value if unknown.
     * - encoding: unused
     * - decoding: set by libavcodec, read by user.
     * @deprecated use AV_CODEC_FLAG_COPY_OPAQUE to pass through arbitrary user
     *             data from packets to frames
     */
    pktSize = _constant__WEBPACK_IMPORTED_MODULE_5__.NOPTS_VALUE;
    /**
     * For hwaccel-format frames, this should be a reference to the
     * AVHWFramesContext describing the frame.
     */
    hwFramesCtx = 0;
    /**
     * AVBufferRef for free use by the API user. FFmpeg will never check the
     * contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when
     * the frame is unreferenced. av_frame_copy_props() calls create a new
     * reference with av_buffer_ref() for the target frame's opaque_ref field.
     *
     * This is unrelated to the opaque field, although it serves a similar
     * purpose.
     */
    opaqueRef = 0;
    /**
     * @anchor cropping
     * @name Cropping
     * Video frames only. The number of pixels to discard from the the
     * top/bottom/left/right border of the frame to obtain the sub-rectangle of
     * the frame intended for presentation.
     */
    cropTop = 0;
    cropBottom = 0;
    cropLeft = 0;
    cropRight = 0;
    /**
     * AVBufferRef for internal use by a single libav* library.
     * Must not be used to transfer data between libraries.
     * Has to be NULL when ownership of the frame leaves the respective library.
     *
     * Code outside the FFmpeg libs should never check or change the contents of the buffer ref.
     *
     * FFmpeg calls av_buffer_unref() on it when the frame is unreferenced.
     * av_frame_copy_props() calls create a new reference with av_buffer_ref()
     * for the target frame's private_ref field.
     */
    privateRef = 0;
    /**
     * Channel layout of the audio data.
     */
    chLayout;
    /**
     * Duration of the frame, in the same units as pts. 0 if unknown.
     */
    duration = BigInt(0);
    close() {
        (0,_util_avframe__WEBPACK_IMPORTED_MODULE_6__.unrefAVFrame)(this[cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructAddress]);
        (0,cheap_std_unmake__WEBPACK_IMPORTED_MODULE_7__["default"])(this);
    }
}
(function (prototype) {
    var map = new Map();
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 1, 4: 8, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("linesize", { 0: 15, 1: 0, 2: 0, 3: 1, 4: 8, 5: 0, 6: 0, 7: 32, 8: 0 });
    map.set("extendedData", { 0: 2, 1: 1, 2: 2, 3: 0, 4: 0, 5: 0, 6: 0, 7: 64, 8: 0 });
    map.set("width", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 68, 8: 0 });
    map.set("height", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 72, 8: 0 });
    map.set("nbSamples", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 76, 8: 0 });
    map.set("format", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 80, 8: 0 });
    map.set("keyFrame", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 84, 8: 0 });
    map.set("pictType", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 88, 8: 0 });
    map.set("sampleAspectRatio", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 92, 8: 0 });
    map.set("pts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 104, 8: 0 });
    map.set("pktDts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 112, 8: 0 });
    map.set("timeBase", { 0: _rational_ts__WEBPACK_IMPORTED_MODULE_4__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 120, 8: 0 });
    map.set("quality", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 128, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 132, 8: 0 });
    map.set("repeatPict", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 136, 8: 0 });
    map.set("interlacedFrame", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 140, 8: 0 });
    map.set("topFieldFirst", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 144, 8: 0 });
    map.set("paletteHasChanged", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 148, 8: 0 });
    map.set("sampleRate", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 152, 8: 0 });
    map.set("buf", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_1__.AVBufferRef, 1: 1, 2: 1, 3: 1, 4: 8, 5: 0, 6: 0, 7: 156, 8: 0 });
    map.set("extendedBuf", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_1__.AVBufferRef, 1: 1, 2: 2, 3: 0, 4: 0, 5: 0, 6: 0, 7: 188, 8: 0 });
    map.set("nbExtendedBuf", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 192, 8: 0 });
    map.set("sideData", { 0: AVFrameSideData, 1: 1, 2: 2, 3: 0, 4: 0, 5: 0, 6: 0, 7: 196, 8: 0 });
    map.set("nbSideData", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 200, 8: 0 });
    map.set("flags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 204, 8: 0 });
    map.set("colorRange", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 208, 8: 0 });
    map.set("colorPrimaries", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 212, 8: 0 });
    map.set("colorTrc", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 216, 8: 0 });
    map.set("colorSpace", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 220, 8: 0 });
    map.set("chromaLocation", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 224, 8: 0 });
    map.set("bestEffortTimestamp", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 232, 8: 0 });
    map.set("pktPos", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 240, 8: 0 });
    map.set("metadata", { 0: _avdict_ts__WEBPACK_IMPORTED_MODULE_0__.AVDictionary, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 248, 8: 0 });
    map.set("decodeErrorFlags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 252, 8: 0 });
    map.set("pktSize", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 256, 8: 0 });
    map.set("hwFramesCtx", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_1__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 260, 8: 0 });
    map.set("opaqueRef", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_1__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 264, 8: 0 });
    map.set("cropTop", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 268, 8: 0 });
    map.set("cropBottom", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 272, 8: 0 });
    map.set("cropLeft", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 276, 8: 0 });
    map.set("cropRight", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 280, 8: 0 });
    map.set("privateRef", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_1__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 284, 8: 0 });
    map.set("chLayout", { 0: _audiosample_ts__WEBPACK_IMPORTED_MODULE_8__.AVChannelLayout, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 288, 8: 0 });
    map.set("duration", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 312, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructLength, 320);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructKeysMeta, map);
})(AVFrame.prototype);
class AVFrameRef extends AVFrame {
    refCount;
}
(function (prototype) {
    var map = new Map();
    map.set("refCount", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 320, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructLength, 328);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructKeysMeta, map);
})(AVFrameRef.prototype);


/***/ }),

/***/ "./src/avutil/struct/avpacket.ts":
/*!***************************************!*\
  !*** ./src/avutil/struct/avpacket.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AVPacketSideData: () => (/* binding */ AVPacketSideData)
/* harmony export */ });
/* unused harmony exports default, AVPacketRef */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _avbuffer_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./avbuffer.ts */ "./src/avutil/struct/avbuffer.ts");
/* harmony import */ var _rational__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rational */ "./src/avutil/struct/rational.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");






class AVPacketSideData {
    data = 0;
    size = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    type = -1 /* AVPacketSideDataType.AV_PKT_DATA_UNKNOWN */;
}
(function (prototype) {
    var map = new Map();
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("type", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructLength, 12);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructKeysMeta, map);
})(AVPacketSideData.prototype);
/**
 * FFmpeg AVPacket 定义
 */
class AVPacket {
    /**
     * A reference to the reference-counted buffer where the packet data is
     * stored.
     * May be NULL, then the packet data is not reference-counted.
     */
    buf = 0;
    /**
     * Presentation timestamp in AVStream->time_base units; the time at which
     * the decompressed packet will be presented to the user.
     * Can be AV_NOPTS_VALUE if it is not stored in the file.
     * pts MUST be larger or equal to dts as presentation cannot happen before
     * decompression, unless one wants to view hex dumps. Some formats misuse
     * the terms dts and pts/cts to mean something different. Such timestamps
     * must be converted to true pts/dts before they are stored in AVPacket.
     */
    pts = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE_BIGINT;
    /**
     * Decompression timestamp in AVStream->time_base units; the time at which
     * the packet is decompressed.
     * Can be AV_NOPTS_VALUE if it is not stored in the file.
     */
    dts = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE_BIGINT;
    data = 0;
    size = 0;
    streamIndex = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE;
    /**
     * A combination of @AVPacketFlags values
     */
    flags = 0;
    /**
     * Additional packet data that can be provided by the container.
     * Packet can contain several types of side information.
     */
    sideData = 0;
    sideDataElems = 0;
    /**
     * Duration of this packet in AVStream->time_base units, 0 if unknown.
     * Equals next_pts - this_pts in presentation order.
     */
    duration = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE_BIGINT;
    pos = _constant__WEBPACK_IMPORTED_MODULE_0__.NOPTS_VALUE_BIGINT;
    /**
     * for some private data of the user
     */
    opaque = 0;
    /**
     * AVBufferRef for free use by the API user. FFmpeg will never check the
     * contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when
     * the packet is unreferenced. av_packet_copy_props() calls create a new
     * reference with av_buffer_ref() for the target packet's opaque_ref field.
     *
     * This is unrelated to the opaque field, although it serves a similar
     * purpose.
     */
    opaqueRef = 0;
    /**
     * 编码时间基
     *
     * 封装时用户设置
     */
    timeBase = new _rational__WEBPACK_IMPORTED_MODULE_3__.Rational({ den: _constant__WEBPACK_IMPORTED_MODULE_0__.AV_TIME_BASE, num: 1 });
    /**
     * 码流格式
     * 对于 h264/h265 标记是 annexb 还是 avcc 格式
     */
    bitFormat = 0;
}
(function (prototype) {
    var map = new Map();
    map.set("buf", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_4__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("pts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("dts", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 16, 8: 0 });
    map.set("data", { 0: 2, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 24, 8: 0 });
    map.set("size", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 28, 8: 0 });
    map.set("streamIndex", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 32, 8: 0 });
    map.set("flags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 36, 8: 0 });
    map.set("sideData", { 0: AVPacketSideData, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 40, 8: 0 });
    map.set("sideDataElems", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 44, 8: 0 });
    map.set("duration", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 48, 8: 0 });
    map.set("pos", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 56, 8: 0 });
    map.set("opaque", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 64, 8: 0 });
    map.set("opaqueRef", { 0: _avbuffer_ts__WEBPACK_IMPORTED_MODULE_4__.AVBufferRef, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 68, 8: 0 });
    map.set("timeBase", { 0: _rational__WEBPACK_IMPORTED_MODULE_3__.Rational, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 72, 8: 0 });
    map.set("bitFormat", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 80, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructLength, 88);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructKeysMeta, map);
})(AVPacket.prototype);
class AVPacketRef extends AVPacket {
    refCount;
}
(function (prototype) {
    var map = new Map();
    map.set("refCount", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 88, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructLength, 96);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructKeysMeta, map);
})(AVPacketRef.prototype);


/***/ }),

/***/ "./src/avutil/struct/rational.ts":
/*!***************************************!*\
  !*** ./src/avutil/struct/rational.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Rational: () => (/* binding */ Rational)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");


/*
 * libmedia Rational defined
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
class Rational {
    /**
     * 分子
     */
    num = 1;
    /**
     * 分母
     */
    den = 1;
    constructor(init) {
        if (init) {
            this.den = init.den;
            this.num = init.num;
        }
    }
}
(function (prototype) {
    var map = new Map();
    map.set("num", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("den", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(Rational.prototype);


/***/ }),

/***/ "./src/avutil/util/av1syntax.ts":
/*!**************************************!*\
  !*** ./src/avutil/util/av1syntax.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   f: () => (/* binding */ f),
/* harmony export */   leb128: () => (/* binding */ leb128),
/* harmony export */   uvlc: () => (/* binding */ uvlc)
/* harmony export */ });
/* unused harmony exports le, su, ns, L, NS */
/*
 * libmedia av1 syntax util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function f(bitReader, n) {
    let x = 0;
    for (let i = 0; i < n; i++) {
        x = 2 * x + bitReader.readU1();
    }
    return x;
}
function uvlc(bitReader) {
    let leadingZeros = 0;
    while (true) {
        let done = f(bitReader, 1);
        if (done) {
            break;
        }
        leadingZeros++;
    }
    if (leadingZeros >= 32) {
        return (1) - 1;
    }
    const value = f(bitReader, leadingZeros);
    return value + (1 << leadingZeros) - 1;
}
function le(bitReader, n) {
    let t = 0;
    for (let i = 0; i < n; i++) {
        let byte = f(bitReader, 8);
        t += (byte << (i * 8));
    }
    return t;
}
function leb128(bitReader) {
    let value = 0;
    let Leb128Bytes = 0;
    for (let i = 0; i < 8; i++) {
        let leb128Byte_ = f(bitReader, 8);
        value |= ((leb128Byte_ & 0x7f) << (i * 7));
        Leb128Bytes += 1;
        if (!(leb128Byte_ & 0x80)) {
            break;
        }
    }
    return value;
}
function su(bitReader, n) {
    let value = f(bitReader, n);
    let signMask = 1 << (n - 1);
    if (value & signMask) {
        value = value - 2 * signMask;
    }
    return value;
}
function ns(bitReader, n) {
    let w = Math.floor(Math.log2(n)) + 1;
    let m = (1 << w) - n;
    let v = f(bitReader, w - 1);
    if (v < m) {
        return v;
    }
    let extraBit = f(bitReader, 1);
    return (v << 1) - m + extraBit;
}
function L(bitReader, n) {
    let x = 0;
    for (let i = 0; i < n; i++) {
        x = 2 * x + bitReader.readU1();
    }
    return x;
}
function NS(bitReader, n) {
    let w = Math.floor(Math.log2(n)) + 1;
    let m = (1 << w) - n;
    let v = L(bitReader, w - 1);
    if (v < m) {
        return v;
    }
    let extraBit = L(bitReader, 1);
    return (v << 1) - m + extraBit;
}


/***/ }),

/***/ "./src/avutil/util/avbuffer.ts":
/*!*************************************!*\
  !*** ./src/avutil/util/avbuffer.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   avbufferAlloc: () => (/* binding */ avbufferAlloc),
/* harmony export */   avbufferCreate: () => (/* binding */ avbufferCreate),
/* harmony export */   avbufferRealloc: () => (/* binding */ avbufferRealloc),
/* harmony export */   avbufferRef: () => (/* binding */ avbufferRef),
/* harmony export */   avbufferReplace: () => (/* binding */ avbufferReplace),
/* harmony export */   avbufferUnref: () => (/* binding */ avbufferUnref)
/* harmony export */ });
/* unused harmony exports bufferCreate, avbufferAllocz, bufferReplace, avbufferIsWritable, avbufferGetOpaque, avbufferGetRefCount, avbufferMakeWritable, bufferPoolFlush, bufferPoolFree, poolReleaseBuffer */
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var cheap_stack__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/stack */ "./src/cheap/stack.ts");





/*
 * libmedia avbuffer util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */






const BUFFER_FLAG_REALLOCATABLE = 1;
function bufferCreate(buf, data, size, free = 0, opaque = 0, flags = 0) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](buf, data);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](buf + 4, size);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](buf + 12, free);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](buf + 16, opaque);
    cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_1__.store(buf + 8, 1, 9, 2);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](buf + 20, flags);
    const ref = (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avMallocz)(12);
    if (!ref) {
        return 0;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](ref, buf);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](ref + 4, data);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](ref + 8, size);
    return ref;
}
function avbufferCreate(data, size, free = 0, opaque = 0, flags = 0) {
    const buf = (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avMallocz)(28);
    if (!buf) {
        return 0;
    }
    const ref = bufferCreate(buf, data, size, free, opaque, flags);
    if (!ref) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFree)(buf);
        return 0;
    }
    return ref;
}
function avbufferAlloc(size) {
    const data = (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avMalloc)(size);
    return avbufferCreate(data, size);
}
function avbufferAllocz(size) {
    const p = avbufferAlloc(size);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](p + 4), 0, size);
    return p;
}
function avbufferRef(buf) {
    const ref = (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avMallocz)(12);
    // @ts-ignore
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memcpy)(ref, buf, 12);
    cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_1__.add(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf) + 8, 1, 9, 2);
    return ref;
}
function bufferReplace(dst, src) {
    const buf = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](dst));
    if (src) {
        // @ts-ignore
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](dst), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](src), 12);
        (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFreep)(src);
    }
    else {
        (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFreep)(dst);
    }
    if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_1__.sub(buf + 8, 1, 9, 2) === 1) {
        const freeAvbuffer = !(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](buf + 24) & 2 /* BufferFlags.BUFFER_FLAG_NO_FREE */);
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf + 16)) {
            poolReleaseBuffer(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf + 16), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf));
        }
        else {
            (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf));
        }
        if (freeAvbuffer) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFree)(buf);
        }
    }
}
function avbufferUnref(buf) {
    if (!buf || !cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf)) {
        return;
    }
    bufferReplace(buf, 0);
}
function avbufferIsWritable(buf) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf) + 20) & 1 /* AVBufferFlags.READONLY */) {
        return 0;
    }
    return cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_1__.load(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf) + 8, 9, 2) === 1 ? 1 : 0;
}
function avbufferGetOpaque(buf) {
    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf) + 16);
}
function avbufferGetRefCount(buf) {
    return cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_1__.load(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf) + 8, 9, 2);
}
function avbufferMakeWritable(pbuf) {
    const buf = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pbuf);
    if (!buf) {
        return -1;
    }
    if (avbufferIsWritable(buf)) {
        return 0;
    }
    const newbuf = avbufferAlloc(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](buf + 8));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](newbuf + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](buf + 8));
    let newbufp = cheap_stack__WEBPACK_IMPORTED_MODULE_5__.malloc(4);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](newbufp, newbuf);
    bufferReplace(pbuf, newbufp);
    cheap_stack__WEBPACK_IMPORTED_MODULE_5__.free(4);
    return 0;
}
function avbufferReplace(pdst, src) {
    const dst = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pdst);
    if (!src) {
        avbufferUnref(pdst);
        return 0;
    }
    if (dst && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](dst + 4) === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](src + 4)) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](dst + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](src + 4));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](dst + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](src + 8));
        return 0;
    }
    const tmp = avbufferRef(src);
    avbufferUnref(pdst);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](pdst, tmp);
    return 0;
}
function avbufferRealloc(pdst, size) {
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pdst)) {
        const data = (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avRealloc)(0, size);
        const buf = avbufferCreate(data, size);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](pdst, buf);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf) + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf) + 24) | BUFFER_FLAG_REALLOCATABLE);
        return 0;
    }
    const ref = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pdst);
    const buf = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](ref);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](ref + 8) === size) {
        return 0;
    }
    if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](buf + 24) & BUFFER_FLAG_REALLOCATABLE)
        || !avbufferIsWritable(ref)
        || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](ref + 4) !== cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf)) {
        let newRef = cheap_stack__WEBPACK_IMPORTED_MODULE_5__.malloc(4);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](newRef, 0);
        const ret = avbufferRealloc(newRef, size);
        if (ret < 0) {
            cheap_stack__WEBPACK_IMPORTED_MODULE_5__.free(4);
            return ret;
        }
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](newRef) + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf), Math.min(size, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[15](buf + 4)));
        bufferReplace(pdst, newRef);
        cheap_stack__WEBPACK_IMPORTED_MODULE_5__.free(4);
        return 0;
    }
    const tmp = (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avRealloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf), size);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](ref + 4, tmp), cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](buf, tmp);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](ref + 8, size), cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[15](buf + 4, size);
    return 0;
}
function bufferPoolFlush(pool) {
    while (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pool + 4)) {
        const buf = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pool + 4);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](pool + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf + 16));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf + 4)) {
            poolReleaseBuffer(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf));
        }
        else {
            (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf));
        }
        (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFree)(buf);
    }
}
function bufferPoolFree(pool) {
    bufferPoolFlush(pool);
    cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_6__.destroy(pool);
    (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFree)(pool);
}
function poolReleaseBuffer(opaque, data) {
    const buf = opaque;
    const pool = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](buf + 12);
    cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_6__.lock(pool);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](buf + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[20](pool + 4));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumWrite[20](pool + 4, buf);
    cheap_thread_mutex__WEBPACK_IMPORTED_MODULE_6__.unlock(pool);
    if (cheap_thread_atomics__WEBPACK_IMPORTED_MODULE_1__.sub(pool + 8, 1, 9, 2) === 1) {
        bufferPoolFree(pool);
    }
}


/***/ }),

/***/ "./src/avutil/util/avdict.ts":
/*!***********************************!*\
  !*** ./src/avutil/util/avdict.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   freeAVDict: () => (/* binding */ freeAVDict)
/* harmony export */ });
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");



function freeAVDict(pm) {
    const m = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](pm);
    if (m) {
        while (cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](m, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) - 1), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) + 1) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFreep)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) * 8);
            (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFreep)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20](m + 4) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](m) * 8 + 4);
        }
        (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFreep)(m + 4);
    }
    (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFreep)(pm);
}


/***/ }),

/***/ "./src/avutil/util/avframe.ts":
/*!************************************!*\
  !*** ./src/avutil/util/avframe.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createAVFrame: () => (/* binding */ createAVFrame),
/* harmony export */   destroyAVFrame: () => (/* binding */ destroyAVFrame),
/* harmony export */   getAVFrameDefault: () => (/* binding */ getAVFrameDefault),
/* harmony export */   getAudioBuffer: () => (/* binding */ getAudioBuffer),
/* harmony export */   getVideoBuffer: () => (/* binding */ getVideoBuffer),
/* harmony export */   refAVFrame: () => (/* binding */ refAVFrame),
/* harmony export */   unrefAVFrame: () => (/* binding */ unrefAVFrame)
/* harmony export */ });
/* unused harmony exports freeSideData, wipeSideData, getAVFrameSideData, getBuffer, copyAVFrameProps, cloneAVFrame */
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _struct_avframe__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../struct/avframe */ "./src/avutil/struct/avframe.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var _avbuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./avbuffer */ "./src/avutil/util/avbuffer.ts");
/* harmony import */ var _avdict__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./avdict */ "./src/avutil/util/avdict.ts");
/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../error */ "./src/avutil/error.ts");
/* harmony import */ var _sample__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./sample */ "./src/avutil/util/sample.ts");
/* harmony import */ var _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var cheap_stack__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! cheap/stack */ "./src/cheap/stack.ts");
/* harmony import */ var _util_common__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../util/common */ "./src/avutil/util/common.ts");
/* harmony import */ var _pixel__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./pixel */ "./src/avutil/util/pixel.ts");






/*
 * libmedia avframe util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */














function createAVFrame() {
    const frame = (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avMallocz)(320);
    getAVFrameDefault(frame);
    return frame;
}
function destroyAVFrame(frame) {
    unrefAVFrame(frame);
    (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avFree)(frame);
}
function freeSideData(ptr) {
    const sideData = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](ptr);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferUnref)(sideData + 16);
    (0,_avdict__WEBPACK_IMPORTED_MODULE_3__.freeAVDict)(sideData + 12);
    (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avFreep)(ptr);
}
function wipeSideData(frame) {
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 200); i++) {
        freeSideData(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 196) + (i * 4));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 200, 0);
    (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avFreep)(frame + 196);
}
function getAVFrameSideData(frame, type) {
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 200); i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 196) + i * 4)) === type) {
            return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 196) + (i * 4));
        }
    }
    return 0;
}
function getAVFrameDefault(frame) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 64) !== frame) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avFreep)(frame + 64);
    }
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memset)(frame, 0, 320);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](frame + 104, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](frame + 112, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](frame + 232, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE_BIGINT);
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](frame + 240, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE_BIGINT);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 256, -1);
    }
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 84, 1);
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 92, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 96, 1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 80, -1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](frame + 64, frame);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 212, 2 /* AVColorPrimaries.AVCOL_PRI_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 216, 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 220, 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 208, 0 /* AVColorRange.AVCOL_RANGE_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 224, 0 /* AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 204, 0);
}
function getVideoBuffer(frame, algin = 0) {
    const desc = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_7__.PixelFormatDescriptorsMap[cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80)];
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_8__.INVALID_ARGUMENT;
    }
    const linesizes = cheap_stack__WEBPACK_IMPORTED_MODULE_9__.malloc(16);
    const sizes = cheap_stack__WEBPACK_IMPORTED_MODULE_9__.malloc(16);
    const planePadding = Math.max(32, algin);
    let ret = 0;
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32)) {
        if (algin <= 0) {
            algin = 32;
        }
        for (let i = 1; i < algin; i += i) {
            ret = (0,_pixel__WEBPACK_IMPORTED_MODULE_10__.pixelFillLinesizes)(frame + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80), (0,_util_common__WEBPACK_IMPORTED_MODULE_11__.alignFunc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 68), i));
            if (ret < 0) {
                defer();
                return ret;
            }
            if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32) & (algin - 1))) {
                break;
            }
        }
        for (let i = 0; i < 4 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32 + 4 * (i)); i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 32 + i * 4, (0,_util_common__WEBPACK_IMPORTED_MODULE_11__.alignFunc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32 + 4 * (i)), algin));
        }
    }
    for (let i = 0; i < 4; i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](linesizes + (i * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32 + 4 * (i)));
    }
    const paddingHeight = (0,_util_common__WEBPACK_IMPORTED_MODULE_11__.alignFunc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 72), 32);
    if ((ret = (0,_pixel__WEBPACK_IMPORTED_MODULE_10__.pixelFillPlaneSizes)(sizes, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80), paddingHeight, linesizes)) < 0) {
        defer();
        return ret;
    }
    let totalSize = 4 * planePadding;
    for (let i = 0; i < 4; i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](sizes + (i * 4)) > _constant__WEBPACK_IMPORTED_MODULE_6__.INT32_MAX - totalSize) {
            _error__WEBPACK_IMPORTED_MODULE_8__.INVALID_ARGUMENT;
        }
        totalSize += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](sizes + (i * 4));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](frame + 156, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferAlloc)(totalSize));
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 156)) {
        unrefAVFrame(frame);
        defer();
        return _error__WEBPACK_IMPORTED_MODULE_8__.NO_MEMORY;
    }
    if ((ret = (0,_pixel__WEBPACK_IMPORTED_MODULE_10__.pixelFillPointer)(frame, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80), paddingHeight, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 156) + 4), linesizes)) < 0) {
        unrefAVFrame(frame);
        defer();
        return ret;
    }
    for (let i = 1; i < 4; i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 4 * (i))) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](frame + i * 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 4 * (i)) + i * planePadding);
        }
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](frame + 64, frame);
    defer();
    return 0;
    function defer() {
        cheap_stack__WEBPACK_IMPORTED_MODULE_9__.free(16);
        cheap_stack__WEBPACK_IMPORTED_MODULE_9__.free(16);
    }
}
function getAudioBuffer(frame, algin) {
    const planar = (0,_sample__WEBPACK_IMPORTED_MODULE_12__.sampleFormatIsPlanar)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80));
    const channels = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 292);
    const planes = planar ? channels : 1;
    let ret = 0;
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32)) {
        ret = (0,_sample__WEBPACK_IMPORTED_MODULE_12__.sampleFormatGetLinesize)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80), channels, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 76), algin);
        if (ret < 0) {
            return ret;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 32, ret);
    }
    if (planes > _struct_avframe__WEBPACK_IMPORTED_MODULE_13__.AV_NUM_DATA_POINTERS) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](frame + 64, (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avMalloc)(planes * 4));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](frame + 188, (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avMalloc)(planes * 4));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 188) || !cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 64)) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avFreep)(frame + 64);
            (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avFreep)(frame + 188);
            return _error__WEBPACK_IMPORTED_MODULE_8__.NO_MEMORY;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](frame + 192, planes - _struct_avframe__WEBPACK_IMPORTED_MODULE_13__.AV_NUM_DATA_POINTERS);
    }
    else {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](frame + 64, frame);
    }
    for (let i = 0; i < Math.min(planes, _struct_avframe__WEBPACK_IMPORTED_MODULE_13__.AV_NUM_DATA_POINTERS); i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](frame + 156 + i * 4, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferAlloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32)));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 156 + 4 * (i))) {
            unrefAVFrame(frame);
            return _error__WEBPACK_IMPORTED_MODULE_8__.NO_MEMORY;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 64) + (i * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 156 + i * 4) + 4)), cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](frame + i * 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 156 + i * 4) + 4));
    }
    for (let i = 0; i < planes - _struct_avframe__WEBPACK_IMPORTED_MODULE_13__.AV_NUM_DATA_POINTERS; i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 188) + (i * 4), (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferAlloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 32)));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 188) + (i * 4))) {
            unrefAVFrame(frame);
            return _error__WEBPACK_IMPORTED_MODULE_8__.NO_MEMORY;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 64) + (i + _struct_avframe__WEBPACK_IMPORTED_MODULE_13__.AV_NUM_DATA_POINTERS), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 188) + i * 4) + 4));
    }
}
function getBuffer(frame, algin) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 80) < 0) {
        return _error__WEBPACK_IMPORTED_MODULE_8__.INVALID_ARGUMENT;
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 68) > 0 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 72) > 0) {
        return getVideoBuffer(frame, algin);
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 76) > 0 && (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[10](frame + 296) || cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 292) > 0)) {
        return getAudioBuffer(frame, algin);
    }
    return _error__WEBPACK_IMPORTED_MODULE_8__.INVALID_ARGUMENT;
}
function refAVFrame(dst, src) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 80, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 80));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 68, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 68));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 72, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 72));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memcpy)(dst + 288, src + 288, 24);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 76, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 76));
    let ret = copyAVFrameProps(dst, src);
    if (ret < 0) {
        return ret;
    }
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 156)) {
        for (let i = 0; i < 8; i++) {
            if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 4 * (i)) || !cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 32 + 4 * (i))) {
                continue;
            }
            let size = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 32 + 4 * (i));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](dst + i * 4, (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avMalloc)(size));
            if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 4 * (i))) {
                unrefAVFrame(dst);
                return _error__WEBPACK_IMPORTED_MODULE_8__.NO_MEMORY;
            }
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 4 * (i)), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 4 * (i)), size);
        }
        return 0;
    }
    for (let i = 0; i < 8; i++) {
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 156 + 4 * (i))) {
            continue;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](dst + 156 + i * 4, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferRef)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 156 + 4 * (i))));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 156 + 4 * (i))) {
            unrefAVFrame(dst);
            return _error__WEBPACK_IMPORTED_MODULE_8__.NO_MEMORY;
        }
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 188)) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](dst + 188, (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avMallocz)(4 * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 192)));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 188)) {
            unrefAVFrame(dst);
            return _error__WEBPACK_IMPORTED_MODULE_8__.NO_MEMORY;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 192, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 192));
        for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 192); i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 188) + (i * 4), (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferRef)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 188) + (i * 4))));
            if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 188) + (i * 4))) {
                unrefAVFrame(dst);
                return _error__WEBPACK_IMPORTED_MODULE_8__.NO_MEMORY;
            }
        }
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 64) !== src) {
        let ch = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 292);
        if (!ch) {
            unrefAVFrame(dst);
            return _error__WEBPACK_IMPORTED_MODULE_8__.INVALID_ARGUMENT;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](dst + 64, (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avMallocz)(4 * ch));
        if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 64)) {
            unrefAVFrame(dst);
            return _error__WEBPACK_IMPORTED_MODULE_8__.NO_MEMORY;
        }
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 64), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 64), 4 * ch);
    }
    else {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](dst + 64, dst);
    }
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memcpy)(dst, src, 32);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memcpy)(dst + 32, src + 32, 32);
    return 0;
}
function unrefAVFrame(frame) {
    wipeSideData(frame);
    for (let i = 0; i < (8); i++) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferUnref)(frame + 156 + i * 4);
    }
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](frame + 192); i++) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferUnref)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](frame + 188) + (i * 4));
    }
    (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avFreep)(frame + 188);
    (0,_avdict__WEBPACK_IMPORTED_MODULE_3__.freeAVDict)(frame + 248);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferUnref)(frame + 260);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferUnref)(frame + 264);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferUnref)(frame + 284);
    getAVFrameDefault(frame);
}
function copyAVFrameProps(dst, src) {
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 84, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 84));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 88, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 88));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_5__.memcpy)(dst + 92, src + 92, 8);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 268, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 268));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 272, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 272));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 276, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 276));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 280, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 280));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](dst + 104, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 104));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 136, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 136));
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 140, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 140));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 144, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 144));
    }
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 148, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 148));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 152, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 152));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](dst + 132, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 132));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](dst + 112, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 112));
    {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](dst + 240, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 240));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 256, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 256));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 128, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 128));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[17](dst + 232, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 232));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 204, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 204));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 252, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 252));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 212, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 212));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 216, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 216));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 220, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 220));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 208, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 208));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[15](dst + 224, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 224));
    let ret = (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferReplace)(dst + 264, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 264));
    ret |= (0,_avbuffer__WEBPACK_IMPORTED_MODULE_2__.avbufferReplace)(dst + 284, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 284));
    return ret;
}
function cloneAVFrame(frame) {
    const ret = createAVFrame();
    refAVFrame(ret, frame);
    return ret;
}


/***/ }),

/***/ "./src/avutil/util/avpacket.ts":
/*!*************************************!*\
  !*** ./src/avutil/util/avpacket.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAVPacketData: () => (/* binding */ addAVPacketData),
/* harmony export */   addAVPacketSideData: () => (/* binding */ addAVPacketSideData),
/* harmony export */   copyAVPacketData: () => (/* binding */ copyAVPacketData),
/* harmony export */   copyAVPacketProps: () => (/* binding */ copyAVPacketProps),
/* harmony export */   createAVPacket: () => (/* binding */ createAVPacket),
/* harmony export */   deleteAVPacketSideData: () => (/* binding */ deleteAVPacketSideData),
/* harmony export */   destroyAVPacket: () => (/* binding */ destroyAVPacket),
/* harmony export */   freeAVPacketSideData: () => (/* binding */ freeAVPacketSideData),
/* harmony export */   getAVPacketData: () => (/* binding */ getAVPacketData),
/* harmony export */   getAVPacketDefault: () => (/* binding */ getAVPacketDefault),
/* harmony export */   getAVPacketSideData: () => (/* binding */ getAVPacketSideData),
/* harmony export */   hasAVPacketSideData: () => (/* binding */ hasAVPacketSideData),
/* harmony export */   refAVPacket: () => (/* binding */ refAVPacket),
/* harmony export */   unrefAVPacket: () => (/* binding */ unrefAVPacket)
/* harmony export */ });
/* unused harmony exports initAVPacketData, copyAVPacketSideData */
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var _avbuffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./avbuffer */ "./src/avutil/util/avbuffer.ts");





/*
 * libmedia avpacket util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */





const AV_INPUT_BUFFER_PADDING_SIZE = 64;
function getAVPacketData(avpacket, safe) {
    return safe ? (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapSafeUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28)) : (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28));
}
function initAVPacketData(avpacket, length) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 24, (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avMalloc)(length));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 28, length);
    return (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.mapUint8Array)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 28));
}
function getAVPacketSideData(avpacket, type) {
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12 + 8) === type) {
            return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + (i * 12);
        }
    }
    return 0;
}
function hasAVPacketSideData(avpacket, type) {
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12 + 8) === type) {
            return true;
        }
    }
    return false;
}
function addAVPacketSideData(avpacket, type, data, length) {
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12 + 8) === type) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12, data);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12 + 4, length);
            return;
        }
    }
    const len = (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44) + 1) * 12;
    const sideData = (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avMallocz)(len);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44)) {
        for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(sideData + (i * 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + (i * 12), 12);
        }
    }
    const ele = sideData + (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44) * 12);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](ele, data);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](ele + 8, type);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](ele + 4, length);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40)) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 40, sideData);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 44, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44) + 1);
}
function deleteAVPacketSideData(avpacket, type) {
    let index = -1;
    for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12 + 8) === type) {
            index = i;
            break;
        }
    }
    if (index > -1) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44) === 1) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40)));
            (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 40, 0);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 44, 0);
        }
        else {
            const len = (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44) - 1) * 12;
            const sideData = (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avMallocz)(len);
            for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44); i++) {
                if (i !== index) {
                    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(sideData + (i * 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + (i * 12), 12);
                }
                else {
                    (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40) + i * 12));
                }
            }
            (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 40));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 40, sideData);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 44, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](avpacket + 44) - 1);
        }
    }
}
function createAVPacket() {
    const avpacket = (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avMallocz)(88);
    getAVPacketDefault(avpacket);
    return avpacket;
}
function destroyAVPacket(avpacket) {
    unrefAVPacket(avpacket);
    (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(avpacket);
}
function freeAVPacketSideData(pSideData, pnbSideData) {
    const sideData = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](pSideData);
    const nbSideData = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](pnbSideData);
    if (sideData) {
        for (let i = 0; i < nbSideData; i++) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](sideData + i * 12));
        }
        (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFreep)(pSideData);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](pnbSideData, 0);
    }
}
function getAVPacketDefault(avpacket) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 24, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 28, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 40, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 44, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 32, _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avpacket + 56, _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avpacket + 48, _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 36, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avpacket + 16, _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](avpacket + 8, _constant__WEBPACK_IMPORTED_MODULE_4__.NOPTS_VALUE_BIGINT);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 76, _constant__WEBPACK_IMPORTED_MODULE_4__.AV_TIME_BASE);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 72, 1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 80, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket, 0);
}
function copyAVPacketSideData(dst, src) {
    freeAVPacketSideData(dst + 40, dst + 44);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 44)) {
        let size = 12;
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 40, (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avMallocz)(size * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 44)));
        for (let i = 0; i < cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 44); i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 40) + i * 12 + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12 + 4));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 40) + i * 12 + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12 + 8));
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 40) + i * 12, (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avMalloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12 + 4)));
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst + 40) + i * 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 40) + i * 12 + 4));
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 44, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 44));
    }
}
function copyAVPacketProps(dst, src) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 32));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 56, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 56));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 48, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 48));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 36, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 36));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 16));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[17](dst + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[17](src + 8));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 64, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 64));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 76, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 76));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 72, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 72));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 80, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 80));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 68, 0);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferReplace)(dst + 68, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 68));
    copyAVPacketSideData(dst, src);
    return 0;
}
function allocAVPacket(buf, size) {
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferRealloc)(buf, size + AV_INPUT_BUFFER_PADDING_SIZE);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](buf) + 4) + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
    return 0;
}
function refAVPacket(dst, src) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst)) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferUnref)(dst);
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst, 0);
    copyAVPacketProps(dst, src);
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src) && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28)) {
        allocAVPacket(dst, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28)) {
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst) + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst) + 4));
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src)) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferRef)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 24));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 28, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
    return 0;
}
function unrefAVPacket(avpacket) {
    freeAVPacketSideData(avpacket + 40, avpacket + 44);
    (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferUnref)(avpacket + 68);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket)) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferUnref)(avpacket);
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24)) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24));
    }
    getAVPacketDefault(avpacket);
}
function copyAVPacketData(dst, src) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst)) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferUnref)(dst);
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst, 0);
    if (!cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src) && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28)) {
        allocAVPacket(dst, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28)) {
            (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_0__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst) + 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 24), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](dst) + 4));
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src)) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferRef)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](src + 24));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](dst + 28, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](src + 28));
}
function addAVPacketData(avpacket, data, size) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket)) {
        (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferUnref)(avpacket);
    }
    else if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24)) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_3__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[20](avpacket + 24));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket, (0,_avbuffer__WEBPACK_IMPORTED_MODULE_5__.avbufferCreate)(data, size + AV_INPUT_BUFFER_PADDING_SIZE));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[20](avpacket + 24, data);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](avpacket + 28, size);
}


/***/ }),

/***/ "./src/avutil/util/channel.ts":
/*!************************************!*\
  !*** ./src/avutil/util/channel.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   unInitChannelLayout: () => (/* binding */ unInitChannelLayout)
/* harmony export */ });
/* unused harmony export getChannelLayoutNBChannels */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/avutil/util/common.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");




function getChannelLayoutNBChannels(layout) {
    return (0,_common__WEBPACK_IMPORTED_MODULE_0__.popCount64)(layout);
}
function unInitChannelLayout(channelLayout) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumRead[15](channelLayout) == 2 /* AVChannelOrder.AV_CHANNEL_ORDER_CUSTOM */) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_2__.avFreep)(channelLayout + 8);
    }
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memset)(channelLayout, 0, 24);
}


/***/ }),

/***/ "./src/avutil/util/codecparameters.ts":
/*!********************************************!*\
  !*** ./src/avutil/util/codecparameters.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copyCodecParameters: () => (/* binding */ copyCodecParameters),
/* harmony export */   freeCodecParameters: () => (/* binding */ freeCodecParameters)
/* harmony export */ });
/* unused harmony export resetCodecParameters */
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _channel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./channel */ "./src/avutil/util/channel.ts");
/* harmony import */ var _avpacket__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./avpacket */ "./src/avutil/util/avpacket.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");












function copyCodecParametersSideData(pDst, pnbDst, src, nbSrc) {
    if (!src) {
        return;
    }
    const dst = (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avMallocz)(nbSrc * 12);
    for (let i = 0; i < nbSrc; i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + i * 12 + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + i * 12 + 8));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + i * 12 + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + i * 12 + 4));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](dst + i * 12, (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avMalloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + i * 12 + 4)));
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memcpy)(dst + i * 12, src + i * 12, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + i * 12 + 4));
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](pnbDst, nbSrc);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](pDst, dst);
    return 0;
}
function copyCodecParameters(dst, src) {
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 4));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[8](dst + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[8](src + 8));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 28, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 28));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](dst + 32, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[17](src + 32));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 40, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 40));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 44, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 44));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 48, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 48));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 52, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 52));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 56, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 56));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 60, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 60));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 68, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 68));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 64, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 64));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 80, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 80));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 84, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 84));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 88, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 88));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 92, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 92));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 96, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 96));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 100, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 100));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 104, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 104));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memcpy)(dst + 112, src + 112, 24);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 136, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 136));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 140, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 140));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 144, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 144));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 148, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 148));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 152, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 152));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 156, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 156));
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memcpy)(dst + 72, src + 72, 8);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](src + 12)) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](dst + 12)) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avFree)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](dst + 12));
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](dst + 12, (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avMalloc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 16)));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](dst + 16, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 16));
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memcpy)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](dst + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](src + 12), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 16));
    }
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](src + 20)) {
        copyCodecParametersSideData(dst + 20, dst + 24, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](src + 20), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[15](src + 24));
    }
}
function resetCodecParameters(par) {
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[20](par + 12)) {
        (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avFreep)(par + 12);
    }
    (0,_channel__WEBPACK_IMPORTED_MODULE_4__.unInitChannelLayout)(par + 112);
    (0,_avpacket__WEBPACK_IMPORTED_MODULE_5__.freeAVPacketSideData)(par + 20, par + 24);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memset)(par, 0, 168);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par, -1 /* AVMediaType.AVMEDIA_TYPE_UNKNOWN */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 4, 0 /* AVCodecID.AV_CODEC_ID_NONE */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 28, -1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 112, 0 /* AVChannelOrder.AV_CHANNEL_ORDER_UNSPEC */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 80, 0 /* AVFieldOrder.AV_FIELD_UNKNOWN */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 84, 0 /* AVColorRange.AVCOL_RANGE_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 88, 2 /* AVColorPrimaries.AVCOL_PRI_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 92, 2 /* AVColorTransferCharacteristic.AVCOL_TRC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 96, 2 /* AVColorSpace.AVCOL_SPC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 100, 0 /* AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED */);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 64, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 68, 1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 72, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 72, 1);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 48, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](par + 52, _constant__WEBPACK_IMPORTED_MODULE_6__.NOPTS_VALUE);
}
function freeCodecParameters(par) {
    if (!par) {
        return;
    }
    resetCodecParameters(par);
    (0,_mem__WEBPACK_IMPORTED_MODULE_0__.avFree)(par);
}


/***/ }),

/***/ "./src/avutil/util/common.ts":
/*!***********************************!*\
  !*** ./src/avutil/util/common.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   alignFunc: () => (/* binding */ alignFunc),
/* harmony export */   popCount64: () => (/* binding */ popCount64)
/* harmony export */ });
/* unused harmony exports popCount, milliSecond2Second */
/*
 * libmedia common util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
function popCount(x) {
    x -= (x >> 1) & 0x55555555;
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x + (x >> 4)) & 0x0F0F0F0F;
    x += x >> 8;
    return (x + (x >> 16)) & 0x3F;
}
function popCount64(x) {
    return popCount(Number(x & 0xffffffffn)) + popCount(Number(x >> BigInt(32) & 0xffffffffn));
}
function milliSecond2Second(time) {
    const integer = time / BigInt(1000);
    const decimal = time - integer * BigInt(1000);
    return Number(integer) + Number(decimal) / 1000;
}
function alignFunc(value, alignment) {
    return (value + alignment - 1) & ~(alignment - 1);
}


/***/ }),

/***/ "./src/avutil/util/expgolomb.ts":
/*!**************************************!*\
  !*** ./src/avutil/util/expgolomb.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readSE: () => (/* binding */ readSE),
/* harmony export */   readUE: () => (/* binding */ readUE)
/* harmony export */ });
/* unused harmony exports readTE, writeUE, writeSE, writeTE */
/*
 * libmedia expgolomb util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */
const UESizeTable = [
    // 0 的二进制所需的比特个数
    1,
    // 1 的二进制所需的比特个数    
    1,
    // 2~3 的二进制所需的比特个数   
    2, 2,
    // 4~7 的二进制所需的比特个数
    3, 3, 3, 3,
    // 8~15 的二进制所需的比特个数
    4, 4, 4, 4, 4, 4, 4, 4,
    // 16~31 的二进制所需的比特个数
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    // 32~63 的二进制所需的比特个数
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    // 64~127 的二进制所需的比特个数
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    // 128~255 的二进制所需的比特个数
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8
];
/**
 * ue(v) 指数哥伦布解码
 */
function readUE(bitReader) {
    let result = 0;
    // leadingZeroBits
    let i = 0;
    while (i < 32 && bitReader.readU1() === 0) {
        i++;
    }
    // 计算 read_bits ( leadingZeroBits )
    result = bitReader.readU(i);
    // 计算 codeNum，1 << i 即为 2 的 i 次幂
    result += (1 << i) - 1;
    return result;
}
/**
 * se(v) 有符号指数哥伦布解码
 */
function readSE(bitReader) {
    let result = readUE(bitReader);
    // 判断 result 的奇偶性
    if (result & 0x01) {
        // 如果为奇数，说明编码前 > 0
        result = (result + 1) / 2;
    }
    else {
        // 如果为偶数，说明编码前 <= 0
        result = -result / 2;
    }
    return result;
}
/**
 * te(v) 截断指数哥伦布解码
 */
function readTE(bitReader, x) {
    let result = 0;
    // 判断取值上限
    if (x === 1) {
        // 如果为 1 则将读取到的比特值取反
        result = 1 - bitReader.readU1();
    }
    else if (x > 1) {
        // 否则按照 ue(v) 进行解码
        result = readUE(bitReader);
    }
    return result;
}
/**
 * ue(v) 指数哥伦布编码
 */
function writeUE(bitWriter, value) {
    let size = 0;
    if (value === 0) {
        // 0 直接编码为 1
        bitWriter.writeU1(1);
    }
    else {
        let tmp = ++value;
        // 判断所需比特个数是否大于 16 位
        if (tmp >= 0x00010000) {
            size += 16;
            tmp >>= 16;
        }
        // 判断此时所需比特个数是否大于 8 位
        if (tmp >= 0x100) {
            size += 8;
            tmp >>= 8;
        }
        // 最终 tmp 移位至 8 位以内，去查表
        size += UESizeTable[tmp];
        // 最终得出编码 value 所需的总比特数：2 * size - 1
        bitWriter.writeU(2 * size - 1, value);
    }
}
/**
 * se(v) 有符号指数哥伦布编码
 */
function writeSE(bitWriter, value) {
    if (value <= 0) {
        writeUE(bitWriter, -value * 2);
    }
    else {
        writeUE(bitWriter, value * 2 - 1);
    }
}
/**
 * te(v) 截断指数哥伦布编码
 */
function writeTE(bitWriter, x, value) {
    if (x === 1) {
        bitWriter.writeU1(1 & ~value);
    }
    else if (x > 1) {
        writeUE(bitWriter, value);
    }
}


/***/ }),

/***/ "./src/avutil/util/mem.ts":
/*!********************************!*\
  !*** ./src/avutil/util/mem.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   avFree: () => (/* binding */ avFree),
/* harmony export */   avFreep: () => (/* binding */ avFreep),
/* harmony export */   avMalloc: () => (/* binding */ avMalloc),
/* harmony export */   avMallocz: () => (/* binding */ avMallocz),
/* harmony export */   avRealloc: () => (/* binding */ avRealloc)
/* harmony export */ });
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__1 = "src/avutil/util/mem.ts";



/*
 * libmedia mem util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */


function avMalloc(len) {
    const p = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(len);
    if (!p) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('can not alloc buffer', cheap__fileName__1, 32);
    }
    return p;
}
function avMallocz(len) {
    const p = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(len);
    if (!p) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('can not alloc buffer', cheap__fileName__1, 40);
    }
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_2__.memset)(p, 0, len);
    return p;
}
function avFree(p) {
    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(p);
}
function avFreep(p) {
    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20](p));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](p, 0);
}
function avRealloc(p, size) {
    return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.realloc(p, size);
}


/***/ }),

/***/ "./src/avutil/util/nalu.ts":
/*!*********************************!*\
  !*** ./src/avutil/util/nalu.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isAnnexb: () => (/* binding */ isAnnexb),
/* harmony export */   naluUnescape: () => (/* binding */ naluUnescape),
/* harmony export */   splitNaluByStartCode: () => (/* binding */ splitNaluByStartCode)
/* harmony export */ });
/* unused harmony exports splitNaluByLength, joinNaluByStartCode, joinNaluByLength, naluEscape */
/* harmony import */ var common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/io/BufferReader */ "./src/common/io/BufferReader.ts");
/* harmony import */ var common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/io/BufferWriter */ "./src/common/io/BufferWriter.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/*
 * libmedia nalu util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */



function isAnnexb(data) {
    return data.length > 4
        && data[0] === 0
        && data[1] === 0
        && (data[2] === 1
            || data[2] === 0 && data[3] === 1);
}
function getNextNaluStart(data, offset) {
    let t = 0;
    for (let i = offset; i < data.length; i++) {
        switch (data[i]) {
            case 0:
                t++;
                break;
            case 1:
                if (t >= 2) {
                    return {
                        offset: i - Math.min(t, 3),
                        startCode: Math.min(t + 1, 4)
                    };
                }
                t = 0;
                break;
            default:
                t = 0;
        }
    }
    return {
        offset: -1,
        startCode: 0
    };
}
function splitNaluByStartCode(buffer) {
    const list = [];
    let offset = 0;
    let current = getNextNaluStart(buffer, offset);
    let next = {
        offset: -1,
        startCode: 0
    };
    while (next = getNextNaluStart(buffer, current.offset + current.startCode), next.offset > -1) {
        list.push(buffer.subarray(current.offset + current.startCode, next.offset, true));
        current = next;
    }
    list.push(buffer.subarray(current.offset + current.startCode, undefined, true));
    return list;
}
function splitNaluByLength(buffer, naluLengthSizeMinusOne) {
    const list = [];
    const bufferReader = new common_io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](buffer);
    while (bufferReader.remainingSize() > 0) {
        let length = 0;
        if (naluLengthSizeMinusOne === 3) {
            length = bufferReader.readUint32();
        }
        else if (naluLengthSizeMinusOne === 2) {
            length = bufferReader.readUint24();
        }
        else if (naluLengthSizeMinusOne === 1) {
            length = bufferReader.readUint16();
        }
        else {
            length = bufferReader.readUint8();
        }
        const nalu = buffer.subarray((Number(bufferReader.getPos() & 0xffffffffn) >> 0), (Number(bufferReader.getPos() & 0xffffffffn) >> 0) + length, true);
        bufferReader.skip(length);
        list.push(nalu);
    }
    return list;
}
function joinNaluByStartCode(nalus, output, slice = false) {
    if (!output) {
        let length = nalus.reduce((prev, nalu, index) => {
            return prev + ((index && slice) ? 3 : 4) + nalu.length;
        }, 0);
        output = new Uint8Array(length);
    }
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__["default"](output);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu, index) => {
        bufferWriter.writeUint8(0x00);
        bufferWriter.writeUint8(0x00);
        if (!index && slice) {
            bufferWriter.writeUint8(0x00);
        }
        bufferWriter.writeUint8(0x01);
        bufferWriter.writeBuffer(nalu);
    });
    return output;
}
function joinNaluByLength(nalus, naluLengthSizeMinusOne, output) {
    if (!output) {
        const length = nalus.reduce((prev, nalu) => {
            return prev + naluLengthSizeMinusOne + 1 + nalu.length;
        }, 0);
        output = new Uint8Array(length);
    }
    const bufferWriter = new common_io_BufferWriter__WEBPACK_IMPORTED_MODULE_1__["default"](output);
    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(nalus, (nalu) => {
        if (naluLengthSizeMinusOne === 3) {
            bufferWriter.writeUint32(nalu.length);
        }
        else if (naluLengthSizeMinusOne === 2) {
            bufferWriter.writeUint24(nalu.length);
        }
        else if (naluLengthSizeMinusOne === 1) {
            bufferWriter.writeUint16(nalu.length);
        }
        else {
            bufferWriter.writeUint8(nalu.length);
        }
        bufferWriter.writeBuffer(nalu);
    });
    return output;
}
function naluUnescape(data, start = 0, end) {
    if (!end) {
        end = data.length;
    }
    const buffer = new Uint8Array(data.length);
    let zeroCount = 0;
    let pos = 0;
    for (let i = 0; i < data.length; i++) {
        if (i >= start && i < end) {
            if (data[i] === 0) {
                zeroCount++;
            }
            else {
                if (data[i] === 3 && zeroCount === 2 && i + 1 < data.length && data[i + 1] <= 3) {
                    i++;
                    if (i === data.length) {
                        break;
                    }
                    else {
                        if (data[i] === 0) {
                            zeroCount = 1;
                        }
                        else {
                            zeroCount = 0;
                        }
                    }
                }
                else {
                    zeroCount = 0;
                }
            }
        }
        buffer[pos++] = data[i];
    }
    return buffer.slice(0, pos);
}
function naluEscape(data, start = 0, end) {
    if (!end) {
        end = data.length;
    }
    const indexes = [];
    let zeroCount = 0;
    for (let i = start; i < end; i++) {
        if (i >= end) {
            break;
        }
        if (data[i] === 0) {
            zeroCount++;
        }
        else {
            if (data[i] <= 3 && zeroCount === 2) {
                indexes.push(i);
            }
            zeroCount = 0;
        }
    }
    if (indexes.length) {
        const buffer = new Uint8Array(data.length + indexes.length);
        let pos = 0;
        let subData = data.subarray(0, indexes[0]);
        buffer.set(subData, pos);
        pos += subData.length;
        buffer[pos++] = 3;
        for (let i = 1; i < indexes.length; i++) {
            subData = data.subarray(indexes[i - 1], indexes[i]);
            buffer.set(subData, pos);
            pos += subData.length;
            buffer[pos++] = 3;
        }
        subData = data.subarray(indexes[indexes.length - 1], data.length);
        buffer.set(subData, pos);
        pos += subData.length;
        return buffer;
    }
    else {
        return data;
    }
}


/***/ }),

/***/ "./src/avutil/util/pixel.ts":
/*!**********************************!*\
  !*** ./src/avutil/util/pixel.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   chromaLocation2Pos: () => (/* binding */ chromaLocation2Pos),
/* harmony export */   pixelFillLinesizes: () => (/* binding */ pixelFillLinesizes),
/* harmony export */   pixelFillPlaneSizes: () => (/* binding */ pixelFillPlaneSizes),
/* harmony export */   pixelFillPointer: () => (/* binding */ pixelFillPointer)
/* harmony export */ });
/* unused harmony exports pixelGetLinesize, pixelAlloc, pixelGetSize */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../pixelFormatDescriptor */ "./src/avutil/pixelFormatDescriptor.ts");
/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../error */ "./src/avutil/error.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var cheap_stack__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! cheap/stack */ "./src/cheap/stack.ts");
/* harmony import */ var _util_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/common */ "./src/avutil/util/common.ts");
/* harmony import */ var _mem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./mem */ "./src/avutil/util/mem.ts");


/*
 * libmedia video pixel util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */







function chromaLocation2Pos(pos) {
    if (pos <= 0 /* AVChromaLocation.AVCHROMA_LOC_UNSPECIFIED */ || pos >= 7 /* AVChromaLocation.AVCHROMA_LOC_NB */) {
        return;
    }
    return {
        x: (pos & 1) * 128,
        y: ((pos >>> 1) ^ (pos < 4 ? 1 : 0)) * 128
    };
}
function getMaxPixSteps(desc) {
    const maxPixSteps = [0, 0, 0, 0];
    const maxPixStepsComps = [0, 0, 0, 0];
    for (let i = 0; i < 4; i++) {
        if (desc.comp[i] && desc.comp[i].step > maxPixSteps[desc.comp[i].plane]) {
            maxPixSteps[desc.comp[i].plane] = desc.comp[i].step;
            maxPixStepsComps[desc.comp[i].plane] = i;
        }
    }
    return {
        maxPixSteps,
        maxPixStepsComps
    };
}
function setSystematicPal(pal, pixfmt) {
    for (let i = 0; i < 256; i++) {
        let r, g, b;
        switch (pixfmt) {
            case 20 /* AVPixelFormat.AV_PIX_FMT_RGB8 */:
                r = (i >> 5) * 36;
                g = ((i >> 2) & 7) * 36;
                b = (i & 3) * 85;
                break;
            case 17 /* AVPixelFormat.AV_PIX_FMT_BGR8 */:
                b = (i >> 6) * 85;
                g = ((i >> 3) & 7) * 36;
                r = (i & 7) * 36;
                break;
            case 22 /* AVPixelFormat.AV_PIX_FMT_RGB4_BYTE */:
                r = (i >> 3) * 255;
                g = ((i >> 1) & 3) * 85;
                b = (i & 1) * 255;
                break;
            case 19 /* AVPixelFormat.AV_PIX_FMT_BGR4_BYTE */:
                b = (i >> 3) * 255;
                g = ((i >> 1) & 3) * 85;
                r = (i & 1) * 255;
                break;
            case 8 /* AVPixelFormat.AV_PIX_FMT_GRAY8 */:
                r = b = g = i;
                break;
            default:
                return _error__WEBPACK_IMPORTED_MODULE_0__.INVALID_ARGUMENT;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[8](pal + (i * 4), b + (g << 8) + (r << 16) + (-16777216));
    }
    return 0;
}
function pixelGetLinesize_(width, plane, maxStep, maxStepComp, desc) {
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_0__.INVALID_ARGUMENT;
    }
    if (width < 0) {
        return _error__WEBPACK_IMPORTED_MODULE_0__.INVALID_ARGUMENT;
    }
    const s = (maxStepComp === 1 || maxStepComp === 2) ? desc.log2ChromaW : 0;
    const shiftedW = ((width + (1 << s) - 1)) >>> s;
    if (shiftedW && maxStep > _constant__WEBPACK_IMPORTED_MODULE_2__.INT32_MAX / shiftedW) {
        return _error__WEBPACK_IMPORTED_MODULE_0__.INVALID_ARGUMENT;
    }
    let linesize = maxStep * shiftedW;
    if (desc.flags & 4 /* PixelFormatFlags.BIT_STREAM */) {
        linesize = (linesize + 7) >>> 3;
    }
    return linesize;
}
function pixelGetLinesize(pixfmt, width, plane) {
    const desc = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_3__.PixelFormatDescriptorsMap[pixfmt];
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_0__.INVALID_ARGUMENT;
    }
    const { maxPixSteps, maxPixStepsComps } = getMaxPixSteps(desc);
    return pixelGetLinesize_(width, plane, maxPixSteps[plane], maxPixStepsComps[plane], desc);
}
function pixelFillLinesizes(linesizes, pixfmt, width) {
    const desc = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_3__.PixelFormatDescriptorsMap[pixfmt];
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_0__.INVALID_ARGUMENT;
    }
    const { maxPixSteps, maxPixStepsComps } = getMaxPixSteps(desc);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.memset)(linesizes, 0, 16);
    let ret = 0;
    for (let i = 0; i < 4; i++) {
        if ((ret = pixelGetLinesize_(width, i, maxPixSteps[i], maxPixStepsComps[i], desc)) < 0) {
            return ret;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](linesizes + (i * 4), ret);
    }
}
function pixelFillPlaneSizes(sizes, pixfmt, height, linesizes) {
    const hasPlane = [0, 0, 0, 0];
    const desc = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_3__.PixelFormatDescriptorsMap[pixfmt];
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_0__.INVALID_ARGUMENT;
    }
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.memset)(sizes, 0, 16);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](linesizes) > _constant__WEBPACK_IMPORTED_MODULE_2__.INT32_MAX / height) {
        return _error__WEBPACK_IMPORTED_MODULE_0__.INVALID_ARGUMENT;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](sizes, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](linesizes) * height);
    if (desc.flags & 2 /* PixelFormatFlags.PALETTE */) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](sizes + 4, 1024);
        return 0;
    }
    for (let i = 0; i < 4; i++) {
        if (desc.comp[i]) {
            hasPlane[desc.comp[i].plane] = 1;
        }
    }
    for (let i = 0; i < 4 && hasPlane[i]; i++) {
        let s = (i === 1 || i === 2) ? desc.log2ChromaH : 0;
        let h = (height + (1 << s) - 1) >> s;
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](linesizes + (i * 4)) > _constant__WEBPACK_IMPORTED_MODULE_2__.INT32_MAX / h) {
            return _error__WEBPACK_IMPORTED_MODULE_0__.INVALID_ARGUMENT;
        }
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](sizes + (i * 4), h * cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](linesizes + (i * 4)));
    }
    return 0;
}
function pixelFillPointer(data, pixfmt, height, ptr, linesizes) {
    const linesizes1 = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    const sizes = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.memset)(data, 0, 16);
    for (let i = 0; i < 4; i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](linesizes1 + (i * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](linesizes + (i * 4)));
    }
    let ret = pixelFillPlaneSizes(sizes, pixfmt, height, linesizes1);
    if (ret < 0) {
        defer();
        return ret;
    }
    ret = 0;
    for (let i = 0; i < 4; i++) {
        if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](sizes + (i * 4)) > _constant__WEBPACK_IMPORTED_MODULE_2__.INT32_MAX - ret) {
            defer();
            return _error__WEBPACK_IMPORTED_MODULE_0__.INVALID_ARGUMENT;
        }
        ret += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](sizes + (i * 4));
    }
    if (!ptr) {
        defer();
        return ret;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](data, ptr);
    for (let i = 1; i < 4 && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](sizes + (i * 4)); i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[20](data + (i * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](data + (i - 1)) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](sizes + (i - 1)));
    }
    defer();
    return ret;
    function defer() {
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
    }
}
function pixelAlloc(pointers, linesizes, w, h, pixfmt, align = 1) {
    const desc = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_3__.PixelFormatDescriptorsMap[pixfmt];
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_0__.INVALID_ARGUMENT;
    }
    const linesizes1 = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    const sizes = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    let ret = 0;
    if ((ret = pixelFillLinesizes(linesizes, pixfmt, align > 7 ? (0,_util_common__WEBPACK_IMPORTED_MODULE_7__.alignFunc)(w, 8) : w)) < 0) {
        defer();
        return ret;
    }
    for (let i = 0; i < 4; i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](linesizes + (i * 4), (0,_util_common__WEBPACK_IMPORTED_MODULE_7__.alignFunc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](linesizes + (i * 4)), align));
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](linesizes1 + (i * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](linesizes + (i * 4)));
    }
    if ((ret = pixelFillPlaneSizes(sizes, pixfmt, h, linesizes1)) < 0) {
        defer();
        return ret;
    }
    let totalSize = align;
    for (let i = 0; i < 4; i++) {
        if (totalSize > _constant__WEBPACK_IMPORTED_MODULE_2__.INT32_MAX - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](sizes + (i * 4))) {
            defer();
            return _error__WEBPACK_IMPORTED_MODULE_0__.INVALID_ARGUMENT;
        }
        totalSize += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](sizes + (i * 4));
    }
    const buf = (0,_mem__WEBPACK_IMPORTED_MODULE_8__.avMalloc)(totalSize);
    if (!buf) {
        defer();
        return _error__WEBPACK_IMPORTED_MODULE_0__.NO_MEMORY;
    }
    if ((ret = pixelFillPointer(pointers, pixfmt, h, buf, linesizes)) < 0) {
        defer();
        return ret;
    }
    if (desc.flags & 2 /* PixelFormatFlags.PALETTE */) {
        if (align < 4) {
            (0,_mem__WEBPACK_IMPORTED_MODULE_8__.avFree)(buf);
            defer();
            return ret;
        }
        setSystematicPal(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](pointers + 4), pixfmt);
    }
    if ((desc.flags & 2 /* PixelFormatFlags.PALETTE */)
        && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](pointers + 4)
        && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](pointers + 4) - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](pointers) > cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](linesizes) * h) {
        /* zero-initialize the padding before the palette */
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_4__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](pointers) + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](linesizes) * h, 0, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](pointers + 4) - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](pointers) - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](linesizes) * h);
    }
    defer();
    return ret;
    function defer() {
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
    }
}
function pixelGetSize(pixfmt, width, height, align) {
    const desc = _pixelFormatDescriptor__WEBPACK_IMPORTED_MODULE_3__.PixelFormatDescriptorsMap[pixfmt];
    if (!desc) {
        return _error__WEBPACK_IMPORTED_MODULE_0__.INVALID_ARGUMENT;
    }
    const linesizes = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    const alignedLinesizes = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    const sizes = cheap_stack__WEBPACK_IMPORTED_MODULE_6__.malloc(16);
    let ret = 0;
    if ((ret = pixelFillLinesizes(linesizes, pixfmt, width)) < 0) {
        defer();
        return ret;
    }
    for (let i = 0; i < 4; i++) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](alignedLinesizes + (i * 4), (0,_util_common__WEBPACK_IMPORTED_MODULE_7__.alignFunc)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](linesizes + (i * 4)), align));
    }
    if ((ret = pixelFillPlaneSizes(sizes, pixfmt, height, alignedLinesizes)) < 0) {
        defer();
        return ret;
    }
    let totalSize = 0;
    for (let i = 0; i < 4; i++) {
        if (totalSize > _constant__WEBPACK_IMPORTED_MODULE_2__.INT32_MAX - cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](sizes + (i * 4))) {
            defer();
            return _error__WEBPACK_IMPORTED_MODULE_0__.INVALID_ARGUMENT;
        }
        totalSize += cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](sizes + (i * 4));
    }
    defer();
    return totalSize;
    function defer() {
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
        cheap_stack__WEBPACK_IMPORTED_MODULE_6__.free(16);
    }
}


/***/ }),

/***/ "./src/avutil/util/rational.ts":
/*!*************************************!*\
  !*** ./src/avutil/util/rational.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   avQ2D: () => (/* binding */ avQ2D),
/* harmony export */   avReduce: () => (/* binding */ avReduce),
/* harmony export */   avRescaleQ: () => (/* binding */ avRescaleQ)
/* harmony export */ });
/* unused harmony exports avRescaleQ2, avQ2D2, avReduce2 */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_math_gcd__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/math/gcd */ "./src/common/math/gcd.ts");



/**
 * 将一个时间戳由一个时间基转换到另一个时间基
 *
 * @param a 待转换时间戳
 * @param bp 待转换时间戳的时间基
 * @param cq 目标时间基
 */
function avRescaleQ(a, bq, cq) {
    const b = a * BigInt(bq.num >>> 0) * BigInt(cq.den >>> 0);
    const c = BigInt(bq.den >>> 0) * BigInt(cq.num >>> 0);
    return b / c;
}
/**
 * 将一个时间戳由一个时间基转换到另一个时间基
 *
 * @param a 待转换时间戳
 * @param bp 待转换时间戳的时间基
 * @param cq 目标时间基
 */
function avRescaleQ2(a, bq, cq) {
    const b = a * BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](bq) >>> 0) * BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](cq + 4) >>> 0);
    const c = BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](bq + 4) >>> 0) * BigInt(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](cq) >>> 0);
    return b / c;
}
/**
 * 将一个时间基转换成 double
 *
 * @param a
 */
function avQ2D(a) {
    return a.num / a.den;
}
/**
 * 将一个时间基转换成 double
 *
 * @param a
 */
function avQ2D2(a) {
    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a) / cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a + 4);
}
/**
 * 化简 Rational
 *
 * @param a
 */
function avReduce(a) {
    const gcdValue = (0,common_math_gcd__WEBPACK_IMPORTED_MODULE_1__["default"])(a.num, a.den);
    if (gcdValue <= 1) {
        return;
    }
    a.den /= gcdValue;
    a.num /= gcdValue;
}
/**
 * 化简 Rational
 *
 * @param a
 */
function avReduce2(a) {
    const gcdValue = (0,common_math_gcd__WEBPACK_IMPORTED_MODULE_1__["default"])(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a + 4));
    if (gcdValue <= 1) {
        return;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](a + 4, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a + 4) / gcdValue);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[15](a, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[15](a) / gcdValue);
}


/***/ }),

/***/ "./src/avutil/util/sample.ts":
/*!***********************************!*\
  !*** ./src/avutil/util/sample.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getBytesPerSample: () => (/* binding */ getBytesPerSample),
/* harmony export */   sampleFormatGetLinesize: () => (/* binding */ sampleFormatGetLinesize),
/* harmony export */   sampleFormatIsPlanar: () => (/* binding */ sampleFormatIsPlanar)
/* harmony export */ });
/* unused harmony exports sampleFillArrays, sampleAlloc, sampleSetSilence */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constant */ "./src/avutil/constant.ts");
/* harmony import */ var _util_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/common */ "./src/avutil/util/common.ts");
/* harmony import */ var _util_mem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/mem */ "./src/avutil/util/mem.ts");
/* harmony import */ var _sampleFormatDescriptor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sampleFormatDescriptor */ "./src/avutil/sampleFormatDescriptor.ts");


/*
 * libmedia audio sample util
 *
 * 版权所有 (C) 2024 赵高兴
 * Copyright (C) 2024 Gaoxing Zhao
 *
 * 此文件是 libmedia 的一部分
 * This file is part of libmedia.
 *
 * libmedia 是自由软件；您可以根据 GNU Lesser General Public License（GNU LGPL）3.1
 * 或任何其更新的版本条款重新分发或修改它
 * libmedia is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.1 of the License, or (at your option) any later version.
 *
 * libmedia 希望能够为您提供帮助，但不提供任何明示或暗示的担保，包括但不限于适销性或特定用途的保证
 * 您应自行承担使用 libmedia 的风险，并且需要遵守 GNU Lesser General Public License 中的条款和条件。
 * libmedia is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 */





function getBytesPerSample(format) {
    return (format < 0 || format >= 12 /* AVSampleFormat.AV_SAMPLE_FMT_NB */)
        ? 0
        : _sampleFormatDescriptor__WEBPACK_IMPORTED_MODULE_0__.AVSampleFormatDescriptors[format].bits >> 3;
}
function sampleFormatIsPlanar(format) {
    return (format < 0 || format >= 12 /* AVSampleFormat.AV_SAMPLE_FMT_NB */)
        ? false
        : _sampleFormatDescriptor__WEBPACK_IMPORTED_MODULE_0__.AVSampleFormatDescriptors[format].planar;
}
function sampleFormatGetLinesize(format, channels, nbSamples, align) {
    const sampleSize = getBytesPerSample(format);
    const planar = sampleFormatIsPlanar(format);
    if (!sampleSize || nbSamples <= 0 || channels <= 0) {
        return -1;
    }
    if (!align) {
        align = 1;
        nbSamples = (0,_util_common__WEBPACK_IMPORTED_MODULE_1__.alignFunc)(nbSamples, 32);
    }
    if (channels > _constant__WEBPACK_IMPORTED_MODULE_2__.INT32_MAX / align || channels * nbSamples > (_constant__WEBPACK_IMPORTED_MODULE_2__.INT32_MAX - align * channels) / sampleSize) {
        return -1;
    }
    return planar ? (0,_util_common__WEBPACK_IMPORTED_MODULE_1__.alignFunc)(nbSamples * sampleSize, align) : (0,_util_common__WEBPACK_IMPORTED_MODULE_1__.alignFunc)(nbSamples * sampleSize * channels, align);
}
function sampleFillArrays(audioData, buf, format, linesize, channels) {
    const planar = sampleFormatIsPlanar(format);
    (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memset)(audioData, 0, planar ? 4 * channels : 4);
    if (!buf) {
        return -1;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](audioData, buf);
    if (planar) {
        for (let i = 1; i < channels; i++) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](audioData + (i * 4), cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](audioData + (i - 1)) + linesize);
        }
    }
    return 0;
}
function sampleAlloc(audioData, format, linesize, channels) {
    const planar = sampleFormatIsPlanar(format);
    const bufSize = planar ? linesize * channels : linesize;
    if (bufSize < 0) {
        return bufSize;
    }
    const buf = (0,_util_mem__WEBPACK_IMPORTED_MODULE_6__.avMalloc)(bufSize);
    const ret = sampleFillArrays(audioData, buf, format, linesize, channels);
    if (ret < 0) {
        (0,_util_mem__WEBPACK_IMPORTED_MODULE_6__.avFree)(buf);
        return ret;
    }
    return 0;
}
function sampleSetSilence(audioData, offset, format, nbSamples, channels) {
    const planar = sampleFormatIsPlanar(format);
    const planes = planar ? channels : 1;
    const blockAlign = getBytesPerSample(format) * (planar ? 1 : channels);
    const dataSize = nbSamples * blockAlign;
    const fillChar = (format === 0 /* AVSampleFormat.AV_SAMPLE_FMT_U8 */ || format === 5 /* AVSampleFormat.AV_SAMPLE_FMT_U8P */)
        ? 0x80
        : 0x00;
    offset *= blockAlign;
    for (let i = 0; i < planes; i++) {
        (0,cheap_std_memory__WEBPACK_IMPORTED_MODULE_3__.memset)(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[20](audioData + (i * 4)) + offset, fillChar, dataSize);
    }
}


/***/ }),

/***/ "./src/cheap/allocator/AllocatorJS.ts":
/*!********************************************!*\
  !*** ./src/cheap/allocator/AllocatorJS.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AllocatorJS)
/* harmony export */ });
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var _thread_mutex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _staticData__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../staticData */ "./src/cheap/staticData.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/cheap/allocator/AllocatorJS.ts";





const ALIGNMENT_IN_BYTES = 8;
const ALIGNMENT_MASK = ALIGNMENT_IN_BYTES - 1;
const POINTER_SIZE_IN_BYTES = 4;
const BYTES_TO_QUADS_SHIFT = 2;
const MIN_FREEABLE_SIZE_IN_BYTES = 16;
const MIN_FREEABLE_SIZE_IN_QUADS = bytesToQuads(MIN_FREEABLE_SIZE_IN_BYTES);
const MAX_HEIGHT = 32;
const HEADER_SIZE_IN_QUADS = 1 + (MAX_HEIGHT * 2);
const HEADER_OFFSET_IN_QUADS = 1;
const HEIGHT_OFFSET_IN_QUADS = 0;
const NEXT_OFFSET_IN_QUADS = 2;
const POINTER_SIZE_IN_QUADS = 1;
const POINTER_OVERHEAD_IN_QUADS = 2;
const FIRST_BLOCK_OFFSET_IN_QUADS = HEADER_OFFSET_IN_QUADS + HEADER_SIZE_IN_QUADS + POINTER_OVERHEAD_IN_QUADS;
const FIRST_BLOCK_OFFSET_IN_BYTES = FIRST_BLOCK_OFFSET_IN_QUADS * POINTER_SIZE_IN_BYTES;
const OVERHEAD_IN_BYTES = (FIRST_BLOCK_OFFSET_IN_QUADS + 1) * POINTER_SIZE_IN_BYTES;
class AllocatorJS {
    buffer;
    byteOffset;
    heapOffset;
    heapLength;
    int32Array;
    updates;
    options;
    shared;
    handles;
    constructor(options, init = true) {
        this.options = common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend({
            growSize: 1048576,
            maxHeapSize: 2097152000
        }, options);
        this.handles = [];
        this.buffer = options.buffer;
        this.shared = false;
        if (this.options.memory || this.buffer instanceof ArrayBuffer || this.buffer instanceof SharedArrayBuffer) {
            this.byteOffset = options.byteOffset ?? 0;
            this.heapOffset = alignHeapOffset(this.byteOffset + quadsToBytes(MAX_HEIGHT), options.byteLength ?? this.buffer.byteLength);
            this.heapLength = alignHeapLength((options.byteLength ?? this.buffer.byteLength) - this.heapOffset);
            this.int32Array = new Int32Array(this.buffer, this.heapOffset, bytesToQuads(this.heapLength));
            this.updates = new Int32Array(this.buffer, this.byteOffset, MAX_HEIGHT);
            if (typeof SharedArrayBuffer === 'function' && this.buffer instanceof SharedArrayBuffer) {
                this.shared = true;
            }
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal('Expected buffer to be an instance of Buffer or ArrayBuffer', cheap__fileName__0, 109);
        }
        if (init) {
            this.updates.fill(HEADER_OFFSET_IN_QUADS);
            prepare(this.int32Array);
            checkListIntegrity(this.int32Array);
        }
    }
    addUpdateHandle(handle) {
        if (!common_util_array__WEBPACK_IMPORTED_MODULE_2__.has(this.handles, handle)) {
            this.handles.push(handle);
        }
    }
    removeUpdateHandle(handle) {
        common_util_array__WEBPACK_IMPORTED_MODULE_2__.remove(this.handles, handle);
    }
    malloc_(size) {
        size = align(size, ALIGNMENT_MASK);
        if (size < MIN_FREEABLE_SIZE_IN_BYTES) {
            size = MIN_FREEABLE_SIZE_IN_BYTES;
        }
        const minimumSize = bytesToQuads(size);
        const block = this.findFreeBlock(this.int32Array, minimumSize);
        if (block <= HEADER_OFFSET_IN_QUADS) {
            return 0;
        }
        const blockSize = readSize(this.int32Array, block);
        if (blockSize - (minimumSize + POINTER_OVERHEAD_IN_QUADS) >= MIN_FREEABLE_SIZE_IN_QUADS) {
            split(this.int32Array, block, minimumSize, blockSize, this.updates);
        }
        else {
            remove(this.int32Array, block, blockSize, this.updates);
        }
        return quadsToBytes(block) + this.heapOffset;
    }
    /**
     * Allocate a given number of bytes and return the offset.
     * If allocation fails, returns 0.
     */
    malloc(size) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex, !false);
            this.checkBuffer();
        }
        const address = this.malloc_(size);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex);
        }
        return address;
    }
    calloc_(num, size) {
        let numberOfBytes = num * size;
        if (numberOfBytes < MIN_FREEABLE_SIZE_IN_BYTES) {
            numberOfBytes = MIN_FREEABLE_SIZE_IN_BYTES;
        }
        else {
            numberOfBytes = align(numberOfBytes, ALIGNMENT_MASK);
        }
        const address = this.malloc_(numberOfBytes);
        if (address === 0) {
            // Not enough space
            return 0;
        }
        const offset = bytesToQuads(address);
        this.int32Array.subarray(offset, offset + numberOfBytes >> 2).fill(0);
        return address;
    }
    calloc(num, size) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex, !false);
            this.checkBuffer();
        }
        const address = this.calloc_(num, size);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex);
        }
        return address;
    }
    realloc_(address, size) {
        if (address === 0) {
            return this.malloc_(size);
        }
        const originAddress = address;
        if (size === 0) {
            this.free_(originAddress);
            return 0;
        }
        address = address - this.heapOffset;
        let originBlock = bytesToQuads(address);
        let block = originBlock;
        let padding = 0;
        if (isAlign(this.int32Array, originBlock)) {
            block = this.int32Array[originBlock - 1];
            padding = originBlock - block;
        }
        const blockSize = readSize(this.int32Array, block) - padding;
        const minimumSize = bytesToQuads(align(size, ALIGNMENT_MASK));
        if (blockSize >= minimumSize) {
            return originAddress;
        }
        else {
            const newAddress = this.malloc_(size);
            if (newAddress === 0) {
                this.free_(originAddress);
                return 0;
            }
            this.int32Array.set(this.int32Array.subarray(originBlock, originBlock + blockSize), bytesToQuads(newAddress - this.heapOffset));
            this.free_(originAddress);
            return newAddress;
        }
    }
    realloc(address, size) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex, !false);
            this.checkBuffer();
        }
        address = this.realloc_(address, size);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex);
        }
        return address;
    }
    alignedAlloc_(alignment, size) {
        if (alignment <= ALIGNMENT_IN_BYTES) {
            // malloc 以 ALIGNMENT_IN_BYTES 字节对齐
            return this.malloc_(size);
        }
        const address = this.malloc_(size + alignment - 1 + POINTER_SIZE_IN_BYTES);
        if (address === 0) {
            return 0;
        }
        const alignmentAddress = (address + alignment - 1 + POINTER_SIZE_IN_BYTES) & ~(alignment - 1);
        this.int32Array[bytesToQuads(alignmentAddress - this.heapOffset) - POINTER_SIZE_IN_QUADS] = bytesToQuads(address - this.heapOffset);
        return alignmentAddress;
    }
    alignedAlloc(alignment, size) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex, !false);
            this.checkBuffer();
        }
        const address = this.alignedAlloc_(alignment, size);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex);
        }
        return address;
    }
    free_(address) {
        if (address === 0) {
            return;
        }
        address = address - this.heapOffset;
        let block = bytesToQuads(address);
        if (isAlign(this.int32Array, block)) {
            block = this.int32Array[block - POINTER_SIZE_IN_QUADS];
        }
        if (isFree(this.int32Array, block)) {
            return;
        }
        const blockSize = readSize(this.int32Array, block);
        const preceding = getFreeBlockBefore(this.int32Array, block);
        const trailing = getFreeBlockAfter(this.int32Array, block);
        if (preceding !== 0) {
            if (trailing !== 0) {
                insertMiddle(this.int32Array, preceding, block, blockSize, trailing, this.updates);
            }
            else {
                insertAfter(this.int32Array, preceding, block, blockSize, this.updates);
            }
        }
        else if (trailing !== 0) {
            insertBefore(this.int32Array, trailing, block, blockSize, this.updates);
        }
        else {
            insert(this.int32Array, block, blockSize, this.updates);
        }
    }
    /**
     * Free a number of bytes from the given address.
     */
    free(address) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex, !false);
            this.checkBuffer();
        }
        this.free_(address);
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex);
        }
    }
    /**
     * Return the size of the block at the given address.
     */
    sizeof(address) {
        if (address === 0) {
            return 0;
        }
        address -= this.heapOffset;
        let block = bytesToQuads(address);
        if (isAlign(this.int32Array, block)) {
            block = this.int32Array[block - POINTER_SIZE_IN_QUADS];
        }
        return quadsToBytes(readSize(this.int32Array, block));
    }
    /**
     * 获取堆分配信息
     *
     * @returns
     */
    inspect() {
        this.checkBuffer();
        return inspect(this.int32Array, this.heapOffset);
    }
    findFreeBlock(int32Array, minimumSize) {
        let block = findFreeBlock(int32Array, minimumSize);
        if (block === HEADER_OFFSET_IN_QUADS) {
            if (this.options.growAllowed && this.heapLength < this.options.maxHeapSize) {
                const block = this.int32Array.length + 1;
                let int32Array;
                let updates;
                let byteOffset = 0;
                let heapLength = 0;
                let heapOffset = 0;
                if (this.options.onResize) {
                    const result = this.options.onResize(this.int32Array, this.int32Array.byteLength + align(Math.max(this.options.growSize, quadsToBytes(minimumSize)), ALIGNMENT_MASK));
                    byteOffset = result.byteOffset ?? 0;
                    heapOffset = alignHeapOffset(byteOffset + quadsToBytes(MAX_HEIGHT), result.byteLength ?? result.buffer.byteLength);
                    heapLength = alignHeapLength((result.byteLength ?? result.buffer.byteLength) - heapOffset);
                    int32Array = new Int32Array(result.buffer, heapOffset, bytesToQuads(heapLength));
                    updates = new Int32Array(result.buffer, byteOffset, MAX_HEIGHT);
                }
                else {
                    const buffer = new ArrayBuffer(this.int32Array.length + bytesToQuads(this.options.growSize));
                    heapOffset = alignHeapOffset(byteOffset + quadsToBytes(MAX_HEIGHT), buffer.byteLength);
                    heapLength = alignHeapLength(buffer.byteLength - heapOffset);
                    int32Array = new Int32Array(buffer, heapOffset, bytesToQuads(heapLength));
                    int32Array.set(this.int32Array, 0);
                    updates = new Int32Array(buffer, byteOffset, MAX_HEIGHT);
                }
                this.byteOffset = byteOffset;
                this.heapOffset = heapOffset;
                this.buffer = int32Array.buffer;
                this.heapLength = heapLength;
                this.int32Array = int32Array;
                this.updates = updates;
                const blockSize = int32Array.length - (block - 1) - POINTER_OVERHEAD_IN_QUADS;
                writeFreeBlockSize(int32Array, blockSize, block);
                const preceding = getFreeBlockBefore(int32Array, block);
                if (preceding !== 0) {
                    insertAfter(int32Array, preceding, block, blockSize, this.updates);
                }
                else {
                    insert(int32Array, block, blockSize, this.updates);
                }
                if (this.handles.length) {
                    common_util_array__WEBPACK_IMPORTED_MODULE_2__.each(this.handles, (func) => {
                        func(this.buffer);
                    });
                }
                return this.findFreeBlock(this.int32Array, minimumSize);
            }
            return block;
        }
        else {
            return block;
        }
    }
    getBuffer() {
        return this.buffer;
    }
    isAlloc(pointer) {
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.lock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex, !false);
            this.checkBuffer();
        }
        const block = bytesToQuads(pointer - this.heapOffset);
        let next = this.int32Array[HEADER_OFFSET_IN_QUADS + NEXT_OFFSET_IN_QUADS];
        // sometime get undefined from the last free node in v8
        // but it's is all right |=_=
        while (next && next !== HEADER_OFFSET_IN_QUADS) {
            if (block >= next && block < next + this.int32Array[next - POINTER_SIZE_IN_QUADS]) {
                if (this.shared) {
                    (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex);
                }
                return false;
            }
            next = this.int32Array[next + NEXT_OFFSET_IN_QUADS];
        }
        if (this.shared) {
            (0,_thread_mutex__WEBPACK_IMPORTED_MODULE_3__.unlock)(_staticData__WEBPACK_IMPORTED_MODULE_4__.heapMutex);
        }
        return true;
    }
    checkBuffer() {
        if (this.options.memory && this.options.memory.buffer !== this.buffer) {
            this.buffer = this.options.memory.buffer;
            this.heapLength = alignHeapLength(this.buffer.byteLength - this.heapOffset);
            this.int32Array = new Int32Array(this.buffer, this.heapOffset, bytesToQuads(this.heapLength));
        }
    }
}
/**
 * Prepare the given int32Array and ensure it contains a valid header.
 */
function prepare(int32Array) {
    if (!verifyHeader(int32Array)) {
        writeInitialHeader(int32Array);
    }
}
/**
 * Verify that the int32Array contains a valid header.
 */
function verifyHeader(int32Array) {
    return int32Array[HEADER_OFFSET_IN_QUADS - 1] === HEADER_SIZE_IN_QUADS
        && int32Array[HEADER_OFFSET_IN_QUADS + HEADER_SIZE_IN_QUADS] === HEADER_SIZE_IN_QUADS;
}
/**
 * Write the initial header for an empty int32Array.
 */
function writeInitialHeader(int32Array) {
    const header = HEADER_OFFSET_IN_QUADS;
    const headerSize = HEADER_SIZE_IN_QUADS;
    const block = FIRST_BLOCK_OFFSET_IN_QUADS;
    const blockSize = int32Array.length - (header + headerSize + POINTER_OVERHEAD_IN_QUADS + POINTER_SIZE_IN_QUADS);
    writeFreeBlockSize(int32Array, headerSize, header);
    int32Array[header + HEIGHT_OFFSET_IN_QUADS] = 1;
    int32Array[header + NEXT_OFFSET_IN_QUADS] = block;
    for (let height = 1; height < MAX_HEIGHT; height++) {
        int32Array[header + NEXT_OFFSET_IN_QUADS + height] = HEADER_OFFSET_IN_QUADS;
    }
    writeFreeBlockSize(int32Array, blockSize, block);
    int32Array[block + HEIGHT_OFFSET_IN_QUADS] = 1;
    int32Array[block + NEXT_OFFSET_IN_QUADS] = header;
}
/**
 * Check the integrity of the freelist in the given array.
 */
function checkListIntegrity(int32Array) {
    let block = FIRST_BLOCK_OFFSET_IN_QUADS;
    while (block < int32Array.length - POINTER_SIZE_IN_QUADS) {
        const size = readSize(int32Array, block);
        /* istanbul ignore if  */
        if (size < POINTER_OVERHEAD_IN_QUADS || size >= int32Array.length - FIRST_BLOCK_OFFSET_IN_QUADS) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal(`Got invalid sized chunk at ${quadsToBytes(block)} (${quadsToBytes(size)} bytes).`, cheap__fileName__0, 563);
        }
        else if (isFree(int32Array, block)) {
            checkFreeBlockIntegrity(int32Array, block, size);
        }
        else {
            checkUsedBlockIntegrity(int32Array, block, size);
        }
        block += size + POINTER_OVERHEAD_IN_QUADS;
    }
    return true;
}
function checkFreeBlockIntegrity(int32Array, block, blockSize) {
    /* istanbul ignore if  */
    if (int32Array[block - 1] !== int32Array[block + blockSize]) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal(`Block length header does not match footer (${quadsToBytes(int32Array[block - 1])} vs ${quadsToBytes(int32Array[block + blockSize])}).`, cheap__fileName__0, 579);
    }
    const height = int32Array[block + HEIGHT_OFFSET_IN_QUADS];
    /* istanbul ignore if  */
    if (height < 1 || height > MAX_HEIGHT) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal(`Block ${quadsToBytes(block)} height must be between 1 and ${MAX_HEIGHT}, got ${height}.`, cheap__fileName__0, 584);
    }
    for (let i = 0; i < height; i++) {
        const pointer = int32Array[block + NEXT_OFFSET_IN_QUADS + i];
        /* istanbul ignore if  */
        if (pointer >= FIRST_BLOCK_OFFSET_IN_QUADS && !isFree(int32Array, pointer)) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal(`Block ${quadsToBytes(block)} has a pointer to a non-free block (${quadsToBytes(pointer)}).`, cheap__fileName__0, 590);
        }
    }
    return true;
}
function checkUsedBlockIntegrity(int32Array, block, blockSize) {
    /* istanbul ignore if  */
    if (int32Array[block - 1] !== int32Array[block + blockSize]) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal(`Block length header does not match footer (${quadsToBytes(int32Array[block - 1])} vs ${quadsToBytes(int32Array[block + blockSize])}).`, cheap__fileName__0, 599);
    }
    else {
        return true;
    }
}
/**
 * Inspect the freelist in the given array.
 */
function inspect(int32Array, byteOffset) {
    const blocks = [];
    const header = readListNode(int32Array, HEADER_OFFSET_IN_QUADS, byteOffset);
    let block = FIRST_BLOCK_OFFSET_IN_QUADS;
    let used = 0;
    while (block < int32Array.length - POINTER_SIZE_IN_QUADS) {
        const size = readSize(int32Array, block);
        /* istanbul ignore if  */
        if (size < POINTER_OVERHEAD_IN_QUADS || size >= int32Array.length) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal(`Got invalid sized chunk at ${quadsToBytes(block)} (${quadsToBytes(size)})`, cheap__fileName__0, 619);
        }
        if (isFree(int32Array, block)) {
            // @flowIssue todo
            blocks.push(readListNode(int32Array, block, byteOffset));
        }
        else {
            used += quadsToBytes(size);
            blocks.push({
                type: 'used',
                block: block,
                offset: quadsToBytes(block) + byteOffset,
                size: quadsToBytes(size)
            });
        }
        block += size + POINTER_OVERHEAD_IN_QUADS;
    }
    return { header, blocks, total: quadsToBytes(int32Array.length), used };
}
/**
 * Convert quads to bytes.
 */
function quadsToBytes(num) {
    return num << BYTES_TO_QUADS_SHIFT;
}
/**
 * Convert bytes to quads.
 */
function bytesToQuads(num) {
    return num >>> BYTES_TO_QUADS_SHIFT;
}
/**
 * Align the given value to 8 bytes.
 */
function align(value, alignment) {
    return (value + alignment) & ~alignment;
}
/**
 * align heap
 *
 * @param offset heap start offset
 * @param byteLength  buffer length
 * @returns
 */
function alignHeapOffset(offset, byteLength) {
    const length = byteLength - offset;
    // 保证 heapLength 为 ALIGNMENT_IN_BYTES 对齐
    let heapOffset = offset + (align(length, ALIGNMENT_MASK) === length
        ? 0
        : (length - align(length, ALIGNMENT_MASK) + ALIGNMENT_IN_BYTES));
    return heapOffset;
}
function alignHeapLength(length) {
    // header 所占 int length 为奇数，则总长度也需要为奇数保证 body 为偶数
    if (!((HEADER_OFFSET_IN_QUADS + HEADER_SIZE_IN_QUADS) % 2)) {
        length -= POINTER_SIZE_IN_BYTES;
    }
    return length;
}
/**
 * Read the list pointers for a given block.
 */
function readListNode(int32Array, block, byteOffset) {
    const height = int32Array[block + HEIGHT_OFFSET_IN_QUADS];
    const pointers = [];
    for (let i = 0; i < height; i++) {
        pointers.push(int32Array[block + NEXT_OFFSET_IN_QUADS + i]);
    }
    return {
        type: 'free',
        block,
        offset: quadsToBytes(block) + byteOffset,
        height,
        pointers,
        size: quadsToBytes(int32Array[block - 1])
    };
}
/**
 * Read the size (in quads) of the block at the given address.
 */
function readSize(int32Array, block) {
    const n = int32Array[block - 1];
    const mask = n >> 31;
    return (n + mask) ^ mask;
}
/**
 * Write the size of the block at the given address.
 * Note: This ONLY works for free blocks, not blocks in use.
 */
function writeFreeBlockSize(int32Array, size, block) {
    int32Array[block - 1] = size;
    int32Array[block + size] = size;
}
/**
 * Populate the `UPDATES` array with the offset of the last item in each
 * list level, *before* a node of at least the given size.
 */
function findPredecessors(int32Array, minimumSize, UPDATES) {
    const listHeight = int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS];
    let node = HEADER_OFFSET_IN_QUADS;
    for (let height = listHeight; height > 0; height--) {
        let next = node + NEXT_OFFSET_IN_QUADS + (height - 1);
        while (int32Array[next] >= FIRST_BLOCK_OFFSET_IN_QUADS && int32Array[int32Array[next] - 1] < minimumSize) {
            node = int32Array[next];
            next = node + NEXT_OFFSET_IN_QUADS + (height - 1);
        }
        UPDATES[height - 1] = node;
    }
}
/**
 * Find a free block with at least the given size and return its offset in quads.
 */
function findFreeBlock(int32Array, minimumSize) {
    let block = HEADER_OFFSET_IN_QUADS;
    for (let height = int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS]; height > 0; height--) {
        let next = int32Array[block + NEXT_OFFSET_IN_QUADS + (height - 1)];
        while (next !== HEADER_OFFSET_IN_QUADS && int32Array[next - POINTER_SIZE_IN_QUADS] < minimumSize) {
            block = next;
            next = int32Array[block + NEXT_OFFSET_IN_QUADS + (height - 1)];
        }
    }
    block = int32Array[block + NEXT_OFFSET_IN_QUADS];
    if (block === HEADER_OFFSET_IN_QUADS) {
        return block;
    }
    else {
        return block;
    }
}
/**
 * Split the given block after a certain number of bytes and add the second half to the freelist.
 */
function split(int32Array, block, firstSize, blockSize, UPDATES) {
    const second = (block + firstSize + POINTER_OVERHEAD_IN_QUADS);
    const secondSize = (blockSize - (second - block));
    remove(int32Array, block, blockSize, UPDATES);
    int32Array[block - 1] = -firstSize;
    int32Array[block + firstSize] = -firstSize;
    int32Array[second - 1] = -secondSize;
    int32Array[second + secondSize] = -secondSize;
    insert(int32Array, second, secondSize, UPDATES);
}
/**
 * Remove the given block from the freelist and mark it as allocated.
 */
function remove(int32Array, block, blockSize, UPDATES) {
    findPredecessors(int32Array, blockSize, UPDATES);
    let node = int32Array[UPDATES[0] + NEXT_OFFSET_IN_QUADS];
    while (node !== block && node !== HEADER_OFFSET_IN_QUADS && int32Array[node - 1] <= blockSize) {
        for (let height = int32Array[node + HEIGHT_OFFSET_IN_QUADS] - 1; height >= 0; height--) {
            if (int32Array[node + NEXT_OFFSET_IN_QUADS + height] === block) {
                UPDATES[height] = node;
            }
        }
        node = int32Array[node + NEXT_OFFSET_IN_QUADS];
    }
    let listHeight = int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS];
    for (let height = 0; height < listHeight; height++) {
        const next = int32Array[UPDATES[height] + NEXT_OFFSET_IN_QUADS + height];
        if (next !== block) {
            break;
        }
        int32Array[UPDATES[height] + NEXT_OFFSET_IN_QUADS + height] = int32Array[block + NEXT_OFFSET_IN_QUADS + height];
    }
    while (listHeight > 0 && int32Array[HEADER_OFFSET_IN_QUADS + NEXT_OFFSET_IN_QUADS + (listHeight - 1)] === HEADER_OFFSET_IN_QUADS) {
        listHeight--;
        int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS] = listHeight;
    }
    // invert the size sign to signify an allocated block
    int32Array[block - 1] = -blockSize;
    int32Array[block + blockSize] = -blockSize;
}
/**
 * Determine whether the block at the given address is free or not.
 */
function isFree(int32Array, block) {
    /* istanbul ignore if  */
    if (block < HEADER_SIZE_IN_QUADS) {
        return false;
    }
    const size = int32Array[block - POINTER_SIZE_IN_QUADS];
    if (size < 0) {
        return false;
    }
    else {
        return true;
    }
}
/**
 * Determine whether the block at the given address is free or not.
 */
function isAlign(int32Array, block) {
    /* istanbul ignore if  */
    if (block < HEADER_SIZE_IN_QUADS) {
        return false;
    }
    const origin = int32Array[block - POINTER_SIZE_IN_QUADS];
    if (origin < 0) {
        return false;
    }
    else {
        return true;
    }
}
/**
 * Get the address of the block before the given one and return the address *if it is free*,
 * otherwise 0.
 */
function getFreeBlockBefore(int32Array, block) {
    if (block <= FIRST_BLOCK_OFFSET_IN_QUADS) {
        return 0;
    }
    const beforeSize = int32Array[block - POINTER_OVERHEAD_IN_QUADS];
    if (beforeSize < POINTER_OVERHEAD_IN_QUADS) {
        return 0;
    }
    return block - (POINTER_OVERHEAD_IN_QUADS + beforeSize);
}
/**
 * Get the address of the block after the given one and return its address *if it is free*,
 * otherwise 0.
 */
function getFreeBlockAfter(int32Array, block) {
    const blockSize = readSize(int32Array, block);
    if (block + blockSize + POINTER_OVERHEAD_IN_QUADS >= int32Array.length - 2) {
        // Block is the last in the list.
        return 0;
    }
    const next = (block + blockSize + POINTER_OVERHEAD_IN_QUADS);
    const nextSize = int32Array[next - POINTER_SIZE_IN_QUADS];
    if (nextSize < POINTER_OVERHEAD_IN_QUADS) {
        return 0;
    }
    return next;
}
/**
 * Insert the given block into the freelist and return the number of bytes that were freed.
 */
function insert(int32Array, block, blockSize, UPDATES) {
    findPredecessors(int32Array, blockSize, UPDATES);
    const blockHeight = generateHeight(int32Array, block, blockSize, UPDATES);
    for (let height = 1; height <= blockHeight; height++) {
        const update = UPDATES[height - 1] + NEXT_OFFSET_IN_QUADS + (height - 1);
        int32Array[block + NEXT_OFFSET_IN_QUADS + (height - 1)] = int32Array[update];
        int32Array[update] = block;
        UPDATES[height - 1] = HEADER_OFFSET_IN_QUADS;
    }
    int32Array[block - 1] = blockSize;
    int32Array[block + blockSize] = blockSize;
    return blockSize;
}
/**
 * Insert the given block into the freelist before the given free block,
 * joining them together, returning the number of bytes which were freed.
 */
function insertBefore(int32Array, trailing, block, blockSize, UPDATES) {
    const trailingSize = readSize(int32Array, trailing);
    remove(int32Array, trailing, trailingSize, UPDATES);
    const size = (blockSize + trailingSize + POINTER_OVERHEAD_IN_QUADS);
    int32Array[block - POINTER_SIZE_IN_QUADS] = -size;
    int32Array[trailing + trailingSize] = -size;
    insert(int32Array, block, size, UPDATES);
    return blockSize;
}
/**
 * Insert the given block into the freelist in between the given free blocks,
 * joining them together, returning the number of bytes which were freed.
 */
function insertMiddle(int32Array, preceding, block, blockSize, trailing, UPDATES) {
    const precedingSize = readSize(int32Array, preceding);
    const trailingSize = readSize(int32Array, trailing);
    const size = ((trailing - preceding) + trailingSize);
    remove(int32Array, preceding, precedingSize, UPDATES);
    remove(int32Array, trailing, trailingSize, UPDATES);
    int32Array[preceding - POINTER_SIZE_IN_QUADS] = -size;
    int32Array[trailing + trailingSize] = -size;
    insert(int32Array, preceding, size, UPDATES);
    return blockSize;
}
/**
 * Insert the given block into the freelist after the given free block,
 * joining them together, returning the number of bytes which were freed.
 */
function insertAfter(int32Array, preceding, block, blockSize, UPDATES) {
    const precedingSize = (block - preceding) - POINTER_OVERHEAD_IN_QUADS;
    const size = ((block - preceding) + blockSize);
    remove(int32Array, preceding, precedingSize, UPDATES);
    int32Array[preceding - POINTER_SIZE_IN_QUADS] = -size;
    int32Array[block + blockSize] = -size;
    insert(int32Array, preceding, size, UPDATES);
    return blockSize;
}
/**
 * Generate a random height for a block, growing the list height by 1 if required.
 */
function generateHeight(int32Array, block, blockSize, UPDATES) {
    const listHeight = int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS];
    let height = randomHeight();
    if (blockSize - 1 < height + 1) {
        height = blockSize - 2;
    }
    if (height > listHeight) {
        const newHeight = listHeight + 1;
        int32Array[HEADER_OFFSET_IN_QUADS + HEIGHT_OFFSET_IN_QUADS] = newHeight;
        int32Array[HEADER_OFFSET_IN_QUADS + NEXT_OFFSET_IN_QUADS + (newHeight - 1)] = HEADER_OFFSET_IN_QUADS;
        UPDATES[newHeight] = HEADER_OFFSET_IN_QUADS;
        int32Array[block + HEIGHT_OFFSET_IN_QUADS] = newHeight;
        return newHeight;
    }
    else {
        int32Array[block + HEIGHT_OFFSET_IN_QUADS] = height;
        return height;
    }
}
/**
 * Generate a random height for a new block.
 */
function randomHeight() {
    let height = 1;
    while (Math.random() < 0.5 && height < MAX_HEIGHT) {
        height += 1;
    }
    return height;
}


/***/ }),

/***/ "./src/cheap/allocator/Table.ts":
/*!**************************************!*\
  !*** ./src/cheap/allocator/Table.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebassemblyTable: () => (/* binding */ WebassemblyTable)
/* harmony export */ });
class WebassemblyTable {
    table;
    pointer;
    nodes;
    constructor() {
        this.table = new WebAssembly.Table({
            initial: 10,
            element: 'anyfunc'
        });
        this.pointer = 1;
        this.nodes = [{
                pointer: 1,
                length: 9,
                free: true
            }];
    }
    getPointer() {
        return this.pointer;
    }
    alloc(count) {
        let p = this.findFree(count);
        if (p < 0) {
            const last = this.nodes[this.nodes.length - 1];
            const length = count - (last.free ? last.length : 0);
            this.table.grow(length);
            if (last.free) {
                last.length = last.length + length;
            }
            else {
                this.nodes.push({
                    pointer: last.pointer + last.length,
                    length,
                    free: true
                });
            }
            p = this.findFree(count);
        }
        const node = this.nodes[p];
        if (node.length > count) {
            this.nodes.splice(p + 1, 0, {
                pointer: node.pointer + count,
                length: node.length - count,
                free: true
            });
            node.length = count;
        }
        node.free = false;
        return node.pointer;
    }
    free(pointer) {
        let p = this.findNode(pointer);
        const node = this.nodes[p];
        if (node && !node.free) {
            const before = this.nodes[p - 1];
            const after = this.nodes[p + 1];
            if (before && before.free) {
                if (after && after.free) {
                    before.length += (node.length + after.length);
                    this.nodes.splice(p, 2);
                }
                else {
                    before.length += node.length;
                    this.nodes.splice(p, 1);
                }
            }
            else {
                if (after && after.free) {
                    node.length += after.length;
                    this.nodes.splice(p + 1, 1);
                    node.free = true;
                }
                else {
                    node.free = true;
                }
            }
        }
        if (this.nodes.length === 1 && this.nodes[0].free) {
            // 当全部 free 之后重新创建新的 Table，之前 WebAssembly 设置的函数引用在 chrome 上没有被回收，会内存泄漏
            this.table = new WebAssembly.Table({
                initial: 10,
                element: 'anyfunc'
            });
            this.pointer = 1;
            this.nodes = [{
                    pointer: 1,
                    length: 9,
                    free: true
                }];
        }
    }
    get(index) {
        return this.table.get(index);
    }
    set(index, value) {
        if (index < 0 || index >= this.pointer) {
            throw new RangeError('index out of bound');
        }
        this.table.set(index, value);
    }
    inspect() {
        return this.nodes;
    }
    findFree(length) {
        let index = -1;
        for (let i = 0; i < this.nodes.length; i++) {
            if (this.nodes[i].length >= length && this.nodes[i].free) {
                index = i;
                break;
            }
        }
        return index;
    }
    findNode(pointer) {
        let index = -1;
        for (let i = 0; i < this.nodes.length; i++) {
            if (this.nodes[i].pointer === pointer) {
                index = i;
                break;
            }
        }
        return index;
    }
}


/***/ }),

/***/ "./src/cheap/asm/memory.ts":
/*!*********************************!*\
  !*** ./src/cheap/asm/memory.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* unused harmony exports instance, support */
/* harmony import */ var common_util_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/base64 */ "./src/common/util/base64.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var common_util_wasm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/wasm */ "./src/common/util/wasm.ts");
/* harmony import */ var _memory_asm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./memory.asm */ "./src/cheap/asm/memory.asm");
/* harmony import */ var _memory_asm__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_memory_asm__WEBPACK_IMPORTED_MODULE_1__);
var cheap__fileName__0 = "src/cheap/asm/memory.ts";






/**
 * WebAssembly runtime 实例
 */
let instance;
function support() {
    return !!instance;
}
async function init(memory) {
    try {
        let wasm = (0,common_util_base64__WEBPACK_IMPORTED_MODULE_0__.base64ToUint8Array)((_memory_asm__WEBPACK_IMPORTED_MODULE_1___default()));
        common_util_wasm__WEBPACK_IMPORTED_MODULE_2__.setMemoryShared(wasm, typeof SharedArrayBuffer === 'function' && memory.buffer instanceof SharedArrayBuffer);
        instance = (await WebAssembly.instantiate(wasm, {
            env: {
                memory
            }
        })).instance;
        (0,_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.override)({
            [4 /* CTypeEnum.char */]: instance.exports.readU8,
            [5 /* CTypeEnum.atomic_char */]: instance.exports.readU8,
            [2 /* CTypeEnum.uint8 */]: instance.exports.readU8,
            [3 /* CTypeEnum.atomic_uint8 */]: instance.exports.readU8,
            [6 /* CTypeEnum.uint16 */]: instance.exports.readU16,
            [7 /* CTypeEnum.atomic_uint16 */]: instance.exports.readU16,
            [8 /* CTypeEnum.uint32 */]: (pointer) => {
                return instance.exports.read32(pointer) >>> 0;
            },
            [9 /* CTypeEnum.atomic_uint32 */]: (pointer) => {
                return instance.exports.read32(pointer) >>> 0;
            },
            [10 /* CTypeEnum.uint64 */]: (pointer) => {
                return BigInt.asUintN(64, instance.exports.read64(pointer));
            },
            [22 /* CTypeEnum.atomic_uint64 */]: (pointer) => {
                return BigInt.asUintN(64, instance.exports.read64(pointer));
            },
            [11 /* CTypeEnum.int8 */]: instance.exports.read8,
            [12 /* CTypeEnum.atomic_int8 */]: instance.exports.read8,
            [13 /* CTypeEnum.int16 */]: instance.exports.read16,
            [14 /* CTypeEnum.atomic_int16 */]: instance.exports.read16,
            [15 /* CTypeEnum.int32 */]: instance.exports.read32,
            [16 /* CTypeEnum.atomic_int32 */]: instance.exports.read32,
            [17 /* CTypeEnum.int64 */]: instance.exports.read64,
            [21 /* CTypeEnum.atomic_int64 */]: instance.exports.read64,
            [18 /* CTypeEnum.float */]: instance.exports.readf32,
            [19 /* CTypeEnum.double */]: instance.exports.readf64,
            [20 /* CTypeEnum.pointer */]: (pointer) => {
                return instance.exports.read32(pointer) >>> 0;
            }
        });
        (0,_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.override)({
            [4 /* CTypeEnum.char */]: instance.exports.write8,
            [5 /* CTypeEnum.atomic_char */]: instance.exports.write8,
            [2 /* CTypeEnum.uint8 */]: instance.exports.write8,
            [3 /* CTypeEnum.atomic_uint8 */]: instance.exports.write8,
            [6 /* CTypeEnum.uint16 */]: instance.exports.write16,
            [7 /* CTypeEnum.atomic_uint16 */]: instance.exports.write16,
            [8 /* CTypeEnum.uint32 */]: instance.exports.write32,
            [9 /* CTypeEnum.atomic_uint32 */]: instance.exports.write32,
            [10 /* CTypeEnum.uint64 */]: instance.exports.write64,
            [22 /* CTypeEnum.atomic_uint64 */]: instance.exports.write64,
            [11 /* CTypeEnum.int8 */]: instance.exports.write8,
            [12 /* CTypeEnum.atomic_int8 */]: instance.exports.write8,
            [13 /* CTypeEnum.int16 */]: instance.exports.write16,
            [14 /* CTypeEnum.atomic_int16 */]: instance.exports.write16,
            [15 /* CTypeEnum.int32 */]: instance.exports.write32,
            [16 /* CTypeEnum.atomic_int32 */]: instance.exports.write32,
            [17 /* CTypeEnum.int64 */]: instance.exports.write64,
            [21 /* CTypeEnum.atomic_int64 */]: instance.exports.write64,
            [18 /* CTypeEnum.float */]: instance.exports.writef32,
            [19 /* CTypeEnum.double */]: instance.exports.writef64,
            [20 /* CTypeEnum.pointer */]: instance.exports.write32
        });
    }
    catch (error) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_5__.warn('memory asm not support, cannot use asm memory function', cheap__fileName__0, 96);
    }
}


/***/ }),

/***/ "./src/cheap/config.ts":
/*!*****************************!*\
  !*** ./src/cheap/config.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HEAP_INITIAL: () => (/* binding */ HEAP_INITIAL),
/* harmony export */   HEAP_MAXIMUM: () => (/* binding */ HEAP_MAXIMUM),
/* harmony export */   HEAP_OFFSET: () => (/* binding */ HEAP_OFFSET),
/* harmony export */   STACK_ALIGNMENT: () => (/* binding */ STACK_ALIGNMENT),
/* harmony export */   STACK_SIZE: () => (/* binding */ STACK_SIZE),
/* harmony export */   USE_THREADS: () => (/* binding */ USE_THREADS)
/* harmony export */ });
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");


/**
 * 是否使用多线程
 */
const USE_THREADS =  true && (common_util_support__WEBPACK_IMPORTED_MODULE_0__["default"].thread || false) && common_util_constant__WEBPACK_IMPORTED_MODULE_1__.SELF.CHEAP_DISABLE_THREAD !== true;
/**
 * 栈地址对齐
 * 栈地址至少是 16 字节对齐，因为 wasm 的基本类型中最大是 v128 16 字节
 */
let STACK_ALIGNMENT = 16;
/**
 * 栈大小，应为 STACK_ALIGNMENT 的整数倍
 */
let STACK_SIZE = 1048576;
/**
 * 堆保留段，可用于静态数据区分配
 */
const HEAP_OFFSET = 1024;
/**
 * 堆初始大小
 */
const HEAP_INITIAL = (common_util_constant__WEBPACK_IMPORTED_MODULE_1__.SELF.CHEAP_HEAP_INITIAL ?? 265);
/**
 * 堆最大大小
 */
const HEAP_MAXIMUM = 32768;


/***/ }),

/***/ "./src/cheap/ctypeEnumImpl.ts":
/*!************************************!*\
  !*** ./src/cheap/ctypeEnumImpl.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_function_isLittleEndian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/function/isLittleEndian */ "./src/common/function/isLittleEndian.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");



let getAllocator;
let getView;
const littleEndian = (0,common_function_isLittleEndian__WEBPACK_IMPORTED_MODULE_0__["default"])();
function writeU8(pointer, value) {
    getView().setUint8(pointer, value);
}
function readU8(pointer) {
    return getView().getUint8(pointer);
}
function writeU16(pointer, value) {
    getView().setUint16(pointer, value, littleEndian);
}
function readU16(pointer) {
    return getView().getUint16(pointer, littleEndian);
}
function writeU32(pointer, value) {
    getView().setUint32(pointer, value, littleEndian);
}
function readU32(pointer) {
    return getView().getUint32(pointer, littleEndian);
}
function writeU64(pointer, value) {
    getView().setBigUint64(pointer, value, littleEndian);
}
function readU64(pointer) {
    return getView().getBigUint64(pointer, littleEndian);
}
function write8(pointer, value) {
    getView().setInt8(pointer, value);
}
function read8(pointer) {
    return getView().getInt8(pointer);
}
function write16(pointer, value) {
    getView().setInt16(pointer, value, littleEndian);
}
function read16(pointer) {
    return getView().getInt16(pointer, littleEndian);
}
function write32(pointer, value) {
    getView().setInt32(pointer, value, littleEndian);
}
function read32(pointer) {
    return getView().getInt32(pointer, littleEndian);
}
function write64(pointer, value) {
    getView().setBigInt64(pointer, value, littleEndian);
}
function read64(pointer) {
    return getView().getBigInt64(pointer, littleEndian);
}
function writef32(pointer, value) {
    getView().setFloat32(pointer, value, littleEndian);
}
function readf32(pointer) {
    return getView().getFloat32(pointer, littleEndian);
}
function writef64(pointer, value) {
    getView().setFloat64(pointer, value, littleEndian);
}
function readf64(pointer) {
    return getView().getFloat64(pointer, littleEndian);
}
function readPointer(pointer) {
    return getView().getUint32(pointer, littleEndian);
}
function writePointer(pointer, value) {
    return getView().setUint32(pointer, value, littleEndian);
}
function init(getAllocator_, getView_) {
    getAllocator = getAllocator_;
    getView = getView_;
    (0,_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_1__.override)({
        [4 /* CTypeEnum.char */]: readU8,
        [5 /* CTypeEnum.atomic_char */]: readU8,
        [2 /* CTypeEnum.uint8 */]: readU8,
        [3 /* CTypeEnum.atomic_uint8 */]: readU8,
        [6 /* CTypeEnum.uint16 */]: readU16,
        [7 /* CTypeEnum.atomic_uint16 */]: readU16,
        [8 /* CTypeEnum.uint32 */]: readU32,
        [9 /* CTypeEnum.atomic_uint32 */]: readU32,
        [10 /* CTypeEnum.uint64 */]: readU64,
        [11 /* CTypeEnum.int8 */]: read8,
        [12 /* CTypeEnum.atomic_int8 */]: read8,
        [13 /* CTypeEnum.int16 */]: read16,
        [14 /* CTypeEnum.atomic_int16 */]: read16,
        [15 /* CTypeEnum.int32 */]: read32,
        [16 /* CTypeEnum.atomic_int32 */]: read32,
        [17 /* CTypeEnum.int64 */]: read64,
        [18 /* CTypeEnum.float */]: readf32,
        [19 /* CTypeEnum.double */]: readf64,
        [20 /* CTypeEnum.pointer */]: readPointer,
        [23 /* CTypeEnum.bool */]: (pointer) => {
            return !!read8(pointer);
        },
        [24 /* CTypeEnum.atomic_bool */]: (pointer) => {
            return !!read8(pointer);
        }
    });
    (0,_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.override)({
        [4 /* CTypeEnum.char */]: writeU8,
        [5 /* CTypeEnum.atomic_char */]: writeU8,
        [2 /* CTypeEnum.uint8 */]: writeU8,
        [3 /* CTypeEnum.atomic_uint8 */]: writeU8,
        [6 /* CTypeEnum.uint16 */]: writeU16,
        [7 /* CTypeEnum.atomic_uint16 */]: writeU16,
        [8 /* CTypeEnum.uint32 */]: writeU32,
        [9 /* CTypeEnum.atomic_uint32 */]: writeU32,
        [10 /* CTypeEnum.uint64 */]: writeU64,
        [11 /* CTypeEnum.int8 */]: write8,
        [12 /* CTypeEnum.atomic_int8 */]: write8,
        [13 /* CTypeEnum.int16 */]: write16,
        [14 /* CTypeEnum.atomic_int16 */]: write16,
        [15 /* CTypeEnum.int32 */]: write32,
        [16 /* CTypeEnum.atomic_int32 */]: write32,
        [17 /* CTypeEnum.int64 */]: write64,
        [18 /* CTypeEnum.float */]: writef32,
        [19 /* CTypeEnum.double */]: writef64,
        [20 /* CTypeEnum.pointer */]: writePointer,
        [23 /* CTypeEnum.bool */]: (pointer, value) => {
            write8(pointer, value ? 1 : 0);
        },
        [24 /* CTypeEnum.atomic_bool */]: ((pointer, value) => {
            write8(pointer, value ? 1 : 0);
        })
    });
}


/***/ }),

/***/ "./src/cheap/ctypeEnumRead.ts":
/*!************************************!*\
  !*** ./src/cheap/ctypeEnumRead.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CTypeEnumRead: () => (/* binding */ CTypeEnumRead),
/* harmony export */   override: () => (/* binding */ override)
/* harmony export */ });
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");

const CTypeEnumRead = {
    [4 /* CTypeEnum.char */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [5 /* CTypeEnum.atomic_char */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [2 /* CTypeEnum.uint8 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [3 /* CTypeEnum.atomic_uint8 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [6 /* CTypeEnum.uint16 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [7 /* CTypeEnum.atomic_uint16 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [8 /* CTypeEnum.uint32 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [9 /* CTypeEnum.atomic_uint32 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [10 /* CTypeEnum.uint64 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [11 /* CTypeEnum.int8 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [12 /* CTypeEnum.atomic_int8 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [13 /* CTypeEnum.int16 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [14 /* CTypeEnum.atomic_int16 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [15 /* CTypeEnum.int32 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [16 /* CTypeEnum.atomic_int32 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [17 /* CTypeEnum.int64 */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [18 /* CTypeEnum.float */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [19 /* CTypeEnum.double */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [20 /* CTypeEnum.pointer */]: function (pointer) {
        throw new Error('unimplemented');
    },
    [0 /* CTypeEnum.null */]: function (pointer) {
        throw new Error('invalid operate');
    },
    [1 /* CTypeEnum.void */]: function (pointer) {
        throw new Error('invalid operate');
    },
    [22 /* CTypeEnum.atomic_uint64 */]: function (pointer) {
        throw new Error('invalid operate');
    },
    [21 /* CTypeEnum.atomic_int64 */]: function (pointer) {
        throw new Error('invalid operate');
    },
    [23 /* CTypeEnum.bool */]: function (pointer) {
        throw new Error('invalid operate');
    },
    [24 /* CTypeEnum.atomic_bool */]: function (pointer) {
        throw new Error('invalid operate');
    }
};
function override(funcs) {
    common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend(CTypeEnumRead, funcs);
}


/***/ }),

/***/ "./src/cheap/ctypeEnumWrite.ts":
/*!*************************************!*\
  !*** ./src/cheap/ctypeEnumWrite.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CTypeEnumWrite: () => (/* binding */ CTypeEnumWrite),
/* harmony export */   override: () => (/* binding */ override)
/* harmony export */ });
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");

const CTypeEnumWrite = {
    [4 /* CTypeEnum.char */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [5 /* CTypeEnum.atomic_char */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [2 /* CTypeEnum.uint8 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [3 /* CTypeEnum.atomic_uint8 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [6 /* CTypeEnum.uint16 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [7 /* CTypeEnum.atomic_uint16 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [8 /* CTypeEnum.uint32 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [9 /* CTypeEnum.atomic_uint32 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [10 /* CTypeEnum.uint64 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [11 /* CTypeEnum.int8 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [12 /* CTypeEnum.atomic_int8 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [13 /* CTypeEnum.int16 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [14 /* CTypeEnum.atomic_int16 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [15 /* CTypeEnum.int32 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [16 /* CTypeEnum.atomic_int32 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [17 /* CTypeEnum.int64 */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [18 /* CTypeEnum.float */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [19 /* CTypeEnum.double */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [20 /* CTypeEnum.pointer */]: function (pointer, value) {
        throw new Error('unimplemented');
    },
    [0 /* CTypeEnum.null */]: function (pointer, value) {
        throw new Error('invalid operate');
    },
    [1 /* CTypeEnum.void */]: function (pointer, value) {
        throw new Error('invalid operate');
    },
    [22 /* CTypeEnum.atomic_uint64 */]: function (pointer, value) {
        throw new Error('invalid operate');
    },
    [21 /* CTypeEnum.atomic_int64 */]: function (pointer, value) {
        throw new Error('invalid operate');
    },
    [23 /* CTypeEnum.bool */]: function (pointer, value) {
        throw new Error('invalid operate');
    },
    [24 /* CTypeEnum.atomic_bool */]: function (pointer, value) {
        throw new Error('invalid operate');
    }
};
function override(funcs) {
    common_util_object__WEBPACK_IMPORTED_MODULE_0__.extend(CTypeEnumWrite, funcs);
}


/***/ }),

/***/ "./src/cheap/definedStruct.ts":
/*!************************************!*\
  !*** ./src/cheap/definedStruct.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   definedStruct: () => (/* binding */ definedStruct),
/* harmony export */   revokeDefinedStruct: () => (/* binding */ revokeDefinedStruct)
/* harmony export */ });
/* harmony import */ var cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/std/sizeof */ "./src/cheap/std/sizeof.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _typedef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typedef */ "./src/cheap/typedef.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_function_toString__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/function/toString */ "./src/common/function/toString.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");









function definedProperty(target, key, get, set) {
    Object.defineProperty(target, key, {
        get,
        set,
        configurable: true,
        enumerable: true
    });
}
/**
 * 指针的值
 *
 * @param address
 * @returns
 */
function getPointerValue(address) {
    return function () {
        return _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[20 /* CTypeEnum.pointer */](address());
    };
}
function getStruct(target, key, address, struct) {
    return function () {
        return target[`__$__${key}`] || (target[`__$__${key}`] = definedStruct(address(), struct));
    };
}
function getCTypeEnumValue(address, type) {
    return function () {
        return _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[type](address());
    };
}
function getBitFieldValue(address, type, bitLen, offset) {
    const shift = _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnum2Bytes[type] * 8 - offset - bitLen;
    const valueMask = Math.pow(2, bitLen) - 1;
    return function () {
        let value = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[type](address());
        return (value >>> shift) & valueMask;
    };
}
function setPointerValue(address) {
    return function (newValue) {
        _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[8 /* CTypeEnum.uint32 */](address(), newValue);
    };
}
function setStruct(obj, key, address, struct) {
    const localKey = `__$__${key}`;
    return function (newValue) {
        const proxy = obj[localKey] || (obj[localKey] = definedStruct(address(), struct));
        common_util_object__WEBPACK_IMPORTED_MODULE_3__.each(newValue, (value, key) => {
            proxy[key] = value;
        });
        obj[localKey] = proxy;
    };
}
function setCTypeEnumValue(address, type) {
    return function (newValue) {
        _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[type](address(), newValue);
    };
}
function setBitFieldValue(address, type, bitLen, offset) {
    let zeroMask = 0;
    let len = _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnum2Bytes[type] * 8;
    for (let i = 0; i < bitLen; i++) {
        zeroMask |= (1 << (len - 1 - (i + offset)));
    }
    const valueMask = Math.pow(2, bitLen) - 1;
    const shift = len - offset - bitLen;
    return function (newValue) {
        const addr = address();
        const value = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[type](addr);
        _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumWrite[type](addr, (value & ~zeroMask) | ((newValue & valueMask) << shift));
    };
}
function definedArrayStruct(address, length, type) {
    const obj = {};
    let size = (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_4__["default"])(type);
    for (let i = 0; i < length; i++) {
        const key = (0,common_function_toString__WEBPACK_IMPORTED_MODULE_5__["default"])(i);
        definedProperty(obj, key, getStruct(obj, key, () => {
            return address() + size * i;
        }, type), setStruct(obj, key, () => {
            return address() + size * i;
        }, type));
    }
    return obj;
}
function definedArrayCTypeEnum(address, length, type) {
    const obj = {};
    let size = (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_4__["default"])(type);
    for (let i = 0; i < length; i++) {
        const key = (0,common_function_toString__WEBPACK_IMPORTED_MODULE_5__["default"])(i);
        definedProperty(obj, key, getCTypeEnumValue(() => {
            return address() + size * i;
        }, type), setCTypeEnumValue(() => {
            return address() + size * i;
        }, type));
    }
    return obj;
}
function getArray(address, target, key) {
    return function () {
        const t = target[`__$__${key}`];
        t[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] = address();
        return t;
    };
}
function setArrayStruct(obj, key, address, length, type) {
    const localKey = `__$__${key}`;
    return function (newValue) {
        let proxy = obj[localKey] || definedArrayStruct(address, length, type);
        proxy[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] = address();
        common_util_array__WEBPACK_IMPORTED_MODULE_7__.each(newValue, (value, key) => {
            proxy[key] = value;
        });
        obj[localKey] = proxy;
    };
}
function setArrayCTypeEnum(obj, key, address, length, type) {
    const localKey = `__$__${key}`;
    return function (newValue) {
        let proxy = obj[localKey] || definedArrayCTypeEnum(address, length, type);
        proxy[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] = address();
        common_util_array__WEBPACK_IMPORTED_MODULE_7__.each(newValue, (value, key) => {
            proxy[key] = value;
        });
        obj[localKey] = proxy;
    };
}
function definedStruct(address, struct) {
    let prototype = common_util_is__WEBPACK_IMPORTED_MODULE_8__.func(struct) ? struct.prototype : struct;
    const obj = {};
    obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] = address;
    Object.setPrototypeOf(obj, prototype);
    while (true) {
        let keysMeta = prototype[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructKeysMeta];
        if (keysMeta) {
            keysMeta.forEach((meta, key) => {
                if (meta[3 /* KeyMetaKey.Array */]) {
                    if (meta[1 /* KeyMetaKey.Pointer */]) {
                        definedProperty(obj, key, getArray(() => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }, obj, key), setArrayCTypeEnum(obj, key, () => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }, meta[4 /* KeyMetaKey.ArrayLength */], 20 /* CTypeEnum.pointer */));
                    }
                    else {
                        if (common_util_is__WEBPACK_IMPORTED_MODULE_8__.func(meta[0 /* KeyMetaKey.Type */]) || common_util_is__WEBPACK_IMPORTED_MODULE_8__.object(meta[0 /* KeyMetaKey.Type */])) {
                            definedProperty(obj, key, getArray(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, obj, key), setArrayStruct(obj, key, () => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[4 /* KeyMetaKey.ArrayLength */], meta[0 /* KeyMetaKey.Type */]));
                        }
                        else {
                            definedProperty(obj, key, getArray(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, obj, key), setArrayCTypeEnum(obj, key, () => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[4 /* KeyMetaKey.ArrayLength */], meta[0 /* KeyMetaKey.Type */]));
                        }
                    }
                }
                else {
                    if (meta[1 /* KeyMetaKey.Pointer */]) {
                        definedProperty(obj, key, getPointerValue(() => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }), setPointerValue(() => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }));
                    }
                    else if (common_util_is__WEBPACK_IMPORTED_MODULE_8__.func(meta[0 /* KeyMetaKey.Type */]) || common_util_is__WEBPACK_IMPORTED_MODULE_8__.object(meta[0 /* KeyMetaKey.Type */])) {
                        definedProperty(obj, key, getStruct(obj, key, () => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }, meta[0 /* KeyMetaKey.Type */]), setStruct(obj, key, () => {
                            return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                        }, meta[0 /* KeyMetaKey.Type */]));
                    }
                    else {
                        if (meta[5 /* KeyMetaKey.BitField */]) {
                            definedProperty(obj, key, getBitFieldValue(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[0 /* KeyMetaKey.Type */], meta[6 /* KeyMetaKey.BitFieldLength */], meta[8 /* KeyMetaKey.BaseBitOffset */]), setBitFieldValue(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[0 /* KeyMetaKey.Type */], meta[6 /* KeyMetaKey.BitFieldLength */], meta[8 /* KeyMetaKey.BaseBitOffset */]));
                        }
                        else {
                            definedProperty(obj, key, getCTypeEnumValue(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[0 /* KeyMetaKey.Type */]), setCTypeEnumValue(() => {
                                return obj[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                            }, meta[0 /* KeyMetaKey.Type */]));
                        }
                    }
                }
            });
        }
        prototype = Object.getPrototypeOf(prototype);
        if (!prototype) {
            break;
        }
    }
    return obj;
}
function revokeDefinedStruct(target) {
    let prototype = Object.getPrototypeOf(target);
    while (true) {
        let keysMeta = prototype[_symbol__WEBPACK_IMPORTED_MODULE_6__.symbolStructKeysMeta];
        if (keysMeta) {
            keysMeta.forEach((meta, key) => {
                delete target[key];
            });
        }
        prototype = Object.getPrototypeOf(prototype);
        if (!prototype) {
            break;
        }
    }
}


/***/ }),

/***/ "./src/cheap/function/definedMetaProperty.ts":
/*!***************************************************!*\
  !*** ./src/cheap/function/definedMetaProperty.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ definedMetaProperty)
/* harmony export */ });
function definedMetaProperty(target, key, value) {
    Object.defineProperty(target, key, {
        value,
        writable: false,
        enumerable: false,
        configurable: false
    });
}


/***/ }),

/***/ "./src/cheap/heap.ts":
/*!***************************!*\
  !*** ./src/cheap/heap.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Allocator: () => (/* binding */ Allocator),
/* harmony export */   Memory: () => (/* binding */ Memory),
/* harmony export */   StackPointer: () => (/* binding */ StackPointer),
/* harmony export */   StackTop: () => (/* binding */ StackTop),
/* harmony export */   Table: () => (/* binding */ Table),
/* harmony export */   allocThreadId: () => (/* binding */ allocThreadId),
/* harmony export */   getHeap16: () => (/* binding */ getHeap16),
/* harmony export */   getHeap32: () => (/* binding */ getHeap32),
/* harmony export */   getHeap64: () => (/* binding */ getHeap64),
/* harmony export */   getHeap8: () => (/* binding */ getHeap8),
/* harmony export */   getHeapF32: () => (/* binding */ getHeapF32),
/* harmony export */   getHeapF64: () => (/* binding */ getHeapF64),
/* harmony export */   getHeapU16: () => (/* binding */ getHeapU16),
/* harmony export */   getHeapU32: () => (/* binding */ getHeapU32),
/* harmony export */   getHeapU64: () => (/* binding */ getHeapU64),
/* harmony export */   getHeapU8: () => (/* binding */ getHeapU8),
/* harmony export */   getView: () => (/* binding */ getView)
/* harmony export */ });
/* unused harmony exports ThreadId, isMainThread, ThreadName, StackSize, getAtomicsBuffer, initThread, initMain */
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var _allocator_AllocatorJS__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./allocator/AllocatorJS */ "./src/cheap/allocator/AllocatorJS.ts");
/* harmony import */ var _allocator_Table__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./allocator/Table */ "./src/cheap/allocator/Table.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./config */ "./src/cheap/config.ts");
/* harmony import */ var _staticData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./staticData */ "./src/cheap/staticData.ts");
/* harmony import */ var _thread_atomicsImpl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./thread/atomicsImpl */ "./src/cheap/thread/atomicsImpl.ts");
/* harmony import */ var _asm_memory__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./asm/memory */ "./src/cheap/asm/memory.ts");
/* harmony import */ var _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./thread/asm/atomics */ "./src/cheap/thread/asm/atomics.ts");
/* harmony import */ var _ctypeEnumImpl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ctypeEnumImpl */ "./src/cheap/ctypeEnumImpl.ts");
/* harmony import */ var common_function_isAudioWorklet__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! common/function/isAudioWorklet */ "./src/common/function/isAudioWorklet.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");













/**
 * 线程 id
 */
let ThreadId = -1;
let isMainThread = true;
/**
 * 线程名
 */
let ThreadName = '';
/**
 * 当前线程的栈顶指针
 */
let StackPointer = null;
/**
 * 栈结束位置
 */
let StackTop = null;
/**
 * 当前线程栈大小
 */
let StackSize = 0;
/**
 * 当前线程的 Table
 */
let Table = null;
/**
 * 堆分配器
 */
let Allocator = null;
/**
 * 堆
 */
let Memory = null;
/**
 * 1 字节整型读取
 * - int8
 * - -128 to 127
 */
let Heap8 = null;
/**
 * 2 字节整型读取
 * - int16
 * - -32768 to 32767
 */
let Heap16 = null;
/**
 * 4 字节整型读取
 * - int32
 * - -2147483648 to 2147483647
 */
let Heap32 = null;
/**
 * 8 字节整型读取
 * - int64
 * - 0 to 4294967295
 */
let Heap64 = null;
/**
 * 1 字节无符号整型读取
 * - uint8
 * - 0 to 255
 */
let HeapU8 = null;
/**
 * 2 字节无符号整型读取
 * - uint16
 * - 0 to 65535
 */
let HeapU16 = null;
/**
 * 4 字节无符号整型读取
 * - uint32
 * - 0 to 4294967295
 */
let HeapU32 = null;
/**
 * 8 字节无符号整型读取
 * - uint64
 * - 0 to 4294967295
 */
let HeapU64 = null;
/**
 * 32 位浮点数
 * float
 */
let HeapFloat32 = null;
/**
 * 64 位浮点数
 * double
 */
let HeapFloat64 = null;
/**
 * 堆访问器
 */
let view = null;
let AtomicBufferMap = {
    [5 /* CTypeEnum.atomic_char */]: HeapU8,
    [3 /* CTypeEnum.atomic_uint8 */]: HeapU8,
    [7 /* CTypeEnum.atomic_uint16 */]: HeapU16,
    [9 /* CTypeEnum.atomic_uint32 */]: HeapU32,
    [22 /* CTypeEnum.atomic_uint64 */]: HeapU64,
    [12 /* CTypeEnum.atomic_int8 */]: Heap8,
    [14 /* CTypeEnum.atomic_int16 */]: Heap16,
    [16 /* CTypeEnum.atomic_int32 */]: Heap32,
    [21 /* CTypeEnum.atomic_int64 */]: Heap64
};
function checkHeap() {
    if (Memory && Memory.buffer !== HeapU8.buffer) {
        return true;
    }
    return false;
}
function getHeapU8() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapU8;
}
function getHeap8() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return Heap8;
}
function getHeapU16() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapU16;
}
function getHeap16() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return Heap16;
}
function getHeapU32() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapU32;
}
function getHeap32() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return Heap32;
}
function getHeap64() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return Heap64;
}
function getHeapU64() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapU64;
}
function getHeapF32() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapFloat32;
}
function getHeapF64() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return HeapFloat64;
}
function getView() {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return view;
}
function getAtomicsBuffer(type) {
    if ( true && checkHeap()) {
        updateHeap(Memory.buffer);
    }
    return AtomicBufferMap[type];
}
function setAllocator(a) {
    if (Allocator) {
        Allocator.removeUpdateHandle(updateHeap);
    }
    Allocator = a;
    if (common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap) {
        common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.Allocator = Allocator;
    }
    Allocator.addUpdateHandle(updateHeap);
    updateHeap(Allocator.getBuffer());
}
function updateHeap(heap) {
    Heap8 = new Int8Array(heap);
    Heap16 = new Int16Array(heap);
    Heap32 = new Int32Array(heap);
    Heap64 = new BigInt64Array(heap);
    HeapU8 = new Uint8Array(heap);
    HeapU16 = new Uint16Array(heap);
    HeapU32 = new Uint32Array(heap);
    HeapU64 = new BigUint64Array(heap);
    HeapFloat32 = new Float32Array(heap);
    HeapFloat64 = new Float64Array(heap);
    view = new DataView(heap);
    AtomicBufferMap = {
        [5 /* CTypeEnum.atomic_char */]: HeapU8,
        [3 /* CTypeEnum.atomic_uint8 */]: HeapU8,
        [7 /* CTypeEnum.atomic_uint16 */]: HeapU16,
        [9 /* CTypeEnum.atomic_uint32 */]: HeapU32,
        [22 /* CTypeEnum.atomic_uint64 */]: HeapU64,
        [12 /* CTypeEnum.atomic_int8 */]: Heap8,
        [14 /* CTypeEnum.atomic_int16 */]: Heap16,
        [16 /* CTypeEnum.atomic_int32 */]: Heap32,
        [21 /* CTypeEnum.atomic_int64 */]: Heap64
    };
}
function allocThreadId() {
    return Atomics.add(HeapU32, _staticData__WEBPACK_IMPORTED_MODULE_1__.threadCounter >>> 2, 1);
}
/**
 * 子线程初始化
 *
 * @param options
 */
async function initThread(options) {
    (0,_ctypeEnumImpl__WEBPACK_IMPORTED_MODULE_2__["default"])(() => {
        return Allocator;
    }, getView);
    (0,_thread_atomicsImpl__WEBPACK_IMPORTED_MODULE_3__["default"])(getAtomicsBuffer);
    Memory = options.memory;
    const allocator = new _allocator_AllocatorJS__WEBPACK_IMPORTED_MODULE_4__["default"]({
        buffer: Memory.buffer,
        memory: Memory,
        byteOffset: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_OFFSET,
        growAllowed: true,
        onResize(old, need) {
            Memory.grow((need - old.byteLength) >>> 16);
            return {
                buffer: Memory.buffer,
                byteOffset: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_OFFSET
            };
        }
    }, false);
    setAllocator(allocator);
    if (options.stackPointer) {
        StackSize = options.stackSize;
        StackTop = options.stackPointer;
        StackPointer = new WebAssembly.Global({
            value: 'i32',
            mutable: true
        }, StackTop + StackSize);
        Table = new _allocator_Table__WEBPACK_IMPORTED_MODULE_6__.WebassemblyTable();
    }
    if (typeof options.id === 'number') {
        ThreadId = options.id;
    }
    else {
        ThreadId = Atomics.add(HeapU32, _staticData__WEBPACK_IMPORTED_MODULE_1__.threadCounter >>> 2, 1);
    }
    ThreadName = options.name ?? 'anonymous';
    common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap = {
        initThread,
        Allocator,
        Table,
        ThreadId,
        ThreadName,
        Memory,
        StackSize,
        StackTop,
        StackPointer,
        isMainThread: false
    };
    isMainThread = false;
    {
        if (!options.disableAsm) {
            // @ts-ignore
            if (typeof BigInt === 'function' && BigInt !== Number
                && (common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].chrome && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '85', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].firefox && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '78', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].safari && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '15', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].newEdge)) {
                await (0,_asm_memory__WEBPACK_IMPORTED_MODULE_8__["default"])(Memory);
            }
            if ( true && _config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS
                && (common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].chrome && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '85', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].firefox && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '78', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].safari && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '15', true)
                    || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].newEdge)) {
                await (0,_thread_asm_atomics__WEBPACK_IMPORTED_MODULE_9__["default"])(Memory);
            }
        }
    }
}
/**
 * 主线程初始化
 */
function initMain() {
    (0,_ctypeEnumImpl__WEBPACK_IMPORTED_MODULE_2__["default"])(() => {
        return Allocator;
    }, getView);
    (0,_thread_atomicsImpl__WEBPACK_IMPORTED_MODULE_3__["default"])(getAtomicsBuffer);
    Memory = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.Memory ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.Memory : new WebAssembly.Memory({
        initial: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_INITIAL,
        maximum: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_MAXIMUM,
        shared: _config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS
    });
    Allocator = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.Allocator ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.Allocator : new _allocator_AllocatorJS__WEBPACK_IMPORTED_MODULE_4__["default"]({
        buffer: Memory.buffer,
        memory: Memory,
        byteOffset: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_OFFSET,
        growAllowed: true,
        onResize(old, need) {
            Memory.grow((need - old.byteLength) >>> 16);
            return {
                buffer: Memory.buffer,
                byteOffset: _config__WEBPACK_IMPORTED_MODULE_5__.HEAP_OFFSET
            };
        }
    });
    Allocator.addUpdateHandle(updateHeap);
    updateHeap(Allocator.getBuffer());
    StackSize = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.StackSize ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.StackSize : _config__WEBPACK_IMPORTED_MODULE_5__.STACK_SIZE;
    StackTop = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.StackTop ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.StackTop : Allocator.malloc(StackSize);
    StackPointer = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.StackPointer ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.StackPointer : new WebAssembly.Global({
        value: 'i32',
        mutable: true
    }, StackTop + StackSize);
    Table = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.Table ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.Table : new _allocator_Table__WEBPACK_IMPORTED_MODULE_6__.WebassemblyTable();
    ThreadId = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.ThreadId ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.ThreadId : 0;
    ThreadName = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.ThreadName ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.ThreadName : 'main';
    if (!common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap) {
        if (_config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS && true) {
            Atomics.store(HeapU32, _staticData__WEBPACK_IMPORTED_MODULE_1__.threadCounter >>> 2, ThreadId + 1);
            Atomics.store(Heap32, _staticData__WEBPACK_IMPORTED_MODULE_1__.heapMutex >>> 2, 0);
        }
        else {
            HeapU32[_staticData__WEBPACK_IMPORTED_MODULE_1__.threadCounter >>> 2] = ThreadId + 1;
            let index = _staticData__WEBPACK_IMPORTED_MODULE_1__.heapMutex >>> 2;
            Heap32[index] = 0;
        }
    }
    {
        // @ts-ignore
        if (typeof BigInt === 'function' && BigInt !== Number
            && (common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].chrome && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '85', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].firefox && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '78', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].safari && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '15', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].newEdge)) {
            (0,_asm_memory__WEBPACK_IMPORTED_MODULE_8__["default"])(Memory);
        }
        if (_config__WEBPACK_IMPORTED_MODULE_5__.USE_THREADS
            && true
            && (common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].chrome && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '85', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].firefox && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '78', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].safari && common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].majorVersion, '15', true)
                || common_util_browser__WEBPACK_IMPORTED_MODULE_7__["default"].newEdge)) {
            (0,_thread_asm_atomics__WEBPACK_IMPORTED_MODULE_9__["default"])(Memory);
        }
    }
    if (!common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap) {
        common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap = {
            Allocator,
            Table,
            ThreadId,
            ThreadName,
            Memory,
            StackSize,
            StackTop,
            StackPointer,
            isMainThread: true,
            threadCounter: _staticData__WEBPACK_IMPORTED_MODULE_1__.threadCounter,
            heapMutex: _staticData__WEBPACK_IMPORTED_MODULE_1__.heapMutex
        };
    }
    isMainThread = true;
}
{
    if (!(0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_10__["default"])() && !(0,common_function_isAudioWorklet__WEBPACK_IMPORTED_MODULE_11__["default"])()) {
        initMain();
    }
    else {
        common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap = {
            initThread,
            isMainThread: false
        };
        isMainThread = false;
    }
}


/***/ }),

/***/ "./src/cheap/proxyStruct.ts":
/*!**********************************!*\
  !*** ./src/cheap/proxyStruct.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   proxyStruct: () => (/* binding */ proxyStruct),
/* harmony export */   revokeProxyStruct: () => (/* binding */ revokeProxyStruct)
/* harmony export */ });
/* unused harmony export findKeyMeta */
/* harmony import */ var cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/sizeof */ "./src/cheap/std/sizeof.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _typedef__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./typedef */ "./src/cheap/typedef.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_function_toNumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/function/toNumber */ "./src/common/function/toNumber.ts");









const ObjectPro = Object.getPrototypeOf({});
function findKeyMeta(prototype, key) {
    while (true) {
        let keysMeta = prototype[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructKeysMeta];
        if (keysMeta) {
            const meta = keysMeta.get(key);
            if (meta) {
                return meta;
            }
        }
        prototype = Object.getPrototypeOf(prototype);
        if (!prototype || prototype === ObjectPro) {
            return null;
        }
    }
}
function proxyArray(address, length, type, pointer) {
    const obj = {};
    obj[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] = address;
    let size = (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_1__["default"])(pointer ? 20 /* CTypeEnum.pointer */ : type);
    const proxy = new Proxy(obj, {
        get(target, propertyKey, receiver) {
            if (propertyKey === _symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress) {
                return target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress];
            }
            const index = (0,common_function_toNumber__WEBPACK_IMPORTED_MODULE_2__["default"])(propertyKey);
            if (pointer) {
                return _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20 /* CTypeEnum.pointer */](target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + index * size);
            }
            else {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.func(type)) {
                    return target[propertyKey];
                }
                else {
                    return _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[type](target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + index * size);
                }
            }
        },
        set(target, propertyKey, newValue, receiver) {
            if (propertyKey === _symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress) {
                target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] = newValue;
                return true;
            }
            const index = (0,common_function_toNumber__WEBPACK_IMPORTED_MODULE_2__["default"])(propertyKey);
            if (pointer) {
                _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[20 /* CTypeEnum.pointer */](target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + index * size, newValue);
                target[propertyKey] = newValue;
            }
            else {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.func(type)) {
                    const proxy = target[propertyKey] || (target[propertyKey] = proxyStruct(target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + index * size, type));
                    common_util_object__WEBPACK_IMPORTED_MODULE_6__.each(newValue, (value, key) => {
                        proxy[key] = value;
                    });
                    target[propertyKey] = proxy;
                }
                else {
                    _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[type](target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + index * size, newValue);
                    target[propertyKey] = newValue;
                }
            }
            return true;
        }
    });
    return proxy;
}
function proxyStruct(address, struct) {
    const prototype = common_util_is__WEBPACK_IMPORTED_MODULE_4__.func(struct) ? struct.prototype : struct;
    const obj = {};
    obj[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] = address;
    Object.setPrototypeOf(obj, prototype);
    const { proxy, revoke } = Proxy.revocable(obj, {
        get(target, propertyKey, receiver) {
            if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.string(propertyKey)) {
                const meta = findKeyMeta(prototype, propertyKey.replace(/^\$+/, ''));
                if (meta) {
                    const address = target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                    if (meta[3 /* KeyMetaKey.Array */]) {
                        const t = target[propertyKey];
                        t[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] = address;
                        return t;
                    }
                    else if (meta[1 /* KeyMetaKey.Pointer */]) {
                        let p = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[20 /* CTypeEnum.pointer */](address);
                        return p;
                    }
                    else if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.func(meta[0 /* KeyMetaKey.Type */]) || common_util_is__WEBPACK_IMPORTED_MODULE_4__.object(meta[0 /* KeyMetaKey.Type */])) {
                        return target[propertyKey] || (target[propertyKey] = proxyStruct(address, meta[0 /* KeyMetaKey.Type */]));
                    }
                    else {
                        let value = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[meta[0 /* KeyMetaKey.Type */]](address);
                        if (meta[5 /* KeyMetaKey.BitField */]) {
                            value = ((value >>> (_typedef__WEBPACK_IMPORTED_MODULE_7__.CTypeEnum2Bytes[meta[0 /* KeyMetaKey.Type */]] * 8 - meta[8 /* KeyMetaKey.BaseBitOffset */] - meta[6 /* KeyMetaKey.BitFieldLength */]))
                                & (Math.pow(2, meta[6 /* KeyMetaKey.BitFieldLength */]) - 1));
                        }
                        return value;
                    }
                }
                else {
                    return target[propertyKey];
                }
            }
            else {
                return target[propertyKey];
            }
        },
        set(target, propertyKey, newValue, receiver) {
            if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.string(propertyKey)) {
                const meta = findKeyMeta(prototype, propertyKey.replace(/^\$+/, ''));
                if (meta) {
                    const address = target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructAddress] + meta[7 /* KeyMetaKey.BaseAddressOffset */];
                    if (meta[3 /* KeyMetaKey.Array */]) {
                        const proxy = target[propertyKey] || proxyArray(address, meta[4 /* KeyMetaKey.ArrayLength */], meta[0 /* KeyMetaKey.Type */], meta[1 /* KeyMetaKey.Pointer */]);
                        common_util_array__WEBPACK_IMPORTED_MODULE_8__.each(newValue, (value, key) => {
                            proxy[key] = value;
                        });
                        target[propertyKey] = proxy;
                    }
                    else {
                        if (meta[1 /* KeyMetaKey.Pointer */]) {
                            _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[20 /* CTypeEnum.pointer */](address, newValue);
                            target[propertyKey] = newValue;
                        }
                        else if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.func(meta[0 /* KeyMetaKey.Type */]) || common_util_is__WEBPACK_IMPORTED_MODULE_4__.object(meta[0 /* KeyMetaKey.Type */])) {
                            const proxy = target[propertyKey] || (target[propertyKey] = proxyStruct(address, meta[0 /* KeyMetaKey.Type */]));
                            common_util_object__WEBPACK_IMPORTED_MODULE_6__.each(newValue, (value, key) => {
                                proxy[key] = value;
                            });
                            target[propertyKey] = proxy;
                        }
                        else {
                            if (meta[5 /* KeyMetaKey.BitField */]) {
                                let mask = 0;
                                let len = _typedef__WEBPACK_IMPORTED_MODULE_7__.CTypeEnum2Bytes[meta[0 /* KeyMetaKey.Type */]] * 8;
                                for (let i = 0; i < meta[6 /* KeyMetaKey.BitFieldLength */]; i++) {
                                    mask |= (1 << (len - 1 - (i + meta[8 /* KeyMetaKey.BaseBitOffset */])));
                                }
                                const value = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[meta[0 /* KeyMetaKey.Type */]](address);
                                _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[meta[0 /* KeyMetaKey.Type */]](address, (value & ~mask) | ((newValue & (Math.pow(2, meta[6 /* KeyMetaKey.BitFieldLength */]) - 1))
                                    << (len - meta[8 /* KeyMetaKey.BaseBitOffset */] - meta[6 /* KeyMetaKey.BitFieldLength */])));
                            }
                            else {
                                _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[meta[0 /* KeyMetaKey.Type */]](address, newValue);
                            }
                            target[propertyKey] = newValue;
                        }
                    }
                }
                else {
                    target[propertyKey] = newValue;
                }
            }
            else {
                target[propertyKey] = newValue;
            }
            return true;
        }
    });
    obj[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructProxyRevoke] = revoke;
    return proxy;
}
function revokeProxyStruct(target) {
    const revoke = target[_symbol__WEBPACK_IMPORTED_MODULE_0__.symbolStructProxyRevoke];
    if (revoke) {
        revoke();
    }
}


/***/ }),

/***/ "./src/cheap/stack.ts":
/*!****************************!*\
  !*** ./src/cheap/stack.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   free: () => (/* binding */ free),
/* harmony export */   malloc: () => (/* binding */ malloc)
/* harmony export */ });
/* harmony import */ var _heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./heap */ "./src/cheap/heap.ts");

function malloc(size) {
    _heap__WEBPACK_IMPORTED_MODULE_0__.StackPointer.value -= size;
    return _heap__WEBPACK_IMPORTED_MODULE_0__.StackPointer.value;
}
function free(size) {
    _heap__WEBPACK_IMPORTED_MODULE_0__.StackPointer.value += size;
}


/***/ }),

/***/ "./src/cheap/staticData.ts":
/*!*********************************!*\
  !*** ./src/cheap/staticData.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   heapMutex: () => (/* binding */ heapMutex),
/* harmony export */   threadCounter: () => (/* binding */ threadCounter)
/* harmony export */ });
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/**
 * 静态分配区只能在此文件分配
 * 导出在其他地方使用
 */



/**
 * 静态分配区栈顶指针
 */
let pointer = (0) + 1;
function malloc(length, algin = 1) {
    let address = pointer;
    while (address % algin) {
        address = address + 1;
    }
    pointer = address + length;
    return address;
}
/**
 * 线程计数器地址
 */
const threadCounter = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.threadCounter
    ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.threadCounter
    : malloc(4, 4);
/**
 * 堆分配锁地址
 */
const heapMutex = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap?.heapMutex
    ? common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.heapMutex
    : malloc(4, 4);


/***/ }),

/***/ "./src/cheap/std/buffer/SafeUint8Array.ts":
/*!************************************************!*\
  !*** ./src/cheap/std/buffer/SafeUint8Array.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SafeUint8Array)
/* harmony export */ });
/* unused harmony export SafeBufferView */
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../heap */ "./src/cheap/heap.ts");
/* harmony import */ var common_interface_ArrayLike__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/interface/ArrayLike */ "./src/common/interface/ArrayLike.ts");




class SafeBufferView {
    pointer;
    len;
    constructor(pointer, len) {
        this.pointer = pointer;
        this.len = len;
    }
    get byteLength() {
        return this.len;
    }
    get buffer() {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().buffer;
    }
    get byteOffset() {
        return this.pointer;
    }
    getFloat32(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getFloat32(this.pointer + byteOffset, littleEndian);
    }
    getFloat64(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getFloat64(this.pointer + byteOffset, littleEndian);
    }
    getInt8(byteOffset) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getInt8(this.pointer + byteOffset);
    }
    getInt16(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getInt16(this.pointer + byteOffset, littleEndian);
    }
    getInt32(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getInt32(this.pointer + byteOffset, littleEndian);
    }
    getUint8(byteOffset) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getUint8(this.pointer + byteOffset);
    }
    getUint16(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getUint16(this.pointer + byteOffset, littleEndian);
    }
    getUint32(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getUint32(this.pointer + byteOffset, littleEndian);
    }
    setFloat32(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setFloat32(this.pointer + byteOffset, value, littleEndian);
    }
    setFloat64(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setFloat64(this.pointer + byteOffset, value, littleEndian);
    }
    setInt8(byteOffset, value) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setInt8(this.pointer + byteOffset, value);
    }
    setInt16(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setInt16(this.pointer + byteOffset, value, littleEndian);
    }
    setInt32(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setInt32(this.pointer + byteOffset, value, littleEndian);
    }
    setUint8(byteOffset, value) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setUint8(this.pointer + byteOffset, value);
    }
    setUint16(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setUint16(this.pointer + byteOffset, value, littleEndian);
    }
    setUint32(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setUint32(this.pointer + byteOffset, value, littleEndian);
    }
    getBigInt64(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getBigInt64(this.pointer + byteOffset, littleEndian);
    }
    getBigUint64(byteOffset, littleEndian) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().getBigUint64(this.pointer + byteOffset, littleEndian);
    }
    setBigInt64(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setBigInt64(this.pointer + byteOffset, value, littleEndian);
    }
    setBigUint64(byteOffset, value, littleEndian) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getView)().setBigUint64(this.pointer + byteOffset, value, littleEndian);
    }
}
class SafeUint8Array extends common_interface_ArrayLike__WEBPACK_IMPORTED_MODULE_1__["default"] {
    pointer;
    len;
    constructor(pointer, len) {
        super();
        this.pointer = pointer;
        this.len = len;
        return this.proxy;
    }
    getIndexValue(index) {
        return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[2](this.pointer + index);
    }
    setIndexValue(index, value) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[2](this.pointer + index, value);
    }
    set(array, offset = 0) {
        (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().set(array, this.pointer + offset);
    }
    subarray(begin = 0, end, safe) {
        if (safe) {
            return new SafeUint8Array(this.pointer + begin, (end ? end : this.len) - begin);
        }
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().subarray(this.pointer + begin, this.pointer + (end ?? this.len));
    }
    slice(start = 0, end) {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().slice(this.pointer + start, this.pointer + (end ?? this.len));
    }
    get length() {
        return this.len;
    }
    get byteLength() {
        return this.len;
    }
    get buffer() {
        return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().buffer;
    }
    get byteOffset() {
        return this.pointer;
    }
    get view() {
        return new SafeBufferView(this.pointer, this.len);
    }
}


/***/ }),

/***/ "./src/cheap/std/collection/List.ts":
/*!******************************************!*\
  !*** ./src/cheap/std/collection/List.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ List)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/std/sizeof */ "./src/cheap/std/sizeof.ts");
/* harmony import */ var _std_memory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var _structAccess__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../structAccess */ "./src/cheap/std/structAccess.ts");












class ListNode {
    prev;
    next;
    data;
}
(function (prototype) {
    var map = new Map();
    map.set("prev", { 0: ListNode, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("next", { 0: ListNode, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("data", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructLength, 12);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructKeysMeta, map);
})(ListNode.prototype);
class List {
    length = 0;
    head = 0;
    tail = 0;
    createNode(item, type, move = false) {
        const pNode = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(12);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](pNode + 4, 0);
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](pNode, 0);
        if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.number(type)) {
            if (type === 20) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](pNode + 8, item);
            }
            else {
                const p = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc((0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_5__["default"])(type));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[type](p, item);
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](pNode + 8, p);
            }
        }
        else {
            if (move) {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](pNode + 8, item);
            }
            else {
                const p = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc((0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_5__["default"])(type));
                (0,_std_memory__WEBPACK_IMPORTED_MODULE_6__.memcpy)(p, item[cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructAddress], (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_5__["default"])(type));
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](pNode + 8, p);
            }
        }
        return pNode;
    }
    getItem(data, type) {
        let result;
        if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.number(type)) {
            if (type === 20) {
                result = data;
            }
            else {
                result = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[type](data);
            }
        }
        else {
            result = (0,_structAccess__WEBPACK_IMPORTED_MODULE_8__["default"])(data, type);
        }
        return result;
    }
    push(item, type, move = false) {
        const pNode = this.createNode(item, type, move);
        if (!this.tail) {
            this.head = pNode;
            this.tail = pNode;
        }
        else {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](this.tail + 4, pNode);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](pNode, this.tail);
            this.tail = pNode;
        }
        this.length++;
    }
    pop(type) {
        const pNode = this.tail;
        let result = this.getItem(_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](pNode + 8), type);
        if (this.length > 1) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](pNode) + 4, 0);
            this.tail = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](pNode);
        }
        else {
            this.head = 0, this.tail = 0;
        }
        this.length--;
        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](pNode + 8));
        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(pNode);
        return result;
    }
    shift(type) {
        const pNode = this.head;
        let result = this.getItem(_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](pNode + 8), type);
        if (this.length > 1) {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](pNode + 4), 0);
            this.head = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](pNode + 4);
        }
        else {
            this.head = 0, this.tail = 0;
        }
        this.length--;
        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](pNode + 8));
        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(pNode);
        return result;
    }
    unshift(item, type, move = false) {
        const pNode = this.createNode(item, type, move);
        if (!this.head) {
            this.head = pNode;
            this.tail = pNode;
        }
        else {
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](this.head, pNode);
            cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumWrite[20](pNode + 4, this.head);
            this.head = pNode;
        }
        this.length++;
    }
    forEach(callback, type) {
        if (!this.length) {
            return;
        }
        let current = this.head;
        let index = 0;
        while (current !== 0) {
            if (callback(this.getItem(_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](current + 8), type), index) === false) {
                break;
            }
            current = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](current + 4);
            index++;
        }
    }
    find(callback, type) {
        if (!this.length) {
            return 0;
        }
        let current = this.head;
        let index = 0;
        while (current !== 0) {
            const item = this.getItem(_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](current + 8), type);
            if (callback(item, index) === true) {
                return item;
            }
            current = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](current + 4);
            index++;
        }
        return 0;
    }
    indexOf(index, type) {
        if (!this.length) {
            return 0;
        }
        let current = this.head;
        let i = 0;
        while (current !== 0) {
            if (i === index) {
                return this.getItem(_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](current + 8), type);
            }
            current = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](current + 4);
            i++;
        }
        return 0;
    }
    clear(callback, type) {
        if (this.length) {
            let current = this.head;
            while (current !== 0) {
                if (callback) {
                    callback(this.getItem(_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](current + 8), type));
                }
                cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](current + 8));
                const next = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumRead[20](current + 4);
                cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(current);
                current = next;
            }
        }
        this.head = 0, this.tail = 0;
        this.length = 0;
    }
}
(function (prototype) {
    var map = new Map();
    map.set("length", { 0: 8, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("head", { 0: ListNode, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("tail", { 0: ListNode, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructLength, 12);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructKeysMeta, map);
})(List.prototype);


/***/ }),

/***/ "./src/cheap/std/make.ts":
/*!*******************************!*\
  !*** ./src/cheap/std/make.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ make)
/* harmony export */ });
/* harmony import */ var cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/std/sizeof */ "./src/cheap/std/sizeof.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var _memory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_function_isDef__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/function/isDef */ "./src/common/function/isDef.ts");
/* harmony import */ var _structAccess__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./structAccess */ "./src/cheap/std/structAccess.ts");







/**
 * 创建一个 struct 实例
 *
 * @param target
 * @returns
 */
function make(struct, init) {
    const size = (0,cheap_std_sizeof__WEBPACK_IMPORTED_MODULE_1__["default"])(struct);
    const address = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(size);
    if (!address) {
        throw new TypeError('cannot alloc memory for struct');
    }
    (0,_memory__WEBPACK_IMPORTED_MODULE_2__.memset)(address, 0, size);
    const target = (0,_structAccess__WEBPACK_IMPORTED_MODULE_3__["default"])(address, struct);
    const data = new struct();
    if (init) {
        common_util_object__WEBPACK_IMPORTED_MODULE_4__.extend(data, init);
    }
    common_util_object__WEBPACK_IMPORTED_MODULE_4__.each(data, (value, key) => {
        if ((0,common_function_isDef__WEBPACK_IMPORTED_MODULE_5__["default"])(value)) {
            target[key] = value;
        }
    });
    return target;
}


/***/ }),

/***/ "./src/cheap/std/memory.ts":
/*!*********************************!*\
  !*** ./src/cheap/std/memory.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapFloat32Array: () => (/* binding */ mapFloat32Array),
/* harmony export */   mapInt16Array: () => (/* binding */ mapInt16Array),
/* harmony export */   mapInt32Array: () => (/* binding */ mapInt32Array),
/* harmony export */   mapSafeUint8Array: () => (/* binding */ mapSafeUint8Array),
/* harmony export */   mapUint8Array: () => (/* binding */ mapUint8Array),
/* harmony export */   memcpy: () => (/* binding */ memcpy),
/* harmony export */   memcpyFromUint8Array: () => (/* binding */ memcpyFromUint8Array),
/* harmony export */   memset: () => (/* binding */ memset)
/* harmony export */ });
/* unused harmony exports memmove, mapInt8Array, mapUint16Array, mapUint32Array, mapUint64Array, mapInt64Array, mapFloat64Array, readCString, writeCString */
/* harmony import */ var _heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../heap */ "./src/cheap/heap.ts");
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./string */ "./src/cheap/std/string.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");
/* harmony import */ var _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _buffer_SafeUint8Array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buffer/SafeUint8Array */ "./src/cheap/std/buffer/SafeUint8Array.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");






function memcpy(dst, src, size) {
    (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().set((0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().subarray(src, src + size), dst);
}
function memcpyFromUint8Array(dst, max, data) {
    (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().set(data.subarray(0, max), dst);
}
function memmove(dst, src, size) {
    (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().copyWithin(dst, src, src + size);
}
function memset(src, c, n) {
    (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().subarray(src, src + n).fill(c);
}
function mapSafeUint8Array(src, n) {
    return _config__WEBPACK_IMPORTED_MODULE_1__.USE_THREADS ? mapUint8Array(src, n) : new _buffer_SafeUint8Array__WEBPACK_IMPORTED_MODULE_2__["default"](src, n);
}
function mapUint8Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU8)().subarray(src, src + n);
}
function mapInt8Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeap8)().subarray(src, src + n);
}
function mapUint16Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU16)().subarray(src >>> 1, (src >>> 1) + n);
}
function mapInt16Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeap16)().subarray(src >>> 1, (src >>> 1) + n);
}
function mapUint32Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU32)().subarray(src >>> 2, (src >>> 2) + n);
}
function mapInt32Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeap32)().subarray(src >>> 2, (src >>> 2) + n);
}
function mapUint64Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapU64)().subarray(src >>> 3, (src >>> 3) + n);
}
function mapInt64Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeap64)().subarray(src >>> 3, (src >>> 3) + n);
}
function mapFloat32Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapF32)().subarray(src >>> 2, (src >>> 2) + n);
}
function mapFloat64Array(src, n) {
    return (0,_heap__WEBPACK_IMPORTED_MODULE_0__.getHeapF64)().subarray(src >>> 3, (src >>> 3) + n);
}
function readCString(pointer, max) {
    const stringLen = (0,_string__WEBPACK_IMPORTED_MODULE_3__.strlen)(pointer);
    const len = Math.min(stringLen, max ?? stringLen);
    return common_util_text__WEBPACK_IMPORTED_MODULE_4__.decode(mapUint8Array(pointer, len));
}
function writeCString(dst, str, max, addNull = true) {
    const data = common_util_text__WEBPACK_IMPORTED_MODULE_4__.encode(str);
    let len = data.length;
    let remain = addNull ? 1 : 0;
    if (max && len - remain > max) {
        len = max - remain;
    }
    memcpyFromUint8Array(dst, len, data);
    if (addNull) {
        _ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[11 /* CTypeEnum.int8 */](dst + len, 0);
    }
}


/***/ }),

/***/ "./src/cheap/std/sizeof.ts":
/*!*********************************!*\
  !*** ./src/cheap/std/sizeof.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ sizeof)
/* harmony export */ });
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var _typedef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../typedef */ "./src/cheap/typedef.ts");



function sizeof(type) {
    if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.number(type)) {
        return _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnum2Bytes[type] || 0;
    }
    else if (common_util_is__WEBPACK_IMPORTED_MODULE_0__.func(type) && type.prototype[_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStruct]) {
        return type.prototype[_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructLength];
    }
    return 0;
}


/***/ }),

/***/ "./src/cheap/std/string.ts":
/*!*********************************!*\
  !*** ./src/cheap/std/string.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   strlen: () => (/* binding */ strlen)
/* harmony export */ });
/* unused harmony exports strcpy, strcat, strcmp */
/* harmony import */ var _memory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");


/**
 * 获取字符串长度，不包括字符串末尾的空字符（\0）
 *
 * @param pointer
 */
function strlen(pointer) {
    let len = 0;
    while (_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[4 /* CTypeEnum.char */]((pointer = pointer + 1, pointer - 1))) {
        len++;
    }
    return len;
}
/**
 * 将一个字符串复制到另一个字符串
 *
 * @param destination
 * @param source
 */
function strcpy(destination, source) {
    const len = strlen(source) + 1;
    (0,_memory__WEBPACK_IMPORTED_MODULE_1__.memcpyFromUint8Array)(destination, len, (0,_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(source, len));
}
/**
 * 将一个字符串追加到另一个字符串的末尾
 *
 * @param destination
 * @param source
 */
function strcat(destination, source) {
    const len = strlen(source) + 1;
    const len1 = strlen(destination);
    (0,_memory__WEBPACK_IMPORTED_MODULE_1__.memcpyFromUint8Array)(destination + len1, len, (0,_memory__WEBPACK_IMPORTED_MODULE_1__.mapUint8Array)(source, len));
}
/**
 * 比较两个字符串的大小
 */
function strcmp(str1, str2) {
    const len1 = strlen(str1);
    const len2 = strlen(str2);
    const len = Math.min(len1, len2);
    for (let i = 0; i < len; i++) {
        const char1 = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[4 /* CTypeEnum.char */](str1 + i);
        const char2 = _ctypeEnumRead__WEBPACK_IMPORTED_MODULE_0__.CTypeEnumRead[4 /* CTypeEnum.char */](str2 + i);
        if (char1 > char2) {
            return 1;
        }
        else if (char1 < char2) {
            return -1;
        }
    }
    if (len1 > len2) {
        return 1;
    }
    else if (len1 < len2) {
        return -1;
    }
    else {
        return 0;
    }
}


/***/ }),

/***/ "./src/cheap/std/structAccess.ts":
/*!***************************************!*\
  !*** ./src/cheap/std/structAccess.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ structAccess)
/* harmony export */ });
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _proxyStruct__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../proxyStruct */ "./src/cheap/proxyStruct.ts");
/* harmony import */ var _definedStruct__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../definedStruct */ "./src/cheap/definedStruct.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_keypath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/keypath */ "./src/common/util/keypath.ts");






/**
 * 访问 struct 指针
 *
 * @param target
 * @param address
 * @returns
 */
function structAccess(address, struct) {
    if (arguments[2] && common_util_is__WEBPACK_IMPORTED_MODULE_0__.string(arguments[2])) {
        struct = struct.prototype;
        common_util_keypath__WEBPACK_IMPORTED_MODULE_1__.each(arguments[2], (key) => {
            const meta = struct[_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructKeysMeta];
            struct = meta.get(key)[0 /* KeyMetaKey.Type */];
        });
    }
    return common_util_support__WEBPACK_IMPORTED_MODULE_3__["default"].proxy ? (0,_proxyStruct__WEBPACK_IMPORTED_MODULE_4__.proxyStruct)(address, struct) : (0,_definedStruct__WEBPACK_IMPORTED_MODULE_5__.definedStruct)(address, struct);
}


/***/ }),

/***/ "./src/cheap/std/unmake.ts":
/*!*********************************!*\
  !*** ./src/cheap/std/unmake.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ unmake)
/* harmony export */ });
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/heap */ "./src/cheap/heap.ts");
/* harmony import */ var _symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var _proxyStruct__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../proxyStruct */ "./src/cheap/proxyStruct.ts");
/* harmony import */ var _definedStruct__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../definedStruct */ "./src/cheap/definedStruct.ts");
/* harmony import */ var common_util_support__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/support */ "./src/common/util/support.ts");





/**
 * 销毁一个 struct 实例，调用 make 创建的对象必须调用 unmake，否则内存泄漏
 *
 * @param target
 */
function unmake(target) {
    const p = target[_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress];
    if (p) {
        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(p);
        target[_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructAddress] = 0;
        common_util_support__WEBPACK_IMPORTED_MODULE_2__["default"].proxy ? (0,_proxyStruct__WEBPACK_IMPORTED_MODULE_3__.revokeProxyStruct)(target) : (0,_definedStruct__WEBPACK_IMPORTED_MODULE_4__.revokeDefinedStruct)(target);
    }
}


/***/ }),

/***/ "./src/cheap/symbol.ts":
/*!*****************************!*\
  !*** ./src/cheap/symbol.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   symbolStruct: () => (/* binding */ symbolStruct),
/* harmony export */   symbolStructAddress: () => (/* binding */ symbolStructAddress),
/* harmony export */   symbolStructKeysMeta: () => (/* binding */ symbolStructKeysMeta),
/* harmony export */   symbolStructLength: () => (/* binding */ symbolStructLength),
/* harmony export */   symbolStructMaxBaseTypeByteLength: () => (/* binding */ symbolStructMaxBaseTypeByteLength),
/* harmony export */   symbolStructProxyRevoke: () => (/* binding */ symbolStructProxyRevoke)
/* harmony export */ });
/* unused harmony exports symbolStructKeysQueue, symbolStructKeysInstance */
const symbolStruct = Symbol('Struct');
const symbolStructLength = Symbol('StructLength');
const symbolStructMaxBaseTypeByteLength = Symbol('StructMaxBaseTypeByteLength');
const symbolStructAddress = Symbol('StructAddress');
const symbolStructKeysQueue = Symbol('StructKeysQueue');
const symbolStructKeysMeta = Symbol('StructKeysMeta');
const symbolStructKeysInstance = Symbol('StructKeysInstance');
const symbolStructProxyRevoke = Symbol('StructProxyRevoke');


/***/ }),

/***/ "./src/cheap/thread/asm/atomics.ts":
/*!*****************************************!*\
  !*** ./src/cheap/thread/asm/atomics.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init),
/* harmony export */   instance: () => (/* binding */ instance),
/* harmony export */   isSupport: () => (/* binding */ isSupport)
/* harmony export */ });
/* harmony import */ var common_util_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/base64 */ "./src/common/util/base64.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_wasm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/wasm */ "./src/common/util/wasm.ts");
/* harmony import */ var _atomics_asm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./atomics.asm */ "./src/cheap/thread/asm/atomics.asm");
/* harmony import */ var _atomics_asm__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_atomics_asm__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../atomics */ "./src/cheap/thread/atomics.ts");
var cheap__fileName__0 = "src/cheap/thread/asm/atomics.ts";





/**
 * WebAssembly runtime 实例
 */
let instance;
function isSupport() {
    return !!instance;
}
async function init(memory) {
    try {
        if (typeof SharedArrayBuffer === 'function' && memory.buffer instanceof SharedArrayBuffer) {
            const wasm = (0,common_util_base64__WEBPACK_IMPORTED_MODULE_0__.base64ToUint8Array)((_atomics_asm__WEBPACK_IMPORTED_MODULE_1___default()));
            common_util_wasm__WEBPACK_IMPORTED_MODULE_2__.setMemoryShared(wasm, true);
            instance = (await WebAssembly.instantiate(wasm, {
                env: {
                    memory
                }
            })).instance;
        }
        else {
            return;
        }
        (0,_atomics__WEBPACK_IMPORTED_MODULE_3__.override)({
            add: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.add8(address, value) & 0xff);
                    case 12:
                        return instance.exports.add8(address, value);
                    case 14:
                        return instance.exports.add16(address, value);
                    case 7:
                        return (instance.exports.add16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.add32(address, value);
                    case 9:
                        return (instance.exports.add32(address, value) & 0xffffffff);
                    case 21:
                        return instance.exports.add64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.add64(address, value));
                }
            },
            sub: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.sub8(address, value) & 0xff);
                    case 12:
                        return instance.exports.sub8(address, value);
                    case 14:
                        return instance.exports.sub16(address, value);
                    case 7:
                        return (instance.exports.sub16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.sub32(address, value);
                    case 9:
                        return (instance.exports.sub32(address, value) & 0xffffffff);
                    case 21:
                        return instance.exports.sub64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.sub64(address, value));
                }
            },
            and: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.and8(address, value) & 0xff);
                    case 12:
                        return instance.exports.and8(address, value);
                    case 14:
                        return instance.exports.and16(address, value);
                    case 7:
                        return (instance.exports.and16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.and32(address, value);
                    case 9:
                        return (instance.exports.and32(address, value) & 0xffffffff);
                    case 21:
                        return instance.exports.and64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.and64(address, value));
                }
            },
            or: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.or8(address, value) & 0xff);
                    case 12:
                        return instance.exports.or8(address, value);
                    case 14:
                        return instance.exports.or16(address, value);
                    case 7:
                        return (instance.exports.or16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.or32(address, value);
                    case 9:
                        return instance.exports.or32(address, value);
                    case 21:
                        return instance.exports.or64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.or64(address, value));
                }
            },
            xor: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.xor8(address, value) & 0xff);
                    case 12:
                        return instance.exports.xor8(address, value);
                    case 14:
                        return instance.exports.xor16(address, value);
                    case 7:
                        return (instance.exports.xor16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.xor32(address, value);
                    case 9:
                        return instance.exports.xor32(address, value);
                    case 21:
                        return instance.exports.xor64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.xor64(address, value));
                }
            },
            store: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 12:
                    case 3:
                        return instance.exports.store8(address, value);
                    case 14:
                    case 7:
                        return instance.exports.store16(address, value);
                    case 16:
                    case 9:
                        return instance.exports.store32(address, value);
                    case 21:
                    case 22:
                        return instance.exports.store64(address, value);
                }
            },
            load: function (address, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.load8(address) & 0xff);
                    case 12:
                        return instance.exports.load8(address);
                    case 14:
                        return instance.exports.load16(address);
                    case 7:
                        return instance.exports.load16(address);
                    case 16:
                        return instance.exports.load32(address);
                    case 9:
                        return (instance.exports.load32(address) & 0xffffffff);
                    case 21:
                        return instance.exports.load64(address);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.load64(address));
                }
            },
            compareExchange: function (address, expectedValue, replacementValue, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.compare_exchange8(address, expectedValue, replacementValue) & 0xff);
                    case 12:
                        return instance.exports.compare_exchange8(address, expectedValue, replacementValue);
                    case 14:
                        return instance.exports.compare_exchange16(address, expectedValue, replacementValue);
                    case 7:
                        return (instance.exports.compare_exchange16(address, expectedValue, replacementValue) & 0xffff);
                    case 16:
                        return instance.exports.compare_exchange32(address, expectedValue, replacementValue);
                    case 9:
                        return (instance.exports.compare_exchange32(address, expectedValue, replacementValue) & 0xffffffff);
                    case 21:
                        return instance.exports.compare_exchange64(address, expectedValue, replacementValue);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.compare_exchange64(address, expectedValue, replacementValue));
                }
            },
            exchange: function (address, value, type) {
                switch (type) {
                    case 5:
                    case 3:
                        return (instance.exports.exchange8(address, value) & 0xff);
                    case 12:
                        return instance.exports.exchange8(address, value);
                    case 14:
                        return instance.exports.exchange16(address, value);
                    case 7:
                        return (instance.exports.exchange16(address, value) & 0xffff);
                    case 16:
                        return instance.exports.exchange32(address, value);
                    case 9:
                        return (instance.exports.exchange32(address, value) & 0xffffffff);
                    case 21:
                        return instance.exports.exchange64(address, value);
                    case 22:
                        return BigInt.asUintN(64, instance.exports.exchange64(address, value));
                }
            },
            notify: function (address, count) {
                return instance.exports.notify(address, count);
            },
            wait: function (address, value) {
                return instance.exports.wait(address, value);
            },
            waitTimeout: function (address, value, timeout) {
                return instance.exports.waitTimeout(address, value, BigInt(timeout >>> 0));
            }
        });
    }
    catch (error) {
        common_util_logger__WEBPACK_IMPORTED_MODULE_4__.warn('atomics asm not support, cannot use asm atomics function', cheap__fileName__0, 284);
    }
}


/***/ }),

/***/ "./src/cheap/thread/atomics.ts":
/*!*************************************!*\
  !*** ./src/cheap/thread/atomics.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   add: () => (/* binding */ add),
/* harmony export */   and: () => (/* binding */ and),
/* harmony export */   compareExchange: () => (/* binding */ compareExchange),
/* harmony export */   exchange: () => (/* binding */ exchange),
/* harmony export */   load: () => (/* binding */ load),
/* harmony export */   notify: () => (/* binding */ notify),
/* harmony export */   or: () => (/* binding */ or),
/* harmony export */   override: () => (/* binding */ override),
/* harmony export */   store: () => (/* binding */ store),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   wait: () => (/* binding */ wait),
/* harmony export */   waitAsync: () => (/* binding */ waitAsync),
/* harmony export */   waitTimeout: () => (/* binding */ waitTimeout),
/* harmony export */   waitTimeoutAsync: () => (/* binding */ waitTimeoutAsync),
/* harmony export */   xor: () => (/* binding */ xor)
/* harmony export */ });
/**
 * 给定的值加到指定位置上
 *
 * 返回该位置的旧值
 *
 */
let add;
/**
 * 给定的值与指定位置上的值相减
 *
 * 返回该位置的旧值
 *
 */
let sub;
/**
 * 给定的值与指定位置上的值进行与运算
 *
 * 返回该位置的旧值
 *
 */
let and;
/**
 * 给定的值与指定位置上的值进行或运算
 *
 * 返回该位置的旧值
 *
 */
let or;
/**
 * 给定的值与指定位置上的值进行异或运算
 *
 * 返回该位置的旧值
 *
 */
let xor;
/**
 * 给定的值存在给定位置上
 *
 * 返回该位置的旧值
 *
 */
let store;
/**
 * 读取给定位置上的值
 *
 * 返回该位置的旧值
 *
 */
let load;
/**
 * 如果指定位置的值与给定的值相等，则将其更新为新的值，并返回该元素原先的值
 *
 * 返回该位置的旧值
 *
 */
let compareExchange;
/**
 * 将指定位置的值更新为给定的值，并返回该元素更新前的值。
 *
 * 返回该位置的旧值
 *
 */
let exchange;
/**
 * 唤醒等待队列中正在指定位置上等待的线程。返回值为成功唤醒的线程数量。
 *
 * 返回被唤醒的代理的数量 0 将不会唤醒任何线程
 *
 */
let notify;
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒
 *
 * 0 "ok"、1 "not-equal"
 *
 */
let wait;
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时（毫秒）
 *
 * 0 "ok"、1 "not-equal" 或 2 "time-out"
 *
 */
let waitTimeout;
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒
 *
 * 异步非阻塞，适合在主线程上使用
 *
 * 0 "ok"、1 "not-equal"
 *
 */
let waitAsync;
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时
 *
 * 异步非阻塞，适合在主线程上使用
 *
 * 0 "ok"、1 "not-equal" 或 2 "time-out"
 *
 */
let waitTimeoutAsync;
function override(funcs) {
    if (funcs.add) {
        add = funcs.add;
    }
    if (funcs.sub) {
        sub = funcs.sub;
    }
    if (funcs.and) {
        and = funcs.and;
    }
    if (funcs.or) {
        or = funcs.or;
    }
    if (funcs.xor) {
        xor = funcs.xor;
    }
    if (funcs.store) {
        store = funcs.store;
    }
    if (funcs.load) {
        load = funcs.load;
    }
    if (funcs.compareExchange) {
        compareExchange = funcs.compareExchange;
    }
    if (funcs.exchange) {
        exchange = funcs.exchange;
    }
    if (funcs.notify) {
        notify = funcs.notify;
    }
    if (funcs.wait) {
        wait = funcs.wait;
    }
    if (funcs.waitTimeout) {
        waitTimeout = funcs.waitTimeout;
    }
    if (funcs.waitAsync) {
        waitAsync = funcs.waitAsync;
    }
    if (funcs.waitTimeoutAsync) {
        waitTimeoutAsync = funcs.waitTimeoutAsync;
    }
}


/***/ }),

/***/ "./src/cheap/thread/atomicsImpl.ts":
/*!*****************************************!*\
  !*** ./src/cheap/thread/atomicsImpl.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var common_function_nextTick__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/function/nextTick */ "./src/common/function/nextTick.ts");
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var common_util_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/browser */ "./src/common/util/browser.ts");






let getAtomicsBuffer;
const useAtomics = _config__WEBPACK_IMPORTED_MODULE_0__.USE_THREADS || (0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_1__["default"])() || (!common_util_browser__WEBPACK_IMPORTED_MODULE_2__["default"].chrome || common_util_browser__WEBPACK_IMPORTED_MODULE_2__["default"].checkVersion(common_util_browser__WEBPACK_IMPORTED_MODULE_2__["default"].majorVersion, '94', true));
/**
 * 给定的值加到指定位置上
 *
 * 返回该位置的旧值
 *
 */
function add(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.add(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] += value;
        return old;
    }
}
/**
 * 给定的值与指定位置上的值相减
 *
 * 返回该位置的旧值
 *
 */
function sub(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.sub(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] -= value;
        return old;
    }
}
/**
 * 给定的值与指定位置上的值进行与运算
 *
 * 返回该位置的旧值
 *
 */
function and(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.and(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] &= value;
        return old;
    }
}
/**
 * 给定的值与指定位置上的值进行或运算
 *
 * 返回该位置的旧值
 *
 */
function or(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.or(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] |= value;
        return old;
    }
}
/**
 * 给定的值与指定位置上的值进行异或运算
 *
 * 返回该位置的旧值
 *
 */
function xor(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.xor(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] ^= value;
        return old;
    }
}
/**
 * 给定的值存在给定位置上
 *
 * 返回该位置的旧值
 *
 */
function store(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.store(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] = value;
        return old;
    }
}
/**
 * 读取给定位置上的值
 *
 * 返回该位置的旧值
 *
 */
function load(address, type, shift) {
    if ( true && useAtomics) {
        return Atomics.load(getAtomicsBuffer(type), address >>> shift);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        return old;
    }
}
/**
 * 如果指定位置的值与给定的值相等，则将其更新为新的值，并返回该位置原先的值
 *
 * 返回该位置的旧值
 *
 */
function compareExchange(address, expectedValue, replacementValue, type, shift) {
    if ( true && useAtomics) {
        return Atomics.compareExchange(getAtomicsBuffer(type), address >>> shift, expectedValue, replacementValue);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        if (old === expectedValue) {
            buffer[index] = replacementValue;
        }
        return old;
    }
}
/**
 * 将指定位置的值更新为给定的值，并返回该位置更新前的值。
 *
 * 返回该位置的旧值
 *
 */
function exchange(address, value, type, shift) {
    if ( true && useAtomics) {
        return Atomics.exchange(getAtomicsBuffer(type), address >>> shift, value);
    }
    else {
        const buffer = getAtomicsBuffer(type);
        const index = address >>> shift;
        const old = buffer[index];
        buffer[index] = value;
        return old;
    }
}
/**
 * 唤醒等待队列中正在指定位置上等待的线程。返回值为成功唤醒的线程数量。
 *
 * 返回被唤醒的代理的数量
 *
 */
function notify(address, count) {
    if ( true && useAtomics) {
        return Atomics.notify(getAtomicsBuffer(16), address >>> 2, count);
    }
    else {
        return;
    }
}
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒
 *
 * 0 "ok"、1 "not-equal" 或 2 "timed-out"
 *
 */
const waitMap = {
    'ok': 0,
    'not-equal': 1,
    'timed-out': 2
};
function wait(address, value) {
    return waitMap[Atomics.wait(getAtomicsBuffer(16), address >>> 2, value)];
}
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时
 *
 * 0 "ok"、1 "not-equal" 或 2 "time-out"
 *
 */
function waitTimeout(address, value, timeout) {
    return waitMap[Atomics.wait(getAtomicsBuffer(16), address >>> 2, value, timeout)];
}
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒
 *
 * 0 "ok"、1 "not-equal" 或 2 "timed-out"
 *
 */
async function waitAsync(address, value) {
    if (Atomics.waitAsync) {
        const result = Atomics.waitAsync(getAtomicsBuffer(16), address >>> 2, value);
        if (result.async) {
            return waitMap[await result.value];
        }
        return waitMap[result.value];
    }
    else {
        if (load(address) !== value) {
            return 1;
        }
        else {
            while (load(address) === value) {
                // 跳过当前事件循环
                await new Promise((resolve) => {
                    (0,common_function_nextTick__WEBPACK_IMPORTED_MODULE_3__["default"])(() => {
                        resolve();
                    });
                });
            }
            return 0;
        }
    }
}
/**
 * 检测指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时
 *
 * 0 "ok"、1 "not-equal" 或 2 "time-out"
 *
 */
async function waitTimeoutAsync(address, value, timeout) {
    if (Atomics.waitAsync) {
        const result = Atomics.waitAsync(getAtomicsBuffer(16), address >>> 2, value, timeout);
        if (result.async) {
            return waitMap[await result.value];
        }
        return waitMap[result.value];
    }
    else {
        if (load(address) !== value) {
            return 1;
        }
        else {
            const now = (0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_4__["default"])();
            while (load(address) === value && ((0,common_function_getTimestamp__WEBPACK_IMPORTED_MODULE_4__["default"])() - now < timeout)) {
                // 跳过当前事件循环
                await new Promise((resolve) => {
                    (0,common_function_nextTick__WEBPACK_IMPORTED_MODULE_3__["default"])(() => {
                        resolve();
                    });
                });
            }
            return load(address) !== value ? 0 : 2;
        }
    }
}
function init(getAtomicsBuffer_) {
    getAtomicsBuffer = getAtomicsBuffer_;
    (0,_atomics__WEBPACK_IMPORTED_MODULE_5__.override)({
        add,
        sub,
        and,
        or,
        xor,
        store,
        load,
        compareExchange,
        exchange,
        notify,
        wait,
        waitTimeout,
        waitAsync,
        waitTimeoutAsync
    });
}


/***/ }),

/***/ "./src/cheap/thread/cond.ts":
/*!**********************************!*\
  !*** ./src/cheap/thread/cond.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   broadcast: () => (/* binding */ broadcast),
/* harmony export */   destroy: () => (/* binding */ destroy),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   signal: () => (/* binding */ signal),
/* harmony export */   timedWait: () => (/* binding */ timedWait),
/* harmony export */   wait: () => (/* binding */ wait)
/* harmony export */ });
/* unused harmony exports Cond, waitAsync, timedwaitAsync */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _mutex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./atomics */ "./src/cheap/thread/atomics.ts");



/**
 * 参考 https://github.com/mozilla-spidermonkey/js-lock-and-condition
 */


class Cond {
    atomic;
}
(function (prototype) {
    var map = new Map();
    map.set("atomic", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(Cond.prototype);
/**
 * 初始化条件变量
 */
function init(cond, attr) {
    _atomics__WEBPACK_IMPORTED_MODULE_2__.store(cond, 0, 16, 2);
    return 0;
}
/**
 * 销毁条件变量
 */
function destroy(cond) {
    _atomics__WEBPACK_IMPORTED_MODULE_2__.store(cond, 0, 16, 2);
    return 0;
}
/**
 * 唤醒条件变量上的一个等待线程
 *
 * @param cond
 */
function signal(cond) {
    _atomics__WEBPACK_IMPORTED_MODULE_2__.add(cond, 1, 16, 2);
    _atomics__WEBPACK_IMPORTED_MODULE_2__.notify(cond, 1);
    return 0;
}
/**
 * 唤醒条件变量上的所有等待线程
 *
 * @param cond
 */
function broadcast(cond) {
    _atomics__WEBPACK_IMPORTED_MODULE_2__.add(cond, 1, 16, 2);
    _atomics__WEBPACK_IMPORTED_MODULE_2__.notify(cond, 1073741824);
    return 0;
}
/**
 * 线程在条件变量处等待
 *
 * @param cond
 * @param mutex
 * @returns
 */
function wait(cond, mutex) {
    let c = _atomics__WEBPACK_IMPORTED_MODULE_2__.load(cond, 16, 2);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.unlock(mutex);
    _atomics__WEBPACK_IMPORTED_MODULE_2__.wait(cond, c);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.lock(mutex);
    return 0;
}
/**
 * 线程在条件变量处异步等待
 *
 * @param cond
 * @param mutex
 */
async function waitAsync(cond, mutex) {
    let c = _atomics__WEBPACK_IMPORTED_MODULE_2__.load(cond, 16, 2);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.unlock(mutex);
    await _atomics__WEBPACK_IMPORTED_MODULE_2__.waitAsync(cond, c);
    await _mutex__WEBPACK_IMPORTED_MODULE_3__.lockAsync(mutex);
    return 0;
}
/**
 * 线程在条件变量处超时等待
 *
 * @param cond
 * @param mutex
 * @param timeout 毫秒
 */
function timedWait(cond, mutex, timeout) {
    let c = _atomics__WEBPACK_IMPORTED_MODULE_2__.load(cond, 16, 2);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.unlock(mutex);
    let ret = _atomics__WEBPACK_IMPORTED_MODULE_2__.waitTimeout(cond, c, timeout);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.lock(mutex);
    return ret === 2 ? 110 : 0;
}
/**
 * 线程在条件变量处超时异步等待
 *
 * @param cond
 * @param mutex
 * @param timeout 毫秒
 */
async function timedwaitAsync(cond, mutex, timeout) {
    let c = _atomics__WEBPACK_IMPORTED_MODULE_2__.load(cond, 16, 2);
    _mutex__WEBPACK_IMPORTED_MODULE_3__.unlock(mutex);
    let ret = await _atomics__WEBPACK_IMPORTED_MODULE_2__.waitTimeoutAsync(cond, c, timeout);
    await _mutex__WEBPACK_IMPORTED_MODULE_3__.lockAsync(mutex);
    return ret === 2 ? 110 : 0;
}


/***/ }),

/***/ "./src/cheap/thread/initClass.ts":
/*!***************************************!*\
  !*** ./src/cheap/thread/initClass.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");




let parentPort = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF;
function init(run) {
    let ipc;
    let target;
    function initIPC(port) {
        ipc =  false ? 0 : new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](port);
        ipc.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__.REQUEST, async (data) => {
            const method = data.method;
            const params = data.params;
            if (common_util_is__WEBPACK_IMPORTED_MODULE_2__.func(target[method])) {
                try {
                    const transfer = [];
                    const result = await target[method](...params.params, transfer);
                    ipc.reply(data, result, null, transfer);
                }
                catch (error) {
                    ipc.reply(data, -2097152 /* CHeapError.REQUEST_ERROR */, {
                        message: error.message
                    });
                }
            }
        });
    }
    const handler = (message) => {
        const origin =  false ? 0 : message.data;
        const type = origin.type;
        const data = origin.data;
        switch (type) {
            case 'init':
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap && common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread) {
                    common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread(data).then(() => {
                        parentPort.postMessage({
                            type: 'ready'
                        });
                    });
                    return;
                }
                parentPort.postMessage({
                    type: 'ready'
                });
                break;
            case 'run':
                parentPort.postMessage({
                    type: 'running'
                });
                target = run(data.params);
                initIPC(data.port);
                break;
            case 'stop':
                if (ipc) {
                    ipc.destroy();
                }
                parentPort.postMessage({
                    type: 'stopped'
                });
                break;
            default:
                break;
        }
    };
    {
        parentPort.onmessage = handler;
    }
}


/***/ }),

/***/ "./src/cheap/thread/initFunction.ts":
/*!******************************************!*\
  !*** ./src/cheap/thread/initFunction.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");

let parentPort = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF;
function init(run) {
    let retval;
    const handler = (message) => {
        const origin =  false ? 0 : message.data;
        const type = origin.type;
        const data = origin.data;
        switch (type) {
            case 'init':
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap && common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread) {
                    common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread(data).then(() => {
                        parentPort.postMessage({
                            type: 'ready'
                        });
                    });
                    return;
                }
                parentPort.postMessage({
                    type: 'ready'
                });
                break;
            case 'run':
                retval = run(data.params);
                break;
            case 'stop':
                if (retval && retval.then) {
                    retval.then((res) => {
                        parentPort.postMessage({
                            type: 'stopped',
                            data: res
                        });
                    });
                }
                else {
                    parentPort.postMessage({
                        type: 'stopped',
                        data: retval
                    });
                }
                break;
            default:
                break;
        }
    };
    {
        parentPort.onmessage = handler;
    }
}


/***/ }),

/***/ "./src/cheap/thread/initModule.ts":
/*!****************************************!*\
  !*** ./src/cheap/thread/initModule.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");




let parentPort = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF;
function init(module) {
    let ipc;
    function initIPC(port) {
        ipc =  false ? 0 : new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__["default"](port);
        ipc.on(common_network_IPCPort__WEBPACK_IMPORTED_MODULE_1__.REQUEST, async (data) => {
            const method = data.method;
            const params = data.params;
            if (common_util_is__WEBPACK_IMPORTED_MODULE_2__.func(module[method])) {
                try {
                    const transfer = [];
                    const result = await module[method](...params.params, transfer);
                    ipc.reply(data, result, null, transfer);
                }
                catch (error) {
                    ipc.reply(data, -2097152 /* CHeapError.REQUEST_ERROR */, {
                        message: error.message
                    });
                }
            }
        });
    }
    const handler = (message) => {
        const origin =  false ? 0 : message.data;
        const type = origin.type;
        const data = origin.data;
        switch (type) {
            case 'init':
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap && common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread) {
                    common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread(data).then(() => {
                        parentPort.postMessage({
                            type: 'ready'
                        });
                    });
                    return;
                }
                parentPort.postMessage({
                    type: 'ready'
                });
                break;
            case 'run':
                parentPort.postMessage({
                    type: 'running'
                });
                initIPC(data.port);
                break;
            case 'stop':
                if (ipc) {
                    ipc.destroy();
                }
                parentPort.postMessage({
                    type: 'stopped'
                });
                break;
            default:
                break;
        }
    };
    {
        parentPort.onmessage = handler;
    }
}


/***/ }),

/***/ "./src/cheap/thread/mutex.ts":
/*!***********************************!*\
  !*** ./src/cheap/thread/mutex.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mutex: () => (/* binding */ Mutex),
/* harmony export */   destroy: () => (/* binding */ destroy),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   lock: () => (/* binding */ lock),
/* harmony export */   lockAsync: () => (/* binding */ lockAsync),
/* harmony export */   unlock: () => (/* binding */ unlock)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");



/**
 * 参考 https://github.com/mozilla-spidermonkey/js-lock-and-condition
 */


class Mutex {
    atomic;
}
(function (prototype) {
    var map = new Map();
    map.set("atomic", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(Mutex.prototype);
/**
 * 初始化锁
 *
 * @param mutex
 * @returns
 */
function init(mutex) {
    _atomics__WEBPACK_IMPORTED_MODULE_2__.store(mutex, 0 /* STATUS.UNLOCK */, 16, 2);
    return 0;
}
/**
 * 加锁
 *
 * @param mutex
 * @param spin 是否自旋
 */
function lock(mutex, spin = false) {
    let status;
    // 不为 UNLOCK，说明其他线程持锁，将锁置为 LOCKED 状态
    if ((status = _atomics__WEBPACK_IMPORTED_MODULE_2__.compareExchange(mutex, 0 /* STATUS.UNLOCK */, 1 /* STATUS.LOCKED */, 16, 2)) !== 0 /* STATUS.UNLOCK */) {
        do {
            // 如果依旧得不到锁，将锁置为 WAITED 状态
            if (status == 2 /* STATUS.WAITED */
                || _atomics__WEBPACK_IMPORTED_MODULE_2__.compareExchange(mutex, 1 /* STATUS.LOCKED */, 2 /* STATUS.WAITED */, 16, 2) !== 0 /* STATUS.UNLOCK */) {
                // 主线程不能 wait，直接自旋（需要注意所有线程各自的持锁时间，避免出现忙等占用大量 cpu 时间）
                if (!spin && (0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_3__["default"])()) {
                    _atomics__WEBPACK_IMPORTED_MODULE_2__.wait(mutex, 2 /* STATUS.WAITED */);
                }
            }
        } 
        // 再次尝试获取锁
        while ((status = _atomics__WEBPACK_IMPORTED_MODULE_2__.compareExchange(mutex, 0 /* STATUS.UNLOCK */, 2 /* STATUS.WAITED */, 16, 2)) !== 0 /* STATUS.UNLOCK */);
    }
    return 0;
}
/**
 * 异步加锁
 *
 * @param mutex
 */
async function lockAsync(mutex) {
    let status;
    // 不为 UNLOCK，说明其他线程持锁，将锁置为 LOCKED 状态
    if ((status = _atomics__WEBPACK_IMPORTED_MODULE_2__.compareExchange(mutex, 0 /* STATUS.UNLOCK */, 1 /* STATUS.LOCKED */, 16, 2)) !== 0 /* STATUS.UNLOCK */) {
        do {
            // 如果依旧得不到锁，将锁置为 WAITED 状态
            if (status == 2 /* STATUS.WAITED */
                || _atomics__WEBPACK_IMPORTED_MODULE_2__.compareExchange(mutex, 1 /* STATUS.LOCKED */, 2 /* STATUS.WAITED */, 16, 2) !== 0 /* STATUS.UNLOCK */) {
                await _atomics__WEBPACK_IMPORTED_MODULE_2__.waitAsync(mutex, 2 /* STATUS.WAITED */);
            }
        } 
        // 再次尝试获取锁
        while ((status = _atomics__WEBPACK_IMPORTED_MODULE_2__.compareExchange(mutex, 0 /* STATUS.UNLOCK */, 2 /* STATUS.WAITED */, 16, 2)) !== 0 /* STATUS.UNLOCK */);
    }
    return 0;
}
/**
 * 释放锁
 *
 * @param mutex
 */
function unlock(mutex) {
    let status = _atomics__WEBPACK_IMPORTED_MODULE_2__.sub(mutex, 1, 16, 2);
    // 此时拥有锁，状态为 LOCKED 或 WAITED
    if (status !== 1 /* STATUS.LOCKED */) {
        // 释放锁
        _atomics__WEBPACK_IMPORTED_MODULE_2__.store(mutex, 0 /* STATUS.UNLOCK */, 16, 2);
        // 唤醒一个 wait 的线程
        _atomics__WEBPACK_IMPORTED_MODULE_2__.notify(mutex, 1);
    }
    return 0;
}
/**
 * 销毁锁
 *
 * @param mutex
 * @returns
 */
function destroy(mutex) {
    _atomics__WEBPACK_IMPORTED_MODULE_2__.store(mutex, 0 /* STATUS.UNLOCK */, 16, 2);
    return 0;
}


/***/ }),

/***/ "./src/cheap/thread/semaphore.ts":
/*!***************************************!*\
  !*** ./src/cheap/thread/semaphore.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   destroy: () => (/* binding */ destroy),
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   post: () => (/* binding */ post),
/* harmony export */   timedWait: () => (/* binding */ timedWait),
/* harmony export */   tryWait: () => (/* binding */ tryWait),
/* harmony export */   wait: () => (/* binding */ wait)
/* harmony export */ });
/* unused harmony exports Sem, waitAsync, timedWaitAsync, set, get */
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var _mutex_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _atomics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./atomics */ "./src/cheap/thread/atomics.ts");








class Sem {
    atomic;
    mutex;
}
(function (prototype) {
    var map = new Map();
    map.set("atomic", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("mutex", { 0: _mutex_ts__WEBPACK_IMPORTED_MODULE_0__.Mutex, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructKeysMeta, map);
})(Sem.prototype);
/**
 * 初始化信号量
 *
 * @param sem
 * @param value 信号量初始值
 */
function init(sem, value) {
    _atomics__WEBPACK_IMPORTED_MODULE_3__.store(sem, (value >> 0), 16, 2);
    _mutex_ts__WEBPACK_IMPORTED_MODULE_0__.init(sem + 4);
    return 0;
}
function destroy(sem) {
    _mutex_ts__WEBPACK_IMPORTED_MODULE_0__.destroy(sem + 4);
    return 0;
}
/**
 * 生产信号量
 *
 * @param sem
 */
function post(sem) {
    _atomics__WEBPACK_IMPORTED_MODULE_3__.add(sem, 1, 16, 2);
    _atomics__WEBPACK_IMPORTED_MODULE_3__.notify(sem, 1);
    return 0;
}
/**
 * 消费信号量
 *
 * @param sem
 */
function wait(sem) {
    while (true) {
        _atomics__WEBPACK_IMPORTED_MODULE_3__.wait(sem, 0);
        let old = _atomics__WEBPACK_IMPORTED_MODULE_3__.sub(sem, 1, 16, 2);
        if (old <= 0) {
            // 此时已经没有了，将减掉的加回来继续等待
            _atomics__WEBPACK_IMPORTED_MODULE_3__.add(sem, 1, 16, 2);
        }
        else {
            break;
        }
    }
    return 0;
}
/**
 * 消费信号量
 *
 * @param sem
 */
function tryWait(sem) {
    _mutex_ts__WEBPACK_IMPORTED_MODULE_0__.lock(sem + 4);
    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[16](sem) > 0) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumWrite[16](sem, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumRead[16](sem) - 1);
        _mutex_ts__WEBPACK_IMPORTED_MODULE_0__.unlock(sem + 4);
        return 0;
    }
    _mutex_ts__WEBPACK_IMPORTED_MODULE_0__.unlock(sem + 4);
    return 11;
}
/**
 * 消费信号量，并设置一个超时
 *
 * @param sem
 * @param timeout 毫秒
 * @returns
 */
function timedWait(sem, timeout) {
    let ret = _atomics__WEBPACK_IMPORTED_MODULE_3__.waitTimeout(sem, 0, timeout);
    if (ret !== 2) {
        let old = _atomics__WEBPACK_IMPORTED_MODULE_3__.sub(sem, 1, 16, 2);
        if (old <= 0) {
            // 此时已经没有了，将减掉的加回来
            _atomics__WEBPACK_IMPORTED_MODULE_3__.add(sem, 1, 16, 2);
            // ETIMEDOUT
            return 110;
        }
    }
    return 0;
}
/**
 * 异步消费信号量
 *
 * @param sem
 */
async function waitAsync(sem) {
    while (true) {
        await _atomics__WEBPACK_IMPORTED_MODULE_3__.waitAsync(sem, 0);
        let old = _atomics__WEBPACK_IMPORTED_MODULE_3__.sub(sem, 1, 16, 2);
        if (old <= 0) {
            // 此时已经没有了，将减掉的加回来继续等待
            _atomics__WEBPACK_IMPORTED_MODULE_3__.add(sem, 1, 16, 2);
        }
        else {
            break;
        }
    }
    return 0;
}
/**
 * 异步消费信号量，并设置一个超时
 *
 * @param sem
 * @param timeout 毫秒
 */
async function timedWaitAsync(sem, timeout) {
    let ret = await _atomics__WEBPACK_IMPORTED_MODULE_3__.waitTimeoutAsync(sem, 0, timeout);
    if (ret !== 2) {
        let old = _atomics__WEBPACK_IMPORTED_MODULE_3__.sub(sem, 1, 16, 2);
        if (old <= 0) {
            // 此时已经没有了，将减掉的加回来
            _atomics__WEBPACK_IMPORTED_MODULE_3__.add(sem, 1, 16, 2);
            // ETIMEDOUT
            return 110;
        }
    }
    return 0;
}
function set(sem, value) {
    _atomics__WEBPACK_IMPORTED_MODULE_3__.store(sem, value, 16, 2);
    return 0;
}
function get(sem) {
    return _atomics__WEBPACK_IMPORTED_MODULE_3__.load(sem, 16, 2);
}


/***/ }),

/***/ "./src/cheap/thread/thread.ts":
/*!************************************!*\
  !*** ./src/cheap/thread/thread.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   closeThread: () => (/* binding */ closeThread),
/* harmony export */   createThreadFromClass: () => (/* binding */ createThreadFromClass)
/* harmony export */ });
/* unused harmony exports createThreadFromFunction, createThreadFromModule, joinThread */
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../heap */ "./src/cheap/heap.ts");
/* harmony import */ var common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/network/IPCPort */ "./src/common/network/IPCPort.ts");
/* harmony import */ var common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/function/sourceLoad */ "./src/common/function/sourceLoad.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");
/* harmony import */ var common_function_toString__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/function/toString */ "./src/common/function/toString.ts");










// @ts-ignore
let Worker = common_util_constant__WEBPACK_IMPORTED_MODULE_1__.SELF.Worker;
// @ts-ignore
let MessageChannel = common_util_constant__WEBPACK_IMPORTED_MODULE_1__.SELF.MessageChannel;
{
    // 保证打包工具可以包含下面的模块代码
    __webpack_require__(/*! ./initClass */ "./src/cheap/thread/initClass.ts");
    __webpack_require__(/*! ./initFunction */ "./src/cheap/thread/initFunction.ts");
    __webpack_require__(/*! ./initModule */ "./src/cheap/thread/initModule.ts");
}
const initClass =  true ? (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_2__["default"])(/*require.resolve*/(/*! ./initClass */ "./src/cheap/thread/initClass.ts"), {
    varName: 'init'
}) : 0;
const initFunction =  true ? (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_2__["default"])(/*require.resolve*/(/*! ./initFunction */ "./src/cheap/thread/initFunction.ts"), {
    varName: 'init'
}) : 0;
const initModule =  true ? (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_2__["default"])(/*require.resolve*/(/*! ./initModule */ "./src/cheap/thread/initModule.ts"), {
    varName: 'init'
}) : 0;
const symbolRevoke = Symbol('revoke');
const caches = new Map();
function getCacheKey(moduleId, type) {
    return `${moduleId}_${type}`;
}
function createThreadFromClass(entity, options = {}, moduleId) {
    let transferData = [];
    let runInWorker;
    {
        runInWorker = (...args) => {
            let worker;
            if (moduleId instanceof Worker) {
                worker = moduleId;
            }
            else {
                let workerUrl;
                const cacheKey = getCacheKey(moduleId, 'class');
                if (caches.has(cacheKey)) {
                    workerUrl = caches.get(cacheKey).url;
                    caches.get(cacheKey).refCount++;
                }
                else {
                    const module = (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_2__["default"])(moduleId, {
                        varName: `__module_${entity.name}__`,
                        exportName: `__${entity.name}__`,
                        pointName: entity.name,
                        exportIsClass: true
                    });
                    const source = `
            ${module}
            function run(params) {
              params.unshift(null)
              return new (Function.prototype.bind.apply(__module_${entity.name}__.__${entity.name}__, params))()
            }
            ${initClass}
            init.default(run);
          `;
                    {
                        const blob = new Blob([source], { type: 'text/javascript' });
                        workerUrl = URL.createObjectURL(blob);
                    }
                    caches.set(cacheKey, {
                        url: workerUrl,
                        refCount: 1
                    });
                }
                worker = new Worker(workerUrl);
            }
            const channel = new MessageChannel();
            return new Promise((resolve, reject) => {
                const stackPointer = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(_config__WEBPACK_IMPORTED_MODULE_3__.STACK_ALIGNMENT, options.stackSize
                    ? ((options.stackSize + _config__WEBPACK_IMPORTED_MODULE_3__.STACK_ALIGNMENT) & ~_config__WEBPACK_IMPORTED_MODULE_3__.STACK_ALIGNMENT)
                    : _config__WEBPACK_IMPORTED_MODULE_3__.STACK_SIZE);
                function running() {
                    const ipc =  false ? 0 : new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__["default"](channel.port1);
                    const obj = {
                        $worker: worker,
                        $ipc: ipc,
                        $channel: channel,
                        $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_5__["default"])(moduleId),
                        $stackPointer: stackPointer,
                        $type: 'class'
                    };
                    const { proxy, revoke } = Proxy.revocable(obj, {
                        get(target, propertyKey, receiver) {
                            if (target[propertyKey]) {
                                return obj[propertyKey];
                            }
                            if (propertyKey in entity.prototype && typeof entity.prototype[propertyKey] === 'function') {
                                const call = async function (...args) {
                                    return ipc.request(propertyKey, {
                                        params: args
                                    });
                                };
                                call.transfer = function (...transfer) {
                                    return {
                                        invoke: async function (...args) {
                                            return ipc.request(propertyKey, {
                                                params: args
                                            }, transfer);
                                        }
                                    };
                                };
                                target[propertyKey] = call;
                            }
                            return target[propertyKey];
                        }
                    });
                    obj[symbolRevoke] = revoke;
                    resolve(proxy);
                }
                const handler = (message) => {
                    const origin =  false ? 0 : message.data;
                    const type = origin.type;
                    const data = origin.data;
                    switch (type) {
                        case 'ready':
                            worker.postMessage({
                                type: 'run',
                                data: {
                                    port: channel.port2,
                                    params: args
                                }
                            }, [channel.port2, ...transferData]);
                            break;
                        case 'running':
                            running();
                            break;
                        default:
                            break;
                    }
                };
                {
                    worker.onmessage = handler;
                }
                worker.onmessage = handler;
                worker.postMessage({
                    type: 'init',
                    data: {
                        memory: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory,
                        name: options.name || entity.name,
                        stackPointer,
                        stackSize: options.stackSize ?? _config__WEBPACK_IMPORTED_MODULE_3__.STACK_SIZE
                    }
                });
            });
        };
    }
    function runInMain(...args) {
        const worker = new entity(...args);
        return new Promise((resolve) => {
            const obj = {
                $worker: null,
                $ipc: null,
                $channel: null,
                $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_5__["default"])(moduleId),
                $stackPointer: 0,
                $instance: worker,
                $type: 'class'
            };
            const { proxy, revoke } = Proxy.revocable(obj, {
                get(target, propertyKey, receiver) {
                    if (target[propertyKey]) {
                        return obj[propertyKey];
                    }
                    if (propertyKey in entity.prototype && typeof entity.prototype[propertyKey] === 'function') {
                        const call = function (...args) {
                            return worker[propertyKey](...args);
                        };
                        call.transfer = function (...transfer) {
                            return {
                                invoke: function (...args) {
                                    return worker[propertyKey](...args);
                                }
                            };
                        };
                        target[propertyKey] = call;
                    }
                    return target[propertyKey];
                }
            });
            obj[symbolRevoke] = revoke;
            resolve(proxy);
        });
    }
    function transfer(...transfer) {
        transferData = transfer;
        return {
            run:  true && (_config__WEBPACK_IMPORTED_MODULE_3__.USE_THREADS && !options.disableWorker) ? runInWorker : runInMain
        };
    }
    return {
        run:  true && (_config__WEBPACK_IMPORTED_MODULE_3__.USE_THREADS && !options.disableWorker) ? runInWorker : runInMain,
        transfer
    };
}
function createThreadFromFunction(entity, options = {}, moduleId) {
    let transferData = [];
    let runInWorker;
    {
        runInWorker = (...args) => {
            let worker;
            if (moduleId instanceof Worker) {
                worker = moduleId;
            }
            else {
                let workerUrl;
                const cacheKey = getCacheKey(moduleId, 'function');
                if (caches.has(cacheKey)) {
                    workerUrl = caches.get(cacheKey).url;
                    caches.get(cacheKey).refCount++;
                }
                else {
                    const module = (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_2__["default"])(moduleId, {
                        varName: `__module_${entity.name}__`,
                        exportName: `__${entity.name}__`,
                        pointName: entity.name
                    });
                    const source = `
            ${module}
            function run(params) {
              return __module_${entity.name}__.__${entity.name}__.apply(${ false ? 0 : 'self'}, params)
            }
            ${initFunction}
            init.default(run);
          `;
                    {
                        const blob = new Blob([source], { type: 'text/javascript' });
                        workerUrl = URL.createObjectURL(blob);
                    }
                    caches.set(cacheKey, {
                        url: workerUrl,
                        refCount: 1
                    });
                }
                worker = new Worker(workerUrl);
            }
            return new Promise((resolve, reject) => {
                const stackPointer = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(_config__WEBPACK_IMPORTED_MODULE_3__.STACK_ALIGNMENT, options.stackSize
                    ? ((options.stackSize + _config__WEBPACK_IMPORTED_MODULE_3__.STACK_ALIGNMENT) & ~_config__WEBPACK_IMPORTED_MODULE_3__.STACK_ALIGNMENT)
                    : _config__WEBPACK_IMPORTED_MODULE_3__.STACK_SIZE);
                function running() {
                    const obj = {
                        $worker: worker,
                        $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_5__["default"])(moduleId),
                        $stackPointer: stackPointer,
                        $type: 'function'
                    };
                    resolve(obj);
                }
                const handler = (message) => {
                    const origin =  false ? 0 : message.data;
                    const type = origin.type;
                    const data = origin.data;
                    switch (type) {
                        case 'ready':
                            worker.postMessage({
                                type: 'run',
                                data: {
                                    params: args
                                }
                            }, transferData);
                            running();
                            break;
                        default:
                            break;
                    }
                };
                {
                    worker.onmessage = handler;
                }
                worker.onmessage = handler;
                worker.postMessage({
                    type: 'init',
                    data: {
                        memory: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory,
                        name: options.name || entity.name,
                        stackPointer,
                        stackSize: options.stackSize ?? _config__WEBPACK_IMPORTED_MODULE_3__.STACK_SIZE
                    }
                });
            });
        };
    }
    function runInMain(...args) {
        return new Promise((resolve, reject) => {
            const obj = {
                $worker: null,
                $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_5__["default"])(moduleId),
                $stackPointer: null,
                $type: 'function'
            };
            resolve(obj);
            obj.$retval = new Promise((resolve) => {
                resolve(entity(...args));
            });
        });
    }
    function transfer(...transfer) {
        transferData = transfer;
        return {
            run:  true && (_config__WEBPACK_IMPORTED_MODULE_3__.USE_THREADS && !options.disableWorker) ? runInWorker : runInMain
        };
    }
    return {
        run:  true && (_config__WEBPACK_IMPORTED_MODULE_3__.USE_THREADS && !options.disableWorker) ? runInWorker : runInMain,
        transfer
    };
}
function createThreadFromModule(entity, options = {}, moduleId) {
    let runInWorker;
    {
        runInWorker = () => {
            let worker;
            let moduleName = `__module_${moduleId}__`.replace(/\.|\//g, '_');
            if (moduleId instanceof Worker) {
                worker = moduleId;
            }
            else {
                let workerUrl;
                const cacheKey = getCacheKey(moduleId, 'module');
                if (caches.has(cacheKey)) {
                    workerUrl = caches.get(cacheKey).url;
                    caches.get(cacheKey).refCount++;
                }
                else {
                    const module = (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_2__["default"])(moduleId, {
                        varName: moduleName
                    });
                    const source = `
            ${module}
            ${initModule}
            init.default(${moduleName});
          `;
                    {
                        const blob = new Blob([source], { type: 'text/javascript' });
                        workerUrl = URL.createObjectURL(blob);
                    }
                    caches.set(cacheKey, {
                        url: workerUrl,
                        refCount: 1
                    });
                }
                worker = new Worker(workerUrl);
            }
            const channel = new MessageChannel();
            return new Promise((resolve, reject) => {
                const stackPointer = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(_config__WEBPACK_IMPORTED_MODULE_3__.STACK_ALIGNMENT, options.stackSize
                    ? ((options.stackSize + _config__WEBPACK_IMPORTED_MODULE_3__.STACK_ALIGNMENT) & ~_config__WEBPACK_IMPORTED_MODULE_3__.STACK_ALIGNMENT)
                    : _config__WEBPACK_IMPORTED_MODULE_3__.STACK_SIZE);
                function running() {
                    const ipc =  false ? 0 : new common_network_IPCPort__WEBPACK_IMPORTED_MODULE_4__["default"](channel.port1);
                    const obj = {
                        $worker: worker,
                        $ipc: ipc,
                        $channel: channel,
                        $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_5__["default"])(moduleId),
                        $stackPointer: stackPointer,
                        $type: 'module'
                    };
                    const { proxy, revoke } = Proxy.revocable(obj, {
                        get(target, propertyKey, receiver) {
                            if (target[propertyKey]) {
                                return obj[propertyKey];
                            }
                            if (propertyKey in entity && typeof entity[propertyKey] === 'function') {
                                const call = async function (...args) {
                                    return ipc.request(propertyKey, {
                                        params: args
                                    });
                                };
                                call.transfer = function (...transfer) {
                                    return {
                                        invoke: async function (...args) {
                                            return ipc.request(propertyKey, {
                                                params: args
                                            }, transfer);
                                        }
                                    };
                                };
                                target[propertyKey] = call;
                            }
                            return target[propertyKey];
                        }
                    });
                    obj[symbolRevoke] = revoke;
                    resolve(proxy);
                }
                const handler = (message) => {
                    const origin =  false ? 0 : message.data;
                    const type = origin.type;
                    const data = origin.data;
                    switch (type) {
                        case 'ready':
                            worker.postMessage({
                                type: 'run',
                                data: {
                                    port: channel.port2
                                }
                            }, [channel.port2]);
                            break;
                        case 'running':
                            running();
                            break;
                        default:
                            break;
                    }
                };
                {
                    worker.onmessage = handler;
                }
                worker.onmessage = handler;
                worker.postMessage({
                    type: 'init',
                    data: {
                        memory: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory,
                        name: options.name || moduleName,
                        stackPointer,
                        stackSize: options.stackSize ?? _config__WEBPACK_IMPORTED_MODULE_3__.STACK_SIZE
                    }
                });
            });
        };
    }
    function runInMain() {
        return new Promise((resolve, reject) => {
            const obj = {
                $worker: null,
                $ipc: null,
                $channel: null,
                $moduleId: (0,common_function_toString__WEBPACK_IMPORTED_MODULE_5__["default"])(moduleId),
                $stackPointer: 0,
                $instance: entity,
                $type: 'module'
            };
            const { proxy, revoke } = Proxy.revocable(obj, {
                get(target, propertyKey, receiver) {
                    if (target[propertyKey]) {
                        return obj[propertyKey];
                    }
                    if (propertyKey in entity && typeof entity[propertyKey] === 'function') {
                        const call = function (...args) {
                            return entity[propertyKey](...args);
                        };
                        call.transfer = function (...transfer) {
                            return {
                                invoke: function (...args) {
                                    return entity[propertyKey](...args);
                                }
                            };
                        };
                        target[propertyKey] = call;
                    }
                    return target[propertyKey];
                }
            });
            obj[symbolRevoke] = revoke;
            resolve(proxy);
        });
    }
    return {
        run:  true && (_config__WEBPACK_IMPORTED_MODULE_3__.USE_THREADS && !options.disableWorker) ? runInWorker : runInMain,
    };
}
function closeThread(thread) {
    if (thread.$worker) {
        thread.$worker.terminate();
        thread.$worker = null;
    }
    if (thread.$moduleId) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_6__.string(thread.$moduleId)) {
            const cacheKey = getCacheKey(thread.$moduleId, thread.$type);
            if (caches.has(cacheKey)) {
                caches.get(cacheKey).refCount--;
                if (caches.get(cacheKey).refCount === 0) {
                    {
                        URL.revokeObjectURL(caches.get(cacheKey).url);
                    }
                    caches.delete(cacheKey);
                }
            }
        }
        thread.$moduleId = null;
    }
    if (thread.$ipc) {
        thread.$ipc.destroy();
        thread.$ipc = null;
    }
    if (thread.$stackPointer) {
        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(thread.$stackPointer);
        thread.$stackPointer = 0;
    }
    thread.$channel = null;
    thread.$instance = null;
    if (thread[symbolRevoke]) {
        const revoke = thread[symbolRevoke];
        thread[symbolRevoke] = null;
        revoke();
    }
}
async function joinThread(thread) {
    if (thread.$worker) {
        return new Promise((resolve) => {
            function handler(message) {
                const origin =  false ? 0 : message.data;
                const type = origin.type;
                const data = origin.data;
                switch (type) {
                    case 'stopped':
                        closeThread(thread);
                        resolve(data);
                        break;
                    default:
                        break;
                }
            }
            {
                thread.$worker.onmessage = handler;
            }
            thread.$worker.postMessage({
                type: 'stop'
            });
        });
    }
    else if (thread.$retval) {
        return thread.$retval;
    }
}


/***/ }),

/***/ "./src/cheap/typedef.ts":
/*!******************************!*\
  !*** ./src/cheap/typedef.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CTypeEnum2Bytes: () => (/* binding */ CTypeEnum2Bytes),
/* harmony export */   CTypeEnumPointerShiftMap: () => (/* binding */ CTypeEnumPointerShiftMap)
/* harmony export */ });
const CTypeEnum2Bytes = {
    [2 /* CTypeEnum.uint8 */]: 1,
    [3 /* CTypeEnum.atomic_uint8 */]: 1,
    [4 /* CTypeEnum.char */]: 1,
    [5 /* CTypeEnum.atomic_char */]: 1,
    [6 /* CTypeEnum.uint16 */]: 2,
    [7 /* CTypeEnum.atomic_uint16 */]: 2,
    [8 /* CTypeEnum.uint32 */]: 4,
    [9 /* CTypeEnum.atomic_uint32 */]: 4,
    [10 /* CTypeEnum.uint64 */]: 8,
    [11 /* CTypeEnum.int8 */]: 1,
    [12 /* CTypeEnum.atomic_int8 */]: 1,
    [13 /* CTypeEnum.int16 */]: 2,
    [14 /* CTypeEnum.atomic_int16 */]: 2,
    [15 /* CTypeEnum.int32 */]: 4,
    [16 /* CTypeEnum.atomic_int32 */]: 4,
    [17 /* CTypeEnum.int64 */]: 8,
    [18 /* CTypeEnum.float */]: 4,
    [19 /* CTypeEnum.double */]: 8,
    [20 /* CTypeEnum.pointer */]: 4,
    [0 /* CTypeEnum.null */]: 4,
    [1 /* CTypeEnum.void */]: 4,
    [22 /* CTypeEnum.atomic_uint64 */]: 8,
    [21 /* CTypeEnum.atomic_int64 */]: 8,
    [23 /* CTypeEnum.bool */]: 1,
    [24 /* CTypeEnum.atomic_bool */]: 1
};
const CTypeEnumPointerShiftMap = {
    [2 /* CTypeEnum.uint8 */]: 0,
    [3 /* CTypeEnum.atomic_uint8 */]: 0,
    [4 /* CTypeEnum.char */]: 0,
    [5 /* CTypeEnum.atomic_char */]: 0,
    [6 /* CTypeEnum.uint16 */]: 1,
    [7 /* CTypeEnum.atomic_uint16 */]: 1,
    [8 /* CTypeEnum.uint32 */]: 2,
    [9 /* CTypeEnum.atomic_uint32 */]: 2,
    [10 /* CTypeEnum.uint64 */]: 4,
    [11 /* CTypeEnum.int8 */]: 0,
    [12 /* CTypeEnum.atomic_int8 */]: 0,
    [13 /* CTypeEnum.int16 */]: 1,
    [14 /* CTypeEnum.atomic_int16 */]: 1,
    [15 /* CTypeEnum.int32 */]: 2,
    [16 /* CTypeEnum.atomic_int32 */]: 2,
    [17 /* CTypeEnum.int64 */]: 4,
    [18 /* CTypeEnum.float */]: 2,
    [19 /* CTypeEnum.double */]: 4,
    [20 /* CTypeEnum.pointer */]: 2,
    [1 /* CTypeEnum.void */]: 2,
    [0 /* CTypeEnum.null */]: 2,
    [22 /* CTypeEnum.atomic_uint64 */]: 4,
    [21 /* CTypeEnum.atomic_int64 */]: 4,
    [23 /* CTypeEnum.bool */]: 0,
    [24 /* CTypeEnum.atomic_bool */]: 0
};


/***/ }),

/***/ "./src/cheap/webassembly/WebAssemblyRunner.ts":
/*!****************************************************!*\
  !*** ./src/cheap/webassembly/WebAssemblyRunner.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebAssemblyRunner)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var cheap_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../heap */ "./src/cheap/heap.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var common_util_array__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! common/util/array */ "./src/common/util/array.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var _std_memory__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var _runtime_clib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./runtime/clib */ "./src/cheap/webassembly/runtime/clib.ts");
/* harmony import */ var _runtime_atomic__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./runtime/atomic */ "./src/cheap/webassembly/runtime/atomic.ts");
/* harmony import */ var _runtime_pthread__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./runtime/pthread */ "./src/cheap/webassembly/runtime/pthread.ts");
/* harmony import */ var _runtime_semaphore__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./runtime/semaphore */ "./src/cheap/webassembly/runtime/semaphore.ts");
/* harmony import */ var common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/function/sourceLoad */ "./src/common/function/sourceLoad.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");
/* harmony import */ var _thread_atomics__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../thread/asm/atomics */ "./src/cheap/thread/asm/atomics.ts");
/* harmony import */ var _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./runtime/asm/thread */ "./src/cheap/webassembly/runtime/asm/thread.ts");
/* harmony import */ var common_function_isWorker__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! common/function/isWorker */ "./src/common/function/isWorker.ts");
var cheap__fileName__6 = "src/cheap/webassembly/WebAssemblyRunner.ts";





/* eslint-disable camelcase */
















{
    // 保证打包工具包含下面的模块代码
    __webpack_require__(/*! ./runThread */ "./src/cheap/webassembly/runThread.ts");
}
const runThread =  true ? (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_1__["default"])(/*require.resolve*/(/*! ./runThread */ "./src/cheap/webassembly/runThread.ts"), {
    varName: 'init'
}) : 0;
function emptyFunction() { }
let atomicAsmOverride = false;
class ThreadDescriptor {
    flags;
}
(function (prototype) {
    var map = new Map();
    map.set("flags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_2__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_3__.symbolStructKeysMeta, map);
})(ThreadDescriptor.prototype);
class WebAssemblyRunner {
    static getTable() {
        return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table;
    }
    resource;
    /**
     * WebAssembly runtime 实例
     */
    instance;
    /**
     * 配置项
     */
    options;
    builtinMalloc;
    memoryBase;
    tableBase;
    childImports;
    childUrl;
    childBlob;
    childThreads;
    imports;
    childReadyPromises;
    constructor(resource, options = {}) {
        this.resource = resource;
        this.builtinMalloc = [];
        this.childThreads = new Map();
        this.childReadyPromises = [];
        if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.string(options.childImports)) {
            this.childImports = options.childImports;
        }
        else if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.object(options.childImports) && options.childImports instanceof Blob) {
            this.childImports = URL.createObjectURL(options.childImports);
        }
        this.memoryBase = resource.dataSize ? cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(resource.dataSize) : 0;
        // 子线程的 tableBase 需要和父线程一致
        if (options.thread && options.tableBase) {
            if (cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.getPointer() !== options.tableBase) {
                cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.alloc(options.tableBase - cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.getPointer());
            }
        }
        this.tableBase = resource.tableSize ? cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.alloc(resource.tableSize) : 0;
        this.options = options;
        this.imports = {
            env: {
                memory: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory,
                __stack_pointer: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.StackPointer,
                __indirect_function_table: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.table,
                clock_time_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_5__.clock_time_get,
                clock_res_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_5__.clock_res_get,
                random_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_5__.random_get,
                abort: _runtime_clib__WEBPACK_IMPORTED_MODULE_5__.abort,
                proc_exit: function (exitCode) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_6__.error(`wasm module exit, code: ${exitCode}`, cheap__fileName__6, 133);
                },
                environ_get: emptyFunction,
                environ_sizes_get: emptyFunction,
                fd_close: emptyFunction,
                fd_fdstat_get: _runtime_clib__WEBPACK_IMPORTED_MODULE_5__.fd_fdstat_get,
                fd_read: emptyFunction,
                fd_seek: emptyFunction,
                fd_write: _runtime_clib__WEBPACK_IMPORTED_MODULE_5__.fd_write,
                emscripten_builtin_malloc: (size) => {
                    const p = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(size);
                    this.builtinMalloc.push(p);
                    return p;
                },
                emscripten_builtin_free: (pointer) => {
                    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(pointer);
                },
                emscripten_builtin_memalign: (memptr, alignment, size) => {
                    const address = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(alignment, size);
                    if (address !== 0) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[20](memptr, address);
                        this.builtinMalloc.push(address);
                        return 0;
                    }
                    return -1;
                },
                emscripten_memcpy_big: function (dest, src, num) {
                    (0,_std_memory__WEBPACK_IMPORTED_MODULE_8__.memcpy)(dest, src, num);
                },
                __libc_malloc: function (size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(size);
                },
                malloc: function (size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(size);
                },
                calloc: function (num, size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.calloc(num, size);
                },
                realloc: function (pointer, size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.realloc(pointer, size);
                },
                aligned_alloc(alignment, size) {
                    return cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(alignment, size);
                },
                free: function (pointer) {
                    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(pointer);
                },
                posix_memalign: function (memptr, alignment, size) {
                    const address = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(alignment, size);
                    if (address !== 0) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[20](memptr, address);
                        return 0;
                    }
                    return -1;
                }
            }
        };
        {
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, {
                wasm_pthread_create: (thread, attr, func, args) => {
                    if (!this.childUrl) {
                        const module = (0,common_function_sourceLoad__WEBPACK_IMPORTED_MODULE_1__["default"])(/*require.resolve*/(/*! ./WebAssemblyRunner.ts */ "./src/cheap/webassembly/WebAssemblyRunner.ts"), {
                            varName: '__WebAssemblyRunner__',
                            exportName: '__WebAssemblyRunner__',
                            pointName: WebAssemblyRunner.name,
                            exportIsClass: true
                        });
                        const source = `
              ${module}
              ${runThread}
              var preRun;
              ${this.childImports ? `
              preRun = import('${this.childImports}')
              ` : ''}
              init.default(preRun);
            `;
                        this.childBlob = new Blob([source], { type: 'text/javascript' });
                        this.childUrl = URL.createObjectURL(this.childBlob);
                    }
                    const worker = new Worker(this.childUrl);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[15](thread, (0,cheap_heap__WEBPACK_IMPORTED_MODULE_0__.allocThreadId)());
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[16](thread + 12, 1 /* PthreadStatus.RUN */);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[15](thread + 8, 0);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[20](thread + 4, 0);
                    const stackPointer = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.alignedAlloc(_config__WEBPACK_IMPORTED_MODULE_10__.STACK_ALIGNMENT, _config__WEBPACK_IMPORTED_MODULE_10__.STACK_SIZE);
                    const threadDescriptor = cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.malloc(4);
                    (0,_std_memory__WEBPACK_IMPORTED_MODULE_8__.memset)(threadDescriptor, 0, 4);
                    this.childThreads.set(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](thread), {
                        thread,
                        worker,
                        stackPointer,
                        threadDescriptor
                    });
                    let resolve;
                    this.childReadyPromises.push(new Promise((r) => {
                        resolve = r;
                    }));
                    worker.onmessage = (message) => {
                        const origin = message.data;
                        const type = origin.type;
                        const data = origin.data;
                        switch (type) {
                            case 'run':
                                resolve();
                                break;
                        }
                    };
                    /**
                     * postMessage 并不是同步的，而是在事件循环中处理的
                     * 因此父线程不能被阻塞在当前的事件循环中，否则子线程无法成功运行
                     * 只有 childReadyPromises 中的 Promise 都 resolve 了之后才能阻塞
                     */
                    worker.postMessage({
                        type: 'run',
                        data: {
                            cheap: {
                                memory: cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory,
                                stackPointer,
                                stackSize: _config__WEBPACK_IMPORTED_MODULE_10__.STACK_SIZE,
                                id: cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](thread)
                            },
                            runner: {
                                resource: {
                                    tableSize: this.resource.tableSize,
                                    module: this.resource.threadModule.module,
                                    initFuncs: this.resource.threadModule.initFuncs
                                },
                                options: {
                                    memoryBase: this.options.memoryBase || this.memoryBase,
                                    tableBase: this.tableBase,
                                    thread,
                                    threadDescriptor,
                                    childImports: this.childImports
                                },
                                func,
                                args,
                                imports: this.childImports,
                                thread
                            }
                        }
                    });
                    return 0;
                },
                wasm_pthread_join2: (thread, retval) => {
                    if (cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](thread + 8) & 1 /* PthreadFlags.DETACH */) {
                        this.childThreads.delete(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](thread));
                        return 0;
                    }
                    // 等待子线程退出
                    _thread_atomics__WEBPACK_IMPORTED_MODULE_12__.wait(thread + 12, 1 /* PthreadStatus.RUN */);
                    if (retval !== 0) {
                        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[20](retval, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[20](thread + 4));
                    }
                    const child = this.childThreads.get(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](thread));
                    // 回收栈
                    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(child.stackPointer);
                    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(child.threadDescriptor);
                    child.worker.terminate();
                    this.childThreads.delete(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](thread));
                    return 0;
                },
                wasm_pthread_detach2: (thread) => {
                    const child = this.childThreads.get(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](thread));
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[15](child.threadDescriptor, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](child.threadDescriptor) | 1 /* PthreadFlags.DETACH */);
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[15](thread + 8, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](thread + 8) | 1 /* PthreadFlags.DETACH */);
                }
            });
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, _runtime_atomic__WEBPACK_IMPORTED_MODULE_13__);
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, _runtime_pthread__WEBPACK_IMPORTED_MODULE_14__);
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, _runtime_semaphore__WEBPACK_IMPORTED_MODULE_15__);
        }
        if (this.memoryBase) {
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, {
                __memory_base: this.memoryBase
            });
        }
        // 使用父线程的 memoryBase
        else if (options.memoryBase) {
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, {
                __memory_base: options.memoryBase
            });
        }
        if (this.tableBase) {
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, {
                __table_base: this.tableBase
            });
        }
        if (options.imports?.env) {
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, options.imports.env);
            if (options.envKey && options.importMap) {
                const env = {};
                common_util_object__WEBPACK_IMPORTED_MODULE_9__.each(this.imports.env, (value, key) => {
                    if (options.importMap[key]) {
                        env[options.importMap[key]] = value;
                    }
                });
                this.imports[options.envKey] = env;
            }
        }
        this.imports['wasi_snapshot_preview1'] = this.imports.env;
    }
    overrideAtomic() {
        _runtime_atomic__WEBPACK_IMPORTED_MODULE_13__.override({
            atomic_add_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.add8,
            atomic_sub_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.sub8,
            atomic_and_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.and8,
            atomic_or_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.or8,
            atomic_xor_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.xor8,
            atomic_store_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.store8,
            atomic_load_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.load8,
            atomic_compare_exchange_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.compare_exchange8,
            atomic_exchange_i8: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.exchange8,
            atomic_add_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.add16,
            atomic_sub_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.sub16,
            atomic_and_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.and16,
            atomic_or_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.or16,
            atomic_xor_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.xor16,
            atomic_store_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.store16,
            atomic_load_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.load16,
            atomic_compare_exchange_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.compare_exchange16,
            atomic_exchange_i16: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.exchange16,
            atomic_add_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.add32,
            atomic_sub_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.sub32,
            atomic_and_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.and32,
            atomic_or_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.or32,
            atomic_xor_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.xor32,
            atomic_store_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.store32,
            atomic_load_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.load32,
            atomic_compare_exchange_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.compare_exchange32,
            atomic_exchange_i32: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.exchange32,
            atomic_add_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.add64,
            atomic_sub_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.sub64,
            atomic_and_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.and64,
            atomic_or_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.or64,
            atomic_xor_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.xor64,
            atomic_store_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.store64,
            atomic_load_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.load64,
            atomic_compare_exchange_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.compare_exchange64,
            atomic_exchange_i64: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.exchange64,
            atomics_notify: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.notify,
            atomics_wait: _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.instance.exports.wait
        });
        common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, _runtime_atomic__WEBPACK_IMPORTED_MODULE_13__);
    }
    /**
     * 运行 wasm 实例
     */
    async run(imports) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.object(imports)) {
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.options.imports, imports);
        }
        if ( true
            && (0,common_function_isWorker__WEBPACK_IMPORTED_MODULE_17__["default"])()
            && !_runtime_asm_thread__WEBPACK_IMPORTED_MODULE_18__.wasmThreadProxy
            && _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_18__.isSupport()
            && this.resource.threadModule) {
            await _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_18__.init(cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory, _runtime_pthread__WEBPACK_IMPORTED_MODULE_14__.override);
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, _runtime_pthread__WEBPACK_IMPORTED_MODULE_14__);
        }
        if (!atomicAsmOverride && _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.isSupport()) {
            atomicAsmOverride = true;
            this.overrideAtomic();
        }
        this.instance = await WebAssembly.instantiate(this.resource.module, this.imports);
        this.initRunTime();
    }
    async runAsChild(imports) {
        if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.object(imports)) {
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.options.imports, imports);
        }
        if ( true && !_runtime_asm_thread__WEBPACK_IMPORTED_MODULE_18__.wasmThreadProxy && _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_18__.isSupport()) {
            await _runtime_asm_thread__WEBPACK_IMPORTED_MODULE_18__.init(cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Memory, _runtime_pthread__WEBPACK_IMPORTED_MODULE_14__.override);
            common_util_object__WEBPACK_IMPORTED_MODULE_9__.extend(this.imports.env, _runtime_pthread__WEBPACK_IMPORTED_MODULE_14__);
        }
        if (!atomicAsmOverride && _thread_asm_atomics__WEBPACK_IMPORTED_MODULE_16__.isSupport()) {
            atomicAsmOverride = true;
            this.overrideAtomic();
        }
        this.instance = new WebAssembly.Instance(this.resource.module, this.imports);
        this.initRunTime();
    }
    async childrenThreadReady() {
        if (!this.childReadyPromises.length) {
            return;
        }
        const promise = this.childReadyPromises;
        this.childReadyPromises = [];
        await Promise.all(promise);
    }
    initRunTime() {
        this.builtinMalloc = [];
        if (common_util_is__WEBPACK_IMPORTED_MODULE_4__.array(this.resource.initFuncs)) {
            common_util_array__WEBPACK_IMPORTED_MODULE_19__.each(this.resource.initFuncs, (func) => {
                this.call(func);
            });
        }
    }
    /**
     * 调用 wasm 模块暴露的方法
     *
     * @param func 方法名
     * @param args 参数，只能是 number 和 bigint( 有浏览器版本要求， 建议 64 位数据使用指针传递） 类型，如果是其他类型参数使用指针传递
     */
    call(func, ...args) {
        if (!this.asm) {
            return -1;
        }
        let call;
        if (this.asm[func]) {
            call = this.asm[func];
        }
        else if (this.options.exportMap && this.options.exportMap[func] && this.asm[this.options.exportMap[func]]) {
            call = this.asm[this.options.exportMap[func]];
        }
        if (call) {
            return call.apply(null, args);
        }
        else {
            common_util_logger__WEBPACK_IMPORTED_MODULE_6__.error(`the wasm module has not function ${func} to call`, cheap__fileName__6, 489);
        }
    }
    get asm() {
        return this.instance && this.instance.exports;
    }
    getInstance() {
        return this.instance;
    }
    destroy() {
        if (this.builtinMalloc?.length) {
            common_util_array__WEBPACK_IMPORTED_MODULE_19__.each(this.builtinMalloc, (pointer) => {
                cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(pointer);
            });
            this.builtinMalloc.length = 0;
        }
        if (this.memoryBase) {
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(this.memoryBase);
            this.memoryBase = null;
        }
        if (this.tableBase) {
            cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Table.free(this.tableBase);
            this.tableBase = null;
        }
        if (this.childImports) {
            URL.revokeObjectURL(this.childImports);
            this.childImports = null;
        }
        if (this.childUrl) {
            URL.revokeObjectURL(this.childUrl);
            this.childUrl = null;
        }
        this.childBlob = null;
        this.childReadyPromises.length = 0;
        if (this.childThreads.size) {
            this.childThreads.forEach((thread, id) => {
                if (!(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](thread.threadDescriptor) & 1 /* PthreadFlags.DETACH */)) {
                    common_util_logger__WEBPACK_IMPORTED_MODULE_6__.warn('has child thread running, maybe resource leakage', cheap__fileName__6, 534);
                    thread.worker.terminate();
                    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[16](thread.thread + 12, 0 /* PthreadStatus.STOP */);
                    if (thread.stackPointer) {
                        cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(thread.stackPointer);
                    }
                    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(thread.threadDescriptor);
                    this.childThreads.delete(id);
                }
            });
        }
        this.builtinMalloc = null;
        this.instance = null;
        if (this.options.thread) {
            if (this.options.threadDescriptor && cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_11__.CTypeEnumRead[15](this.options.threadDescriptor) & 1 /* PthreadFlags.DETACH */) {
                if (cheap_heap__WEBPACK_IMPORTED_MODULE_0__.StackTop) {
                    cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(cheap_heap__WEBPACK_IMPORTED_MODULE_0__.StackTop);
                }
                cheap_heap__WEBPACK_IMPORTED_MODULE_0__.Allocator.free(this.options.threadDescriptor);
                self.close();
            }
            else {
                cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_7__.CTypeEnumWrite[16](this.options.thread + 12, 0 /* PthreadStatus.STOP */
                // 唤醒父线程收回资源
                );
                // 唤醒父线程收回资源
                _thread_atomics__WEBPACK_IMPORTED_MODULE_12__.notify(this.options.thread + 12, 1);
            }
        }
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/compiler.ts":
/*!*******************************************!*\
  !*** ./src/cheap/webassembly/compiler.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ compile)
/* harmony export */ });
/* harmony import */ var common_util_is__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/is */ "./src/common/util/is.ts");
/* harmony import */ var common_io_IOReader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! common/io/IOReader */ "./src/common/io/IOReader.ts");
/* harmony import */ var common_io_IOWriter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! common/io/IOWriter */ "./src/common/io/IOWriter.ts");
/* harmony import */ var common_util_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/wasm */ "./src/common/util/wasm.ts");
/* harmony import */ var common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! common/function/concatTypeArray */ "./src/common/function/concatTypeArray.ts");
/* harmony import */ var common_util_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/object */ "./src/common/util/object.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../config */ "./src/cheap/config.ts");







async function process(context) {
    try {
        // `\0asm`
        await context.ioWriter.writeUint32(await context.ioReader.readUint32());
        // Version
        await context.ioWriter.writeUint32(await context.ioReader.readUint32());
        while (true) {
            if (context.compileStopped) {
                if (context.abortController) {
                    context.abortController.abort();
                }
                break;
            }
            const sectionId = await context.ioReader.readUint8();
            if (context.options.child) {
                if (sectionId === 11 /* SectionId.Data */) {
                    await context.ioWriter.writeUint8(sectionId);
                    // size
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, 7);
                    // count
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, 1);
                    // index
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, 0);
                    // init_expr i32_const 0
                    await context.ioWriter.writeUint8(0x41);
                    await context.ioWriter.writeUint8(0x00);
                    await context.ioWriter.writeUint8(0x0b);
                    // size
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, 1);
                    await context.ioWriter.writeUint8(0x00);
                    const size = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
                    await context.ioReader.skip(size);
                    continue;
                }
            }
            await context.ioWriter.writeUint8(sectionId);
            const size = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, size);
            const now = context.ioReader.getPos();
            if (sectionId === 11 /* SectionId.Data */) {
                /**
                 * - count: varuint32
                 * - entries: data_segment*
                 *   - index varuint32 the linear memory index (0 in the MVP)
                 *   - offset init_expr
                 *   - size varuint32
                 *   - data bytes
                 */
                const count = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
                await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, count);
                if (count) {
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader));
                    while (true) {
                        const byte = await context.ioReader.readUint8();
                        await context.ioWriter.writeUint8(byte);
                        if (byte === 0x0b) {
                            break;
                        }
                    }
                    context.data.dataSize = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, context.data.dataSize);
                }
            }
            else if (sectionId === 2 /* SectionId.Import */) {
                /**
                 * - count: varuint32
                 * - entries: import_entry*
                 *   - module_len varuint32
                 *   - module_str bytes
                 *   - field_len varuint32
                 *   - field_str bytes
                 *   - external_kind
                 */
                let count = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
                await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, count);
                let counter = 0;
                while (count--) {
                    const moduleLen = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, moduleLen);
                    await context.ioWriter.writeBuffer(await context.ioReader.readBuffer(moduleLen));
                    const fieldLen = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
                    await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, fieldLen);
                    await context.ioWriter.writeBuffer(await context.ioReader.readBuffer(fieldLen));
                    const externalKind = await context.ioReader.readUint8();
                    await context.ioWriter.writeUint8(externalKind);
                    switch (externalKind) {
                        case 0 /* ExternalKind.Function */: {
                            // type index of the function signature
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader));
                            break;
                        }
                        case 3 /* ExternalKind.Global */: {
                            // content_type
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeSleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readSLeb128Async)(context.ioReader));
                            // mutability
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader));
                            break;
                        }
                        case 2 /* ExternalKind.Memory */: {
                            let flags = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
                            if (context.options.enableThread) {
                                flags |= 2;
                            }
                            else {
                                flags &= ~2;
                            }
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, flags);
                            // initial
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader));
                            if (flags & 0x01) {
                                // maximum
                                await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader));
                            }
                            counter++;
                            break;
                        }
                        case 1 /* ExternalKind.Table */: {
                            // elem_type
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeSleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readSLeb128Async)(context.ioReader));
                            const flags = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, flags);
                            const initial = await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader);
                            await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, initial);
                            context.data.tableSize = initial;
                            if (flags & 0x01) {
                                // maximum
                                await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.writeUleb128Async)(context.ioWriter, await (0,common_util_wasm__WEBPACK_IMPORTED_MODULE_0__.readULeb128Async)(context.ioReader));
                            }
                            counter++;
                            break;
                        }
                    }
                    if (counter === 2) {
                        break;
                    }
                }
            }
            const remainingLength = size - Number(context.ioReader.getPos() - now);
            if (remainingLength) {
                await context.ioReader.pipe(context.ioWriter, size - Number(context.ioReader.getPos() - now));
            }
        }
    }
    catch (e) {
        if (context.ioReader.error === -1048576 /* IOError.END */) {
            context.bufferEnded = true;
        }
        else {
            context.error = e;
        }
        if (context.ioReader.remainingLength()) {
            await context.ioWriter.writeBuffer(await context.ioReader.readBuffer(context.ioReader.remainingLength()));
        }
        await context.ioWriter.flush();
    }
}
async function compile(source, options = {}) {
    let module;
    let tableSize;
    let dataSize;
    let buffer;
    options = common_util_object__WEBPACK_IMPORTED_MODULE_1__.extend({
        enableThread: _config__WEBPACK_IMPORTED_MODULE_2__.USE_THREADS,
        initFuncs: options.child ? [] : ['__wasm_apply_data_relocs']
    }, options);
    if (common_util_is__WEBPACK_IMPORTED_MODULE_3__.number(source.dataSize) && common_util_is__WEBPACK_IMPORTED_MODULE_3__.number(source.tableSize)) {
        tableSize = source.dataSize;
        dataSize = source.dataSize;
        if (common_util_is__WEBPACK_IMPORTED_MODULE_3__.string(source.source)) {
            const params = {
                method: 'GET',
                headers: {},
                mode: 'cors',
                cache: 'default',
                referrerPolicy: 'no-referrer-when-downgrade'
            };
            if (common_util_is__WEBPACK_IMPORTED_MODULE_3__.func(WebAssembly.compileStreaming)) {
                module = await WebAssembly.compileStreaming(fetch(source.source, params));
            }
            else {
                const response = await fetch(source.source, params);
                buffer = await response.arrayBuffer();
                module = await WebAssembly.compile(buffer);
            }
        }
        else {
            module = await WebAssembly.compile(source.source);
            buffer = common_util_is__WEBPACK_IMPORTED_MODULE_3__.arrayBuffer(source.source) ? source.source : source.source.buffer;
        }
    }
    else {
        const context = {
            ioReader: new common_io_IOReader__WEBPACK_IMPORTED_MODULE_4__["default"](1048576),
            ioWriter: new common_io_IOWriter__WEBPACK_IMPORTED_MODULE_5__["default"](1048576),
            bufferEnded: false,
            compileStopped: false,
            error: '',
            abortController: null,
            pullResolve: null,
            bufferResolve: null,
            buffers: [],
            data: {},
            options
        };
        const response = new Response(new ReadableStream({
            async start(controller) {
                if (common_util_is__WEBPACK_IMPORTED_MODULE_3__.string(source.source)) {
                    if (AbortController) {
                        context.abortController = new AbortController();
                    }
                    const params = {
                        method: 'GET',
                        headers: {},
                        mode: 'cors',
                        cache: 'default',
                        referrerPolicy: 'no-referrer-when-downgrade',
                        signal: context.abortController?.signal
                    };
                    const res = await fetch(source.source, params);
                    let reader;
                    if (res.ok && (res.status >= 200 && res.status <= 299)) {
                        reader = res.body.getReader();
                    }
                    else {
                        controller.error(`Http code invalid, ${res.status} ${res.statusText}`);
                    }
                    const buffers = [];
                    context.ioReader.onFlush = async (buffer) => {
                        let pos = 0;
                        while (buffers.length && pos < buffer.length) {
                            const cache = buffers.shift();
                            if (cache.length > buffer.length - pos) {
                                buffer.set(cache.subarray(0, buffer.length - pos), pos);
                                buffers.unshift(cache.subarray(buffer.length - pos));
                                pos = buffer.length;
                            }
                            else {
                                buffer.set(cache, pos);
                                pos += cache.length;
                            }
                        }
                        if (pos >= buffer.length) {
                            return buffer.length;
                        }
                        const { value, done } = await reader.read();
                        if (done) {
                            return pos > 0 ? pos : -1048576 /* IOError.END */;
                        }
                        else {
                            context.buffers.push(value);
                            if (value.length > buffer.length - pos) {
                                buffer.set(value.subarray(0, buffer.length - pos), pos);
                                buffers.push(value.subarray(buffer.length - pos));
                                return buffer.length;
                            }
                            else {
                                buffer.set(value, pos);
                                pos += value.length;
                                return pos;
                            }
                        }
                    };
                }
                else {
                    let readPos = 0;
                    let readFileLength = source.source.byteLength;
                    const wasm = common_util_is__WEBPACK_IMPORTED_MODULE_3__.arrayBuffer(source.source) ? new Uint8Array(source.source) : source.source;
                    context.ioReader.onFlush = async (buffer) => {
                        if (readPos >= readFileLength) {
                            return -1048576 /* IOError.END */;
                        }
                        const len = Math.min(buffer.length, readFileLength - readPos);
                        buffer.set(wasm.subarray(readPos, readPos + len), 0);
                        readPos += len;
                        return len;
                    };
                }
                context.ioWriter.onFlush = async (buffer) => {
                    if (context.pullResolve) {
                        context.pullResolve(buffer.slice());
                        context.pullResolve = null;
                        return 0;
                    }
                    (await new Promise((resolve, reject) => {
                        context.bufferResolve = resolve;
                    })).enqueue(buffer.slice());
                    return 0;
                };
                process(context);
            },
            async pull(controller) {
                if (context.error) {
                    controller.close();
                    return;
                }
                if (context.bufferResolve) {
                    context.bufferResolve(controller);
                    context.bufferResolve = null;
                    return;
                }
                controller.enqueue(await new Promise((resolve, reject) => {
                    context.pullResolve = resolve;
                }));
                if (context.bufferEnded) {
                    controller.close();
                }
                else if (context.error) {
                    controller.error(context.error);
                }
            },
            cancel(reason) {
                context.compileStopped = true;
            }
        }), {
            headers: {
                'Content-Type': 'application/wasm'
            }
        });
        if (common_util_is__WEBPACK_IMPORTED_MODULE_3__.func(WebAssembly.compileStreaming)) {
            module = await WebAssembly.compileStreaming(response);
        }
        else {
            module = await WebAssembly.compile(await response.arrayBuffer());
        }
        buffer = common_util_is__WEBPACK_IMPORTED_MODULE_3__.string(source.source)
            ? (0,common_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_6__["default"])(Uint8Array, context.buffers).buffer
            : (common_util_is__WEBPACK_IMPORTED_MODULE_3__.arrayBuffer(source.source) ? source.source : source.source.buffer);
        tableSize = context.data.tableSize;
        dataSize = context.data.dataSize;
    }
    if (options.child) {
        return {
            module,
            initFuncs: options.initFuncs || []
        };
    }
    return {
        module,
        tableSize,
        dataSize,
        initFuncs: options.initFuncs || [],
        buffer: buffer
    };
}


/***/ }),

/***/ "./src/cheap/webassembly/runThread.ts":
/*!********************************************!*\
  !*** ./src/cheap/webassembly/runThread.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ init)
/* harmony export */ });
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");

// @ts-ignore
common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.imports = {
    env: {}
};
let parentPort = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF;
function init(preRun) {
    const handler = (message) => {
        const origin =  false ? 0 : message.data;
        const type = origin.type;
        const data = origin.data;
        let runner;
        switch (type) {
            case 'run':
                parentPort.postMessage({
                    type: 'run'
                });
                if (common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap && common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread) {
                    common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.CHeap.initThread(data.cheap).then(() => {
                        function run() {
                            common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.__SELF_THREAD__ = data.runner.thread;
                            // @ts-ignore
                            data.runner.options.imports = common_util_constant__WEBPACK_IMPORTED_MODULE_0__.SELF.imports;
                            // @ts-ignore
                            runner = new __WebAssemblyRunner__.__WebAssemblyRunner__(data.runner.resource, data.runner.options);
                            runner.runAsChild().then(() => {
                                // @ts-ignore
                                __WebAssemblyRunner__.__WebAssemblyRunner__.getTable().get(data.runner.func)(data.runner.args);
                                runner.destroy();
                            });
                        }
                        if (preRun) {
                            preRun.then(() => {
                                run();
                            });
                        }
                        else {
                            run();
                        }
                    });
                }
                break;
        }
    };
    {
        parentPort.onmessage = handler;
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/asm/thread.ts":
/*!*****************************************************!*\
  !*** ./src/cheap/webassembly/runtime/asm/thread.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   init: () => (/* binding */ init),
/* harmony export */   isSupport: () => (/* binding */ isSupport),
/* harmony export */   wasmThreadProxy: () => (/* binding */ wasmThreadProxy)
/* harmony export */ });
/* harmony import */ var common_util_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/base64 */ "./src/common/util/base64.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _thread_asm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./thread.asm */ "./src/cheap/webassembly/runtime/asm/thread.asm");
/* harmony import */ var _thread_asm__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_thread_asm__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var common_util_wasm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! common/util/wasm */ "./src/common/util/wasm.ts");
var cheap__fileName__0 = "src/cheap/webassembly/runtime/asm/thread.ts";
/* eslint-disable camelcase */




/**
 * WebAssembly runtime 实例
 */
let wasmThreadProxy;
let support = true;
function isSupport() {
    return support;
}
async function init(memory, override) {
    try {
        if (typeof SharedArrayBuffer === 'function' && memory.buffer instanceof SharedArrayBuffer) {
            const wasm = (0,common_util_base64__WEBPACK_IMPORTED_MODULE_0__.base64ToUint8Array)((_thread_asm__WEBPACK_IMPORTED_MODULE_1___default()));
            common_util_wasm__WEBPACK_IMPORTED_MODULE_2__.setMemoryShared(wasm, true);
            wasmThreadProxy = (await WebAssembly.instantiate(wasm, {
                env: {
                    memory
                }
            })).instance;
        }
        else {
            support = false;
            return;
        }
        override({
            wasm_pthread_mutex_lock: wasmThreadProxy.exports.lock,
            wasm_pthread_mutex_unlock: wasmThreadProxy.exports.unlock,
            wasm_pthread_cond_wait: wasmThreadProxy.exports.wait,
            wasm_pthread_cond_timedwait: wasmThreadProxy.exports.timedwait,
            wasm_pthread_cond_signal: wasmThreadProxy.exports.signal,
            wasm_pthread_cond_broadcast: wasmThreadProxy.exports.broadcast
        });
    }
    catch (error) {
        support = false;
        common_util_logger__WEBPACK_IMPORTED_MODULE_3__.warn('thread asm not support, cannot use asm thread function', cheap__fileName__0, 65);
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/atomic.ts":
/*!*************************************************!*\
  !*** ./src/cheap/webassembly/runtime/atomic.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   atomic_add_i16: () => (/* binding */ atomic_add_i16),
/* harmony export */   atomic_add_i32: () => (/* binding */ atomic_add_i32),
/* harmony export */   atomic_add_i64: () => (/* binding */ atomic_add_i64),
/* harmony export */   atomic_add_i8: () => (/* binding */ atomic_add_i8),
/* harmony export */   atomic_and_i16: () => (/* binding */ atomic_and_i16),
/* harmony export */   atomic_and_i32: () => (/* binding */ atomic_and_i32),
/* harmony export */   atomic_and_i64: () => (/* binding */ atomic_and_i64),
/* harmony export */   atomic_and_i8: () => (/* binding */ atomic_and_i8),
/* harmony export */   atomic_compare_exchange_i16: () => (/* binding */ atomic_compare_exchange_i16),
/* harmony export */   atomic_compare_exchange_i32: () => (/* binding */ atomic_compare_exchange_i32),
/* harmony export */   atomic_compare_exchange_i64: () => (/* binding */ atomic_compare_exchange_i64),
/* harmony export */   atomic_compare_exchange_i8: () => (/* binding */ atomic_compare_exchange_i8),
/* harmony export */   atomic_exchange_i16: () => (/* binding */ atomic_exchange_i16),
/* harmony export */   atomic_exchange_i32: () => (/* binding */ atomic_exchange_i32),
/* harmony export */   atomic_exchange_i64: () => (/* binding */ atomic_exchange_i64),
/* harmony export */   atomic_exchange_i8: () => (/* binding */ atomic_exchange_i8),
/* harmony export */   atomic_load_i16: () => (/* binding */ atomic_load_i16),
/* harmony export */   atomic_load_i32: () => (/* binding */ atomic_load_i32),
/* harmony export */   atomic_load_i64: () => (/* binding */ atomic_load_i64),
/* harmony export */   atomic_load_i8: () => (/* binding */ atomic_load_i8),
/* harmony export */   atomic_or_i16: () => (/* binding */ atomic_or_i16),
/* harmony export */   atomic_or_i32: () => (/* binding */ atomic_or_i32),
/* harmony export */   atomic_or_i64: () => (/* binding */ atomic_or_i64),
/* harmony export */   atomic_or_i8: () => (/* binding */ atomic_or_i8),
/* harmony export */   atomic_store_i16: () => (/* binding */ atomic_store_i16),
/* harmony export */   atomic_store_i32: () => (/* binding */ atomic_store_i32),
/* harmony export */   atomic_store_i64: () => (/* binding */ atomic_store_i64),
/* harmony export */   atomic_store_i8: () => (/* binding */ atomic_store_i8),
/* harmony export */   atomic_sub_i16: () => (/* binding */ atomic_sub_i16),
/* harmony export */   atomic_sub_i32: () => (/* binding */ atomic_sub_i32),
/* harmony export */   atomic_sub_i64: () => (/* binding */ atomic_sub_i64),
/* harmony export */   atomic_sub_i8: () => (/* binding */ atomic_sub_i8),
/* harmony export */   atomic_xor_i16: () => (/* binding */ atomic_xor_i16),
/* harmony export */   atomic_xor_i32: () => (/* binding */ atomic_xor_i32),
/* harmony export */   atomic_xor_i64: () => (/* binding */ atomic_xor_i64),
/* harmony export */   atomic_xor_i8: () => (/* binding */ atomic_xor_i8),
/* harmony export */   atomics_notify: () => (/* binding */ atomics_notify),
/* harmony export */   atomics_wait: () => (/* binding */ atomics_wait),
/* harmony export */   atomics_wait_timeout: () => (/* binding */ atomics_wait_timeout),
/* harmony export */   override: () => (/* binding */ override)
/* harmony export */ });
/* harmony import */ var _thread_atomics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var _typedef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../typedef */ "./src/cheap/typedef.ts");
/* eslint-disable camelcase */


let atomic_add_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.add(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_sub_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_and_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.and(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_or_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.or(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_xor_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.xor(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_store_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_load_i8 = function (p) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(p, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_compare_exchange_i8 = function (p, expectedValue, replacementValue) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(p, expectedValue, replacementValue, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_exchange_i8 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.exchange(p, value, 12, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[12]);
};
let atomic_add_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.add(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_sub_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_and_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.and(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_or_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.or(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_xor_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.xor(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_store_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_load_i16 = function (p) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(p, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_compare_exchange_i16 = function (p, expectedValue, replacementValue) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(p, expectedValue, replacementValue, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_exchange_i16 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.exchange(p, value, 14, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[14]);
};
let atomic_add_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.add(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_sub_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_and_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.and(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_or_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.or(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_xor_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.xor(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_store_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_load_i32 = function (p) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(p, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_compare_exchange_i32 = function (p, expectedValue, replacementValue) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(p, expectedValue, replacementValue, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_exchange_i32 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.exchange(p, value, 16, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[16]);
};
let atomic_add_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.add(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_sub_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.sub(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_and_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.and(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_or_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.or(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_xor_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.xor(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_store_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.store(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_load_i64 = function (p) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.load(p, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_compare_exchange_i64 = function (p, expectedValue, replacementValue) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.compareExchange(p, expectedValue, replacementValue, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomic_exchange_i64 = function (p, value) {
    // @ts-ignore
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.exchange(p, value, 21, _typedef__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumPointerShiftMap[21]);
};
let atomics_notify = function (p, count) {
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.notify(p, count);
};
let atomics_wait = function (p, value) {
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.wait(p, value);
};
let atomics_wait_timeout = function (p, value, timeout) {
    return _thread_atomics__WEBPACK_IMPORTED_MODULE_0__.waitTimeout(p, value, (Number(timeout & 0xffffffffn) >> 0));
};
function override(data) {
    if (data.atomic_add_i8) {
        atomic_add_i8 = data.atomic_add_i8;
    }
    if (data.atomic_sub_i8) {
        atomic_sub_i8 = data.atomic_sub_i8;
    }
    if (data.atomic_and_i8) {
        atomic_and_i8 = data.atomic_and_i8;
    }
    if (data.atomic_or_i8) {
        atomic_or_i8 = data.atomic_or_i8;
    }
    if (data.atomic_xor_i8) {
        atomic_xor_i8 = data.atomic_xor_i8;
    }
    if (data.atomic_store_i8) {
        atomic_store_i8 = data.atomic_store_i8;
    }
    if (data.atomic_load_i8) {
        atomic_load_i8 = data.atomic_load_i8;
    }
    if (data.atomic_compare_exchange_i8) {
        atomic_compare_exchange_i8 = data.atomic_compare_exchange_i8;
    }
    if (data.atomic_exchange_i8) {
        atomic_exchange_i8 = data.atomic_exchange_i8;
    }
    if (data.atomic_add_i16) {
        atomic_add_i16 = data.atomic_add_i16;
    }
    if (data.atomic_sub_i16) {
        atomic_sub_i16 = data.atomic_sub_i16;
    }
    if (data.atomic_and_i16) {
        atomic_and_i16 = data.atomic_and_i16;
    }
    if (data.atomic_or_i16) {
        atomic_or_i16 = data.atomic_or_i16;
    }
    if (data.atomic_xor_i16) {
        atomic_xor_i16 = data.atomic_xor_i16;
    }
    if (data.atomic_store_i16) {
        atomic_store_i16 = data.atomic_store_i16;
    }
    if (data.atomic_load_i16) {
        atomic_load_i16 = data.atomic_load_i16;
    }
    if (data.atomic_compare_exchange_i16) {
        atomic_compare_exchange_i16 = data.atomic_compare_exchange_i16;
    }
    if (data.atomic_exchange_i16) {
        atomic_exchange_i16 = data.atomic_exchange_i16;
    }
    if (data.atomic_add_i32) {
        atomic_add_i32 = data.atomic_add_i32;
    }
    if (data.atomic_sub_i32) {
        atomic_sub_i32 = data.atomic_sub_i32;
    }
    if (data.atomic_and_i32) {
        atomic_and_i32 = data.atomic_and_i32;
    }
    if (data.atomic_or_i32) {
        atomic_or_i32 = data.atomic_or_i32;
    }
    if (data.atomic_xor_i32) {
        atomic_xor_i32 = data.atomic_xor_i32;
    }
    if (data.atomic_store_i32) {
        atomic_store_i32 = data.atomic_store_i32;
    }
    if (data.atomic_load_i32) {
        atomic_load_i32 = data.atomic_load_i32;
    }
    if (data.atomic_compare_exchange_i32) {
        atomic_compare_exchange_i32 = data.atomic_compare_exchange_i32;
    }
    if (data.atomic_exchange_i32) {
        atomic_exchange_i32 = data.atomic_exchange_i32;
    }
    if (data.atomic_add_i64) {
        atomic_add_i64 = data.atomic_add_i64;
    }
    if (data.atomic_sub_i64) {
        atomic_sub_i64 = data.atomic_sub_i64;
    }
    if (data.atomic_and_i64) {
        atomic_and_i64 = data.atomic_and_i64;
    }
    if (data.atomic_or_i64) {
        atomic_or_i64 = data.atomic_or_i64;
    }
    if (data.atomic_xor_i64) {
        atomic_xor_i64 = data.atomic_xor_i64;
    }
    if (data.atomic_store_i64) {
        atomic_store_i64 = data.atomic_store_i64;
    }
    if (data.atomic_load_i64) {
        atomic_load_i64 = data.atomic_load_i64;
    }
    if (data.atomic_compare_exchange_i64) {
        atomic_compare_exchange_i64 = data.atomic_compare_exchange_i64;
    }
    if (data.atomic_exchange_i64) {
        atomic_exchange_i64 = data.atomic_exchange_i64;
    }
    if (data.atomics_notify) {
        atomics_notify = data.atomics_notify;
    }
    if (data.atomics_wait) {
        atomics_wait = data.atomics_wait;
    }
    if (data.atomics_wait_timeout) {
        atomics_wait_timeout = data.atomics_wait_timeout;
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/clib.ts":
/*!***********************************************!*\
  !*** ./src/cheap/webassembly/runtime/clib.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abort: () => (/* binding */ abort),
/* harmony export */   clock_res_get: () => (/* binding */ clock_res_get),
/* harmony export */   clock_time_get: () => (/* binding */ clock_time_get),
/* harmony export */   fd_fdstat_get: () => (/* binding */ fd_fdstat_get),
/* harmony export */   fd_write: () => (/* binding */ fd_write),
/* harmony export */   random_get: () => (/* binding */ random_get)
/* harmony export */ });
/* unused harmony exports printChar, writeAsciiToMemory, fd_read, fd_seek, fd_close */
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _std_memory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../std/memory */ "./src/cheap/std/memory.ts");
/* harmony import */ var common_util_text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! common/util/text */ "./src/common/util/text.ts");


/* eslint-disable camelcase */


const buffers = [null, [], []];
const WASI_ERRNO_SUCCESS = 0;
const WASI_ERRNO_NOSYS = 52;
const WASI_ERRNO_INVAL = 28;
function printChar(stream, curr) {
    const buffer = buffers[stream];
    if (curr === 0 || curr === 10) {
        (stream === 1 ? console.log.bind(console) : console.log.bind(console))(common_util_text__WEBPACK_IMPORTED_MODULE_0__.decode(buffer));
        buffer.length = 0;
    }
    else {
        buffer.push(curr);
    }
}
function writeAsciiToMemory(str, buffer, doNotAddNull) {
    for (let i = 0; i < str.length; ++i) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[4](buffer, (((((str.charCodeAt(i)) >> 0) & 0xff) & 0x80) ? -(0x100 - (((str.charCodeAt(i)) >> 0) & 0xff)) : (((str.charCodeAt(i)) >> 0) & 0xff)));
        buffer = buffer + 1;
    }
    if (!doNotAddNull) {
        cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[4](buffer, (( false) ? 0 : (0 & 0xff)));
    }
}
function fd_fdstat_get(fd, pBuf) {
    let rightsBase = 0;
    if (fd == 0) {
        rightsBase = 2;
    }
    else if (fd == 1 || fd == 2) {
        rightsBase = 64;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[11](pBuf, (( false) ? 0 : (2 & 0xff)));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[13](pBuf + 2, (( false) ? 0 : (1 & 0xffff)));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](pBuf + 8, ((rightsBase) >> 0));
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[15](pBuf + 12, 0);
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[17](pBuf + 16, BigInt(0));
    return WASI_ERRNO_SUCCESS;
}
function fd_read(fd, iov, iovCnt, pNum) {
    return WASI_ERRNO_NOSYS;
}
function fd_seek(fd, offsetLow, offsetHigh, whence, newOffset) {
    return WASI_ERRNO_NOSYS;
}
function fd_write(fd, iov, iovCnt, pNum) {
    let num = 0;
    for (let i = 0; i < iovCnt; i++) {
        let ptr = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[8](iov);
        let len = cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[8](iov + 4);
        iov = iov + 8;
        for (let j = 0; j < len; j++) {
            printChar(fd, cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_2__.CTypeEnumRead[4](ptr + j));
        }
        num += len;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[8](pNum, (((num) >> 0) >>> 0));
    return WASI_ERRNO_SUCCESS;
}
function fd_close(fd) {
    return WASI_ERRNO_NOSYS;
}
function abort(what) {
    what += '';
    what = `abort(${what}). Build with -s ASSERTIONS=1 for more info.`;
    throw new WebAssembly.RuntimeError(what);
}
function clock_time_get(id, precision, timeOut) {
    if (id !== 0) {
        return WASI_ERRNO_INVAL;
    }
    const now = new Date().getTime();
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[10](timeOut, BigInt(now) * BigInt(1000000));
    return WASI_ERRNO_SUCCESS;
}
function clock_res_get(id, resOut) {
    if (id !== 0) {
        return WASI_ERRNO_INVAL;
    }
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_1__.CTypeEnumWrite[10](resOut, BigInt(1000000));
    return WASI_ERRNO_SUCCESS;
}
function random_get(pointer, size) {
    const buffer = (0,_std_memory__WEBPACK_IMPORTED_MODULE_3__.mapUint8Array)(pointer, size);
    {
        crypto.getRandomValues(buffer);
    }
    return WASI_ERRNO_SUCCESS;
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/pthread.ts":
/*!**************************************************!*\
  !*** ./src/cheap/webassembly/runtime/pthread.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Pthread: () => (/* binding */ Pthread),
/* harmony export */   PthreadOnce: () => (/* binding */ PthreadOnce),
/* harmony export */   override: () => (/* binding */ override),
/* harmony export */   wasm_cpu_core_count: () => (/* binding */ wasm_cpu_core_count),
/* harmony export */   wasm_pthread_cond_broadcast: () => (/* binding */ wasm_pthread_cond_broadcast),
/* harmony export */   wasm_pthread_cond_destroy: () => (/* binding */ wasm_pthread_cond_destroy),
/* harmony export */   wasm_pthread_cond_init: () => (/* binding */ wasm_pthread_cond_init),
/* harmony export */   wasm_pthread_cond_signal: () => (/* binding */ wasm_pthread_cond_signal),
/* harmony export */   wasm_pthread_cond_timedwait: () => (/* binding */ wasm_pthread_cond_timedwait),
/* harmony export */   wasm_pthread_cond_wait: () => (/* binding */ wasm_pthread_cond_wait),
/* harmony export */   wasm_pthread_equal2: () => (/* binding */ wasm_pthread_equal2),
/* harmony export */   wasm_pthread_exit: () => (/* binding */ wasm_pthread_exit),
/* harmony export */   wasm_pthread_mutex_destroy: () => (/* binding */ wasm_pthread_mutex_destroy),
/* harmony export */   wasm_pthread_mutex_init: () => (/* binding */ wasm_pthread_mutex_init),
/* harmony export */   wasm_pthread_mutex_lock: () => (/* binding */ wasm_pthread_mutex_lock),
/* harmony export */   wasm_pthread_mutex_unlock: () => (/* binding */ wasm_pthread_mutex_unlock),
/* harmony export */   wasm_pthread_once: () => (/* binding */ wasm_pthread_once),
/* harmony export */   wasm_pthread_support: () => (/* binding */ wasm_pthread_support)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! cheap/ctypeEnumWrite */ "./src/cheap/ctypeEnumWrite.ts");
/* harmony import */ var _thread_mutex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../thread/mutex */ "./src/cheap/thread/mutex.ts");
/* harmony import */ var _thread_cond__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../thread/cond */ "./src/cheap/thread/cond.ts");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../config */ "./src/cheap/config.ts");
/* harmony import */ var _heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../heap */ "./src/cheap/heap.ts");
/* harmony import */ var _thread_atomics__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../thread/atomics */ "./src/cheap/thread/atomics.ts");
/* harmony import */ var common_util_constant__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! common/util/constant */ "./src/common/util/constant.ts");




/* eslint-disable camelcase */






class PthreadOnce {
    atomic;
}
(function (prototype) {
    var map = new Map();
    map.set("atomic", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructKeysMeta, map);
})(PthreadOnce.prototype);
class Pthread {
    id;
    retval;
    flags;
    status;
}
(function (prototype) {
    var map = new Map();
    map.set("id", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("retval", { 0: 1, 1: 1, 2: 1, 3: 0, 4: 0, 5: 0, 6: 0, 7: 4, 8: 0 });
    map.set("flags", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    map.set("status", { 0: 16, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 12, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructMaxBaseTypeByteLength, 4);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructLength, 16);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_2__.symbolStructKeysMeta, map);
})(Pthread.prototype);
let wasm_pthread_mutex_init;
let wasm_pthread_mutex_destroy;
let wasm_pthread_mutex_lock;
let wasm_pthread_mutex_unlock;
let wasm_pthread_cond_init;
let wasm_pthread_cond_destroy;
let wasm_pthread_cond_wait;
let wasm_pthread_cond_timedwait;
let wasm_pthread_cond_signal;
let wasm_pthread_cond_broadcast;
let wasm_pthread_once;
function wasm_pthread_exit(retval) {
    const thread = common_util_constant__WEBPACK_IMPORTED_MODULE_3__.SELF.__SELF_THREAD__;
    cheap_ctypeEnumWrite__WEBPACK_IMPORTED_MODULE_4__.CTypeEnumWrite[20](thread + 4, retval);
}
function wasm_pthread_equal2(t1, t2) {
    return cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](t1) === cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](t2) ? 1 : 0;
}
function wasm_pthread_support() {
    return _config__WEBPACK_IMPORTED_MODULE_6__.USE_THREADS ? 1 : 0;
}
function wasm_cpu_core_count() {
    return navigator.hardwareConcurrency;
}
wasm_pthread_mutex_init = function (mutex, attr) {
    return _thread_mutex__WEBPACK_IMPORTED_MODULE_7__.init(mutex);
};
wasm_pthread_mutex_destroy = function (mutex) {
    return _thread_mutex__WEBPACK_IMPORTED_MODULE_7__.destroy(mutex);
};
wasm_pthread_mutex_lock = function (mutex) {
    return _thread_mutex__WEBPACK_IMPORTED_MODULE_7__.lock(mutex);
};
wasm_pthread_mutex_unlock = function (mutex) {
    return _thread_mutex__WEBPACK_IMPORTED_MODULE_7__.unlock(mutex);
};
wasm_pthread_cond_init = function (cond, attr) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_8__.init(cond, attr);
};
wasm_pthread_cond_destroy = function (cond) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_8__.destroy(cond);
};
wasm_pthread_cond_wait = function (cond, mutex) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_8__.wait(cond, mutex);
};
wasm_pthread_cond_timedwait = function (cond, mutex, abstime) {
    let timeout = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[17](abstime)) * 1000 + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_5__.CTypeEnumRead[15](abstime + 8) / 1000000;
    return _thread_cond__WEBPACK_IMPORTED_MODULE_8__.timedWait(cond, mutex, timeout);
};
wasm_pthread_cond_signal = function (cond) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_8__.signal(cond);
};
wasm_pthread_cond_broadcast = function (cond) {
    return _thread_cond__WEBPACK_IMPORTED_MODULE_8__.broadcast(cond);
};
wasm_pthread_once = function (control, func) {
    if (_thread_atomics__WEBPACK_IMPORTED_MODULE_9__.add(control, 1, 16, 2) === 0) {
        _heap__WEBPACK_IMPORTED_MODULE_0__.Table.get(func)();
    }
    return 0;
};
function override(data) {
    if (data.wasm_pthread_mutex_lock) {
        wasm_pthread_mutex_lock = data.wasm_pthread_mutex_lock;
    }
    if (data.wasm_pthread_mutex_unlock) {
        wasm_pthread_mutex_unlock = data.wasm_pthread_mutex_unlock;
    }
    if (data.wasm_pthread_cond_wait) {
        wasm_pthread_cond_wait = data.wasm_pthread_cond_wait;
    }
    if (data.wasm_pthread_cond_timedwait) {
        wasm_pthread_cond_timedwait = data.wasm_pthread_cond_timedwait;
    }
    if (data.wasm_pthread_cond_signal) {
        wasm_pthread_cond_signal = data.wasm_pthread_cond_signal;
    }
    if (data.wasm_pthread_cond_broadcast) {
        wasm_pthread_cond_broadcast = data.wasm_pthread_cond_broadcast;
    }
}


/***/ }),

/***/ "./src/cheap/webassembly/runtime/semaphore.ts":
/*!****************************************************!*\
  !*** ./src/cheap/webassembly/runtime/semaphore.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Timespec: () => (/* binding */ Timespec),
/* harmony export */   wasm_sem_destroy: () => (/* binding */ wasm_sem_destroy),
/* harmony export */   wasm_sem_init: () => (/* binding */ wasm_sem_init),
/* harmony export */   wasm_sem_post: () => (/* binding */ wasm_sem_post),
/* harmony export */   wasm_sem_timedwait: () => (/* binding */ wasm_sem_timedwait),
/* harmony export */   wasm_sem_trywait: () => (/* binding */ wasm_sem_trywait),
/* harmony export */   wasm_sem_wait: () => (/* binding */ wasm_sem_wait)
/* harmony export */ });
/* harmony import */ var cheap_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! cheap/symbol */ "./src/cheap/symbol.ts");
/* harmony import */ var cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/function/definedMetaProperty */ "./src/cheap/function/definedMetaProperty.ts");
/* harmony import */ var cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! cheap/ctypeEnumRead */ "./src/cheap/ctypeEnumRead.ts");
/* harmony import */ var _thread_semaphore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../thread/semaphore */ "./src/cheap/thread/semaphore.ts");



/* eslint-disable camelcase */

class Timespec {
    tvSec;
    tvNSec;
}
(function (prototype) {
    var map = new Map();
    map.set("tvSec", { 0: 17, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });
    map.set("tvNSec", { 0: 15, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 8, 8: 0 });
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStruct, true);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructMaxBaseTypeByteLength, 8);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructLength, 16);
    (0,cheap_function_definedMetaProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(prototype, cheap_symbol__WEBPACK_IMPORTED_MODULE_1__.symbolStructKeysMeta, map);
})(Timespec.prototype);
function wasm_sem_init(sem, pshared, value) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_2__.init(sem, value);
}
function wasm_sem_destroy(sem) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_2__.destroy(sem);
}
function wasm_sem_wait(sem) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_2__.wait(sem);
}
function wasm_sem_trywait(sem) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_2__.tryWait(sem);
}
function wasm_sem_timedwait(sem, abstime) {
    let timeout = Number(cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[17](abstime)) * 1000 + cheap_ctypeEnumRead__WEBPACK_IMPORTED_MODULE_3__.CTypeEnumRead[15](abstime + 8) / 1000000;
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_2__.timedWait(sem, timeout);
}
function wasm_sem_post(sem) {
    return _thread_semaphore__WEBPACK_IMPORTED_MODULE_2__.post(sem);
}


/***/ }),

/***/ "./src/common/event/CustomEvent.ts":
/*!*****************************************!*\
  !*** ./src/common/event/CustomEvent.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CustomEvent)
/* harmony export */ });
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * https://github.com/yoxjs/yox-common/blob/master/src/util/CustomEvent.ts
 * MIT License
 *
 * @file 事件
 */

class CustomEvent {
    static PHASE_CURRENT = 0;
    static PHASE_UPWARD = 1;
    static PHASE_DOWNWARD = _util_constant__WEBPACK_IMPORTED_MODULE_0__.MINUS_ONE;
    // 事件名称
    type;
    // 事件当前阶段
    phase;
    // 事件命名空间
    ns;
    // 哪个组件发出的事件
    target;
    // 原始事件，比如 DOM 事件
    originalEvent;
    // 是否已阻止事件的默认行为
    isPrevented;
    // 是否已停止事件冒泡
    isStopped;
    // 处理当前事件的监听器，方便外部获取 listener 进行解绑
    listener;
    /**
     * 构造函数
     *
     * 可以传事件名称，也可以传原生事件对象
     */
    constructor(type, originalEvent) {
        /*
         * 这里不设置命名空间
         * 因为有没有命名空间取决于 Emitter 的构造函数有没有传 true
         * CustomEvent 自己无法决定
         */
        this.type = type;
        this.phase = CustomEvent.PHASE_CURRENT;
        if (originalEvent) {
            this.originalEvent = originalEvent;
        }
    }
    /**
     * 阻止事件的默认行为
     */
    preventDefault() {
        const instance = this;
        if (!instance.isPrevented) {
            const { originalEvent } = instance;
            if (originalEvent) {
                originalEvent.preventDefault();
            }
            instance.isPrevented = _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE;
        }
        return instance;
    }
    /**
     * 停止事件广播
     */
    stopPropagation() {
        const instance = this;
        if (!instance.isStopped) {
            const { originalEvent } = instance;
            if (originalEvent) {
                originalEvent.stopPropagation();
            }
            instance.isStopped = _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE;
        }
        return instance;
    }
    prevent() {
        return this.preventDefault();
    }
    stop() {
        return this.stopPropagation();
    }
}


/***/ }),

/***/ "./src/common/event/Emitter.ts":
/*!*************************************!*\
  !*** ./src/common/event/Emitter.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Emitter)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _CustomEvent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CustomEvent */ "./src/common/event/CustomEvent.ts");
/* harmony import */ var _util_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/object */ "./src/common/util/object.ts");
/* harmony import */ var _util_string__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util/string */ "./src/common/util/string.ts");
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _function_execute__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../function/execute */ "./src/common/function/execute.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
var cheap__fileName__0 = "src/common/event/Emitter.ts";
/**
 * https://github.com/yoxjs/yox-common/blob/master/src/util/Emitter.ts
 * MIT License
 *
 * @file 事件代理
 */








class Emitter {
    /**
     * 是否开启命名空间
     */
    ns;
    /**
     * 已注册的事件监听
     */
    listeners;
    /**
     * 原生事件监听，一个事件对应一个 listener
     */
    nativeListeners;
    constructor(ns) {
        this.ns = ns || _util_constant__WEBPACK_IMPORTED_MODULE_0__.FALSE;
        this.listeners = {};
    }
    /**
     * 发射事件
     *
     * @param type 事件名称或命名空间
     * @param args 事件处理函数的参数列表
     * @param filter 自定义过滤器
     */
    fire(type, args, filter) {
        let instance = this, namespace = _util_is__WEBPACK_IMPORTED_MODULE_1__.string(type) ? instance.parse(type) : type, list = instance.listeners[namespace.type], isComplete = _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE;
        if (list) {
            // 避免遍历过程中，数组发生变化，比如增删了
            list = _util_object__WEBPACK_IMPORTED_MODULE_2__.copy(list);
            /*
             * 判断是否是发射事件
             * 如果 args 的第一个参数是 CustomEvent 类型，表示发射事件
             * 因为事件处理函数的参数列表是 (event, data)
             */
            const event = args && args[0] instanceof _CustomEvent__WEBPACK_IMPORTED_MODULE_3__["default"]
                ? args[0]
                : _util_constant__WEBPACK_IMPORTED_MODULE_0__.UNDEFINED;
            _util_array__WEBPACK_IMPORTED_MODULE_4__.each(list, function (options) {
                // 命名空间不匹配
                if (!matchNamespace(namespace.ns, options, _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE)
                    // 在 fire 过程中被移除了
                    || !_util_array__WEBPACK_IMPORTED_MODULE_4__.has(list, options)
                    // 传了 filter，则用 filter 判断是否过滤此 options
                    || (filter && !filter(namespace, args, options))) {
                    return;
                }
                /*
                 * 为 event 对象加上当前正在处理的 listener
                 * 这样方便业务层移除事件绑定
                 * 比如 on('xx', function) 这样定义了匿名 listener
                 * 在这个 listener 里面获取不到当前 listener 的引用
                 * 为了能引用到，有时候会先定义 var listener = function
                 * 然后再 on('xx', listener) 这样其实是没有必要的
                 */
                if (event) {
                    event.listener = options.fn;
                }
                let result = (0,_function_execute__WEBPACK_IMPORTED_MODULE_5__["default"])(options.fn, options.ctx, args);
                if (event) {
                    event.listener = _util_constant__WEBPACK_IMPORTED_MODULE_0__.UNDEFINED;
                }
                // 执行次数
                options.num = options.num ? (options.num + 1) : 1;
                // 注册的 listener 可以指定最大执行次数
                if (options.num === options.max) {
                    instance.off(namespace, options.fn);
                }
                // 如果没有返回 false，而是调用了 event.stop 也算是返回 false
                if (event) {
                    if (result === _util_constant__WEBPACK_IMPORTED_MODULE_0__.FALSE) {
                        event.prevent().stop();
                    }
                    else if (event.isStopped) {
                        result = _util_constant__WEBPACK_IMPORTED_MODULE_0__.FALSE;
                    }
                }
                if (result === _util_constant__WEBPACK_IMPORTED_MODULE_0__.FALSE) {
                    return isComplete = _util_constant__WEBPACK_IMPORTED_MODULE_0__.FALSE;
                }
            });
        }
        return isComplete;
    }
    /**
     * 注册监听
     *
     * @param type
     * @param listener
     */
    on(type, listener) {
        const instance = this, listeners = instance.listeners, options = _util_is__WEBPACK_IMPORTED_MODULE_1__.func(listener)
            ? { fn: listener }
            : listener;
        if (_util_is__WEBPACK_IMPORTED_MODULE_1__.object(options) && _util_is__WEBPACK_IMPORTED_MODULE_1__.func(options.fn)) {
            const namespace = _util_is__WEBPACK_IMPORTED_MODULE_1__.string(type) ? instance.parse(type) : type;
            options.ns = namespace.ns;
            _util_array__WEBPACK_IMPORTED_MODULE_4__.push(listeners[namespace.type] || (listeners[namespace.type] = []), options);
        }
        else if (true) {
            _util_logger__WEBPACK_IMPORTED_MODULE_6__.fatal('emitter.on(type, listener) invoke failed：\n\n"listener" is expected to be a Function or an EmitterOptions.\n', cheap__fileName__0, 196);
        }
        return this;
    }
    one(type, listener) {
        if (_util_is__WEBPACK_IMPORTED_MODULE_1__.func(listener)) {
            listener = {
                fn: listener,
                max: 1
            };
        }
        else {
            listener.max = 1;
        }
        return this.on(type, listener);
    }
    /**
     * 取消监听
     *
     * @param type
     * @param listener
     */
    off(type, listener) {
        const instance = this, listeners = instance.listeners;
        if (type) {
            const namespace = _util_is__WEBPACK_IMPORTED_MODULE_1__.string(type) ? instance.parse(type) : type, name = namespace.type, ns = namespace.ns, matchListener = createMatchListener(listener), each = function (list, name) {
                _util_array__WEBPACK_IMPORTED_MODULE_4__.each(list, function (options, index) {
                    if (matchListener(options)) {
                        list.splice(index, 1);
                    }
                }, _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE);
                if (!list.length) {
                    delete listeners[name];
                }
            }, eachNS = function (list, name) {
                _util_array__WEBPACK_IMPORTED_MODULE_4__.each(list, function (options, index) {
                    if (matchNamespace(ns, options)) {
                        list.splice(index, 1);
                    }
                }, _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE);
                if (!list.length) {
                    delete listeners[name];
                }
            };
            if (name) {
                if (listeners[name]) {
                    each(listeners[name], name);
                }
            }
            else if (ns) {
                _util_object__WEBPACK_IMPORTED_MODULE_2__.each(listeners, eachNS);
            }
            /*
             * 在开发阶段进行警告，比如传了 listener 进来，listener 是个空值
             * 但你不知道它是空值
             */
            if (true) {
                if (arguments.length > 1 && listener == _util_constant__WEBPACK_IMPORTED_MODULE_0__.NULL) {
                    _util_logger__WEBPACK_IMPORTED_MODULE_6__.warn(`emitter.off(type, listener) is invoked, but "listener" is ${listener}.`, cheap__fileName__0, 288);
                }
            }
        }
        else {
            // 清空
            instance.listeners = {};
            /*
             * 在开发阶段进行警告，比如传了 type 进来，type 是个空值
             * 但你不知道它是空值
             */
            if (true) {
                if (arguments.length > 0) {
                    _util_logger__WEBPACK_IMPORTED_MODULE_6__.warn(`emitter.off(type) is invoked, but "type" is ${type}.`, cheap__fileName__0, 302);
                }
            }
        }
    }
    /**
     * 是否已监听某个事件
     *
     * @param type
     * @param listener
     */
    has(type, listener) {
        let instance = this, listeners = instance.listeners, namespace = _util_is__WEBPACK_IMPORTED_MODULE_1__.string(type) ? instance.parse(type) : type, name = namespace.type, ns = namespace.ns, result = _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE, matchListener = createMatchListener(listener), each = function (list) {
            _util_array__WEBPACK_IMPORTED_MODULE_4__.each(list, function (options) {
                if (matchListener(options)) {
                    return result = _util_constant__WEBPACK_IMPORTED_MODULE_0__.FALSE;
                }
            });
            return result;
        }, eachNS = function (list) {
            _util_array__WEBPACK_IMPORTED_MODULE_4__.each(list, function (options) {
                if (matchNamespace(ns, options)) {
                    return result = _util_constant__WEBPACK_IMPORTED_MODULE_0__.FALSE;
                }
            });
            return result;
        };
        if (name) {
            if (listeners[name]) {
                each(listeners[name]);
            }
        }
        else if (ns) {
            _util_object__WEBPACK_IMPORTED_MODULE_2__.each(listeners, eachNS);
        }
        return !result;
    }
    /**
     * 把事件类型解析成命名空间格式
     *
     * @param type
     */
    parse(type) {
        /*
         * 这里 ns 必须为字符串
         * 用于区分 event 对象是否已完成命名空间的解析
         */
        const result = {
            type,
            ns: _util_constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_STRING,
        };
        // 是否开启命名空间
        if (this.ns) {
            const index = _util_string__WEBPACK_IMPORTED_MODULE_7__.indexOf(type, _util_constant__WEBPACK_IMPORTED_MODULE_0__.RAW_DOT);
            if (index >= 0) {
                result.type = _util_string__WEBPACK_IMPORTED_MODULE_7__.slice(type, 0, index);
                result.ns = _util_string__WEBPACK_IMPORTED_MODULE_7__.slice(type, index + 1);
            }
        }
        return result;
    }
}
function matchTrue() {
    return _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE;
}
/**
 * 外部会传入 Function 或 EmitterOptions 或 空
 *
 * 这里根据传入值的不同类型，创建不同的判断函数
 *
 * 如果传入的是 EmitterOptions，则全等判断
 *
 * 如果传入的是 Function，则判断函数是否全等
 *
 * 如果传入的是空，则直接返回 true
 *
 * @param listener
 */
function createMatchListener(listener) {
    return _util_is__WEBPACK_IMPORTED_MODULE_1__.func(listener)
        ? function (options) {
            return listener === options.fn;
        }
        : matchTrue;
}
/**
 * 判断 options 是否能匹配命名空间
 *
 * 如果 namespace 和 options.ns 都不为空，则需完全匹配
 *
 * 如果他们两个其中任何一个为空，则不判断命名空间
 *
 * @param namespace
 * @param options
 */
function matchNamespace(namespace, options, isFire) {
    const { ns } = options;
    return ns && namespace
        ? ns === namespace
        : (isFire ? _util_constant__WEBPACK_IMPORTED_MODULE_0__.TRUE : _util_constant__WEBPACK_IMPORTED_MODULE_0__.FALSE);
}


/***/ }),

/***/ "./src/common/function/checkVersion.ts":
/*!*********************************************!*\
  !*** ./src/common/function/checkVersion.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ checkVersion)
/* harmony export */ });
/* harmony import */ var _toNumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toNumber */ "./src/common/function/toNumber.ts");
/**
 * @file 判断版本
 */

/**
 * 判断给定版本是否符合条件
 *
 * @param version 待检查版本
 * @param checkVersion 版本基准
 * @param equal 是否判等
 *
 * @returns 是否符合条件
 */
function checkVersion(version, checkVersion, equal = false) {
    const checkVersionArr = checkVersion.split('.');
    const versionArr = version.split('.');
    for (let i = 0; i < versionArr.length; i++) {
        if (equal && i == (versionArr.length - 1) && (0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(versionArr[i]) >= (0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(checkVersionArr[i])) {
            return versionArr.length >= checkVersionArr.length;
        }
        if ((0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(versionArr[i]) > (0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(checkVersionArr[i])) {
            return true;
        }
        else if ((0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(versionArr[i]) < (0,_toNumber__WEBPACK_IMPORTED_MODULE_0__["default"])(checkVersionArr[i])) {
            return false;
        }
        if (i === checkVersionArr.length - 1 && i === versionArr.length - 1) {
            return equal;
        }
        if (i === checkVersionArr.length - 1) {
            return true;
        }
        else if (i === versionArr.length - 1) {
            return false;
        }
    }
    return true;
}


/***/ }),

/***/ "./src/common/function/concatTypeArray.ts":
/*!************************************************!*\
  !*** ./src/common/function/concatTypeArray.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ concatTypeArray)
/* harmony export */ });
/**
 * @file 合并 TypeArray
 */
function concatTypeArray(constructor, arrays) {
    if (!arrays.length) {
        return null;
    }
    if (arrays.length === 1) {
        return arrays[0];
    }
    let totalLength = 0;
    let array;
    for (array of arrays) {
        totalLength += array.length;
    }
    let result = new constructor(totalLength);
    let offset = 0;
    for (array of arrays) {
        result.set(array, offset);
        offset += array.length;
    }
    return result;
}


/***/ }),

/***/ "./src/common/function/debounce.ts":
/*!*****************************************!*\
  !*** ./src/common/function/debounce.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ debounce)
/* harmony export */ });
/* harmony import */ var _execute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./execute */ "./src/common/function/execute.ts");
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 防抖函数
 */



/**
 * 防抖函数
 *
 * @param fn 需要节制调用的函数
 * @param delay 调用的时间间隔，单位毫秒
 * @param immediate 是否立即触发
 * @return 节流函数
 */
function debounce(fn, delay, immediate) {
    let timer;
    return function () {
        let context = this;
        if (!timer) {
            const args = _util_array__WEBPACK_IMPORTED_MODULE_0__.toArray(arguments);
            if (immediate) {
                (0,_execute__WEBPACK_IMPORTED_MODULE_1__["default"])(fn, context, args);
            }
            timer = setTimeout(function () {
                timer = _util_constant__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED;
                if (!immediate) {
                    (0,_execute__WEBPACK_IMPORTED_MODULE_1__["default"])(fn, context, args);
                }
            }, delay);
        }
    };
}


/***/ }),

/***/ "./src/common/function/execute.ts":
/*!****************************************!*\
  !*** ./src/common/function/execute.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ execute)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 使用指定上下文执行函数
 */


/**
 * 任性地执行一个函数，不管它有没有、是不是
 *
 * @param fn 调用的函数
 * @param context 执行函数时的 this 指向
 * @param args 调用函数的参数，多参数时传入数组
 * @return 调用函数的返回值
 */
function execute(fn, context, args) {
    if (_util_is__WEBPACK_IMPORTED_MODULE_0__.func(fn)) {
        return _util_is__WEBPACK_IMPORTED_MODULE_0__.array(args)
            ? fn.apply(context, args)
            : context !== _util_constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED
                ? fn.call(context, args)
                : args !== _util_constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED
                    ? fn(args)
                    : fn();
    }
}


/***/ }),

/***/ "./src/common/function/generateUUID.ts":
/*!*********************************************!*\
  !*** ./src/common/function/generateUUID.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ generateUUID)
/* harmony export */ });
/**
 * 生成唯一 id
 *
 * @internal
 * @returns id
 */
function generateUUID() {
    let d = new Date().getTime();
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        let r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        return (c == 'x' ? r : (r & 0x3 | 0x8)).toString(16);
    });
}


/***/ }),

/***/ "./src/common/function/getTimestamp.ts":
/*!*********************************************!*\
  !*** ./src/common/function/getTimestamp.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getTimestamp)
/* harmony export */ });
function getTimestamp() {
    return Date.now();
}


/***/ }),

/***/ "./src/common/function/isAudioWorklet.ts":
/*!***********************************************!*\
  !*** ./src/common/function/isAudioWorklet.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isAudioWorklet)
/* harmony export */ });
function isAudioWorklet() {
    // @ts-ignore
    return typeof registerProcessor === 'function' && typeof sampleRate === 'number' && typeof currentFrame === 'number' && typeof currentTime === 'number';
}


/***/ }),

/***/ "./src/common/function/isDef.ts":
/*!**************************************!*\
  !*** ./src/common/function/isDef.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isDef)
/* harmony export */ });
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 判断是否定义
 */

/**
 * 判断是否定义
 *
 * @param target 待判定变量
 */
function isDef(target) {
    return target !== _util_constant__WEBPACK_IMPORTED_MODULE_0__.UNDEFINED;
}


/***/ }),

/***/ "./src/common/function/isLittleEndian.ts":
/*!***********************************************!*\
  !*** ./src/common/function/isLittleEndian.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isLittleEndian)
/* harmony export */ });
/* harmony import */ var _isDef__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isDef */ "./src/common/function/isDef.ts");

let _isLittleEndian;
function isLittleEndian() {
    if ((0,_isDef__WEBPACK_IMPORTED_MODULE_0__["default"])(_isLittleEndian)) {
        return _isLittleEndian;
    }
    const buf = new ArrayBuffer(2);
    const view = new DataView(buf);
    // little-endian write
    view.setInt16(0, 256, true);
    // platform-spec read, if equal then LE
    _isLittleEndian = (new Int16Array(buf))[0] === 256;
    return _isLittleEndian;
}


/***/ }),

/***/ "./src/common/function/isNative.ts":
/*!*****************************************!*\
  !*** ./src/common/function/isNative.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isNative)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _toString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./toString */ "./src/common/function/toString.ts");
/* harmony import */ var _util_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/string */ "./src/common/util/string.ts");
/**
 * @file 判断是否是 native 方法
 */



/**
 * 判断是否是 native 方法
 *
 * @param target 待判定函数
 */
function isNative(target) {
    return _util_is__WEBPACK_IMPORTED_MODULE_0__.func(target) && _util_string__WEBPACK_IMPORTED_MODULE_1__.has((0,_toString__WEBPACK_IMPORTED_MODULE_2__["default"])(target), '[native code]');
}


/***/ }),

/***/ "./src/common/function/isWorker.ts":
/*!*****************************************!*\
  !*** ./src/common/function/isWorker.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isWorker)
/* harmony export */ });
/* harmony import */ var _isDef__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isDef */ "./src/common/function/isDef.ts");
/* harmony import */ var _isAudioWorklet__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isAudioWorklet */ "./src/common/function/isAudioWorklet.ts");


function isWorker() {
    return !(typeof window === 'object' && (0,_isDef__WEBPACK_IMPORTED_MODULE_0__["default"])(window.document)) && !(0,_isAudioWorklet__WEBPACK_IMPORTED_MODULE_1__["default"])();
}


/***/ }),

/***/ "./src/common/function/nextTick.ts":
/*!*****************************************!*\
  !*** ./src/common/function/nextTick.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _isNative__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isNative */ "./src/common/function/isNative.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 下一个时间片
 */


let nextTick;
// IE (10+) 和 node
if (typeof setImmediate === _util_constant__WEBPACK_IMPORTED_MODULE_0__.RAW_FUNCTION && (0,_isNative__WEBPACK_IMPORTED_MODULE_1__["default"])(setImmediate)) {
    nextTick = setImmediate;
}
/*
 * 用 MessageChannel 去做 setImmediate 的 polyfill
 * 原理是将新的 message 事件加入到原有的 dom events 之后
 * 兼容性 IE10+ 和其他标准浏览器
 */
if (typeof MessageChannel === _util_constant__WEBPACK_IMPORTED_MODULE_0__.RAW_FUNCTION && (0,_isNative__WEBPACK_IMPORTED_MODULE_1__["default"])(MessageChannel)) {
    nextTick = function (fn) {
        const channel = new MessageChannel();
        channel.port1.onmessage = fn;
        channel.port2.postMessage(1);
    };
}
else if (typeof setTimeout === 'function') {
    nextTick = setTimeout;
}
// 没有 setTimeout 是环境，比如 WorkletGlobalScope，先固定一个插槽
else {
    nextTick = function (fn) {
        setTimeout(fn);
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (nextTick);


/***/ }),

/***/ "./src/common/function/sourceLoad.ts":
/*!*******************************************!*\
  !*** ./src/common/function/sourceLoad.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * 将某个文件的代码变成字符串（Webpack 使用）
 */
const webpackBootstrapFunc = `
function webpackBootstrapFunc (modules) {
  var installedModules = {};
  function __webpack_require__(moduleId) {
    if(installedModules[moduleId])
    return installedModules[moduleId].exports;
    var module = installedModules[moduleId] = {
      i: moduleId,
      l: false,
      exports: {}
    };
    if (!modules[moduleId]) {
      console.log('can not found module:', moduleId)
    }
    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    module.l = true;
    return module.exports;
  }
  __webpack_require__.m = modules;
  __webpack_require__.c = installedModules;
  __webpack_require__.i = function(value) { return value; };
  __webpack_require__.d = function(exports, definition, getter) {
    if (typeof definition === 'string') {
      if(!__webpack_require__.o(exports, definition)) {
        Object.defineProperty(exports, definition, {
          enumerable: true,
          get: getter
        });
      }
    }
    else {
      for(var key in definition) {
        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
          Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
          });
        }
      }
    }
  };
  __webpack_require__.r = function(exports) {
    if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
    	Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
    }
    Object.defineProperty(exports, '__esModule', { value: true });
  };
  __webpack_require__.f = {};
  __webpack_require__.e = function(chunkId) {
    return Promise.all(Object.keys(__webpack_require__.f).reduce(function (promises, key) {
      __webpack_require__.f[key](chunkId, promises);
        return promises;
    	}, []));
	};
  __webpack_require__.u = function(chunkId) {
    return chunkId + "LIB_NAME";
  };
  __webpack_require__.n = function(module) {
    var getter = module && module.__esModule ?
      function getDefault() { return module['default']; } :
      function getModuleExports() { return module; };
    __webpack_require__.d(getter, 'a', getter);
    return getter;
  };
  (function() {
    var installedChunks = {
      "main": 0
    };
    __webpack_require__.f.j = function(chunkId, promises) {
      var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
      if (installedChunkData !== 0) {
        if(installedChunkData) {
          promises.push(installedChunkData[2]);
        } else {
          if (true) {
            var promise = new Promise(function(resolve, reject){installedChunkData = installedChunks[chunkId] = [resolve, reject]});
            promises.push(installedChunkData[2] = promise);
            var url = __webpack_require__.p + __webpack_require__.u(chunkId);
            var error = new Error();
            var loadingEnded = function(event) {
              if(__webpack_require__.o(installedChunks, chunkId)) {
                installedChunkData = installedChunks[chunkId];
                if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
                if(installedChunkData) {
                  var errorType = event && (event.type === 'load' ? 'missing' : event.type);
                  var realSrc = url;
                  error.message = "Loading chunk " + chunkId + " failed.\\n(" + errorType + ": " + realSrc + ")";
                  error.name = "ChunkLoadError";
                  error.type = errorType;
                  error.request = realSrc;
                  installedChunkData[1](error);
                }
              }
            };
            __webpack_require__.l(url, loadingEnded);
          }
        }
      }
    };
    var webpackJsonpCallback = function(parentChunkLoadingFunction, data) {
    var [chunkIds, moreModules, runtime] = data;
    var moduleId, chunkId, i = 0;
    if (chunkIds.some(function(id){return installedChunks[id] !== 0})) {
      for(moduleId in moreModules) {
        if(__webpack_require__.o(moreModules, moduleId)) {
          __webpack_require__.m[moduleId] = moreModules[moduleId];
        }
      }
      if(runtime) runtime(__webpack_require__);
    }
    if (parentChunkLoadingFunction) parentChunkLoadingFunction(data);
      for (;i < chunkIds.length; i++) {
        chunkId = chunkIds[i];
        if (__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
          installedChunks[chunkId][0]();
        }
        installedChunks[chunkId] = 0;
      }
    }
    var self = typeof globalThis !== undefined ? globalThis : self
    var exportName = 'LIBRARY_EXPORT_NAME'
    var chunkLoadingGlobal = self["webpackChunk" + exportName] = self["webpackChunk" + exportName] || [];
    chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
    chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
  })();
  (function() {
    var inProgress = {};
    __webpack_require__.l = function(url, done) {
      if (inProgress[url]) { inProgress[url].push(done); return; }
        inProgress[url] = [done];
        var onComplete = function(event) {
          clearTimeout(timeout);
          var doneFns = inProgress[url];
          delete inProgress[url];
          doneFns && doneFns.forEach(function(fn){fn(event)});
        }
        var timeout = setTimeout(onComplete.bind(null, undefined, { type: "timeout" }), 120000);
      import(url).then(function() {
        onComplete({
          type: "load"
        })
      }, function (error) {
        onComplete({
          type: "missing"
        })
      });
    };
  })();
  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
  __webpack_require__.p = "ROOT_URL";
  __webpack_require__.oe = function(err) { console.error(err); throw err; };
  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE);
  return f;
}
`;
const moduleNameReqExp = '[\\.|\\-|\\+|\\w|\/|@|!]+';
// additional chars when output.path info is true
const dependencyRegExp = '\\(\\s*(\/\\*.*?\\*\/)?\\s*.*?(' + moduleNameReqExp + ').*?\\)';
// http://stackoverflow.com/a/2593661/130442
function quoteRegExp(str) {
    return (str + '').replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
}
function isNumeric(n) {
    // 1 * n converts integers, integers as string ("123"), 1e3 and "1e3" to integers and strings to NaN
    return !isNaN(n);
}
function getModuleDependencies(sources, module, queueName, requiredModules) {
    const retval = {};
    retval[queueName] = [];
    let fnString = module.toString();
    const wrapperSignature = fnString.match(/^(function)?\s?\w*\(\w+,\s*(\w+),\s*(\w+)\)/);
    if (!wrapperSignature) {
        return retval;
    }
    const webpackRequireName = wrapperSignature[3];
    if (!requiredModules.__webpack_exports_process__) {
        requiredModules.__webpack_require__ = webpackRequireName;
        requiredModules.__webpack_exports__ = wrapperSignature[2];
        requiredModules.__webpack_exports_process__ = true;
    }
    // main bundle deps
    let re = new RegExp('(\\\\n|\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g');
    let match;
    while ((match = re.exec(fnString))) {
        if (match[3] === 'dll-reference') {
            continue;
        }
        retval[queueName].push(match[3]);
    }
    // dll deps
    re = new RegExp('\\(' + quoteRegExp(webpackRequireName) + '\\("(dll-reference\\s(' + moduleNameReqExp + '))"\\)\\)' + dependencyRegExp, 'g');
    while ((match = re.exec(fnString))) {
        if (!sources[match[2]]) {
            retval[queueName].push(match[1]);
            // @ts-ignore
            sources[match[2]] = __webpack_require__(match[1]).m;
        }
        retval[match[2]] = retval[match[2]] || [];
        retval[match[2]].push(match[4]);
    }
    // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3
    const keys = Object.keys(retval);
    for (let i = 0; i < keys.length; i++) {
        for (let j = 0; j < retval[keys[i]].length; j++) {
            if (isNumeric(+retval[keys[i]][j])) {
                retval[keys[i]][j] = +retval[keys[i]][j];
            }
        }
    }
    return retval;
}
function hasValuesInQueues(queues) {
    const keys = Object.keys(queues);
    return keys.reduce(function (hasValues, key) {
        return hasValues || queues[key].length > 0;
    }, false);
}
function getRequiredModules(sources, moduleId) {
    const modulesQueue = {
        main: [moduleId]
    };
    const requiredModules = {
        main: [],
        __webpack_exports__: '__webpack_exports__',
        __webpack_require__: '__webpack_require__',
        __webpack_exports_process__: false
    };
    const seenModules = {
        main: {}
    };
    while (hasValuesInQueues(modulesQueue)) {
        const queues = Object.keys(modulesQueue);
        for (let i = 0; i < queues.length; i++) {
            let queueName = queues[i];
            let queue = modulesQueue[queueName];
            let moduleToCheck = queue.pop();
            seenModules[queueName] = seenModules[queueName] || {};
            if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) {
                continue;
            }
            seenModules[queueName][moduleToCheck] = true;
            requiredModules[queueName] = requiredModules[queueName] || [];
            requiredModules[queueName].push(moduleToCheck);
            let newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName, requiredModules);
            let newModulesKeys = Object.keys(newModules);
            for (let j = 0; j < newModulesKeys.length; j++) {
                modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || [];
                modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]]);
            }
        }
    }
    return requiredModules;
}
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(moduleId, options) {
    const sources = {
        // @ts-ignore
        main: __webpack_require__.m
    };
    const requiredModules = getRequiredModules(sources, moduleId);
    let src = '';
    let stringifyModuleId = JSON.stringify(moduleId);
    return src + 'var ' + options.varName + '=(' + webpackBootstrapFunc.replace('ENTRY_MODULE', stringifyModuleId)
        // @ts-ignore
        .replace('ROOT_URL', __webpack_require__.p || '')
        // @ts-ignore
        .replace('LIBRARY_EXPORT_NAME', 'AVTranscoder')
        // @ts-ignore
        .replace('LIB_NAME', __webpack_require__.u && __webpack_require__.u('') || '')
        + ')({' + requiredModules.main.map(function (id) {
        const stringifyId = JSON.stringify(id);
        let source = '' + stringifyId + ': ' + sources.main[id].toString();
        if (stringifyId === stringifyModuleId && options.exportName && options.pointName) {
            const line = `;${requiredModules.__webpack_require__}.d(
          ${requiredModules.__webpack_exports__},
          "${options.exportName}",
          function() {
            if (${options.exportIsClass}) {
              for (var key in ${requiredModules.__webpack_exports__}) {
                if (key === '${options.exportName}') {
                  continue;
                }
                var v = ${requiredModules.__webpack_exports__}[key];
                if (typeof v === 'function' && v.name === '${options.pointName}') {
                  return v;
                }
              }
            }
            return ${options.pointName};
          }
        );`;
            source = source.slice(0, source.length - 1) + line + '}';
        }
        return source;
    }).join(',') + '});';
}


/***/ }),

/***/ "./src/common/function/split.ts":
/*!**************************************!*\
  !*** ./src/common/function/split.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ split)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/**
 * @file 拆解字符串，并 trim 每个部分
 */


/**
 * 拆解字符串，并 trim 每个部分
 *
 * @param str 字符串
 * @param sep 分隔符
 */
function split(str, sep) {
    const result = [];
    if (_util_is__WEBPACK_IMPORTED_MODULE_0__.number(str)) {
        str = str + '';
    }
    if (str && _util_is__WEBPACK_IMPORTED_MODULE_0__.string(str)) {
        _util_array__WEBPACK_IMPORTED_MODULE_1__.each(str.split(sep), (part, index) => {
            part = part.trim();
            if (part) {
                result.push(part);
            }
        });
    }
    return result;
}


/***/ }),

/***/ "./src/common/function/toNumber.ts":
/*!*****************************************!*\
  !*** ./src/common/function/toNumber.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toNumber)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 强转为 number
 */


/**
 * 强转为 number
 *
 * @param target 待转换值
 * @param defaultValue 默认值
 *
 * @returns 转换之后的值
 */
function toNumber(target, defaultValue) {
    return _util_is__WEBPACK_IMPORTED_MODULE_0__.numeric(target)
        ? +target
        : defaultValue !== _util_constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED
            ? defaultValue
            : 0;
}


/***/ }),

/***/ "./src/common/function/toString.ts":
/*!*****************************************!*\
  !*** ./src/common/function/toString.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toString)
/* harmony export */ });
/* harmony import */ var _util_constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/constant */ "./src/common/util/constant.ts");
/**
 * @file 强转为 string
 */

/**
 * 强转为 string
 *
 * @param target 待转换的值
 * @param defaultValue 默认值
 * @returns 转换之后的值
 */
function toString(target, defaultValue) {
    return target != _util_constant__WEBPACK_IMPORTED_MODULE_0__.NULL && target.toString
        ? target.toString()
        : defaultValue !== _util_constant__WEBPACK_IMPORTED_MODULE_0__.UNDEFINED
            ? defaultValue
            : _util_constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_STRING;
}


/***/ }),

/***/ "./src/common/helper/CommandQueue.ts":
/*!*******************************************!*\
  !*** ./src/common/helper/CommandQueue.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CommandQueue)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/**
 * 顺序执行异步任务，用于有顺序依赖的信令交互
 */


class CommandQueue {
    queue;
    constructor() {
        this.queue = [];
    }
    async execute(command) {
        try {
            const result = await command.task();
            command.resolve(result);
        }
        catch (error) {
            command.reject(error);
        }
    }
    async next() {
        if (this.queue.length) {
            const command = this.queue[0];
            if (command.error) {
                command.reject(command.error);
            }
            else {
                await this.execute(command);
            }
            this.queue.shift();
            if (this.queue.length) {
                this.next();
            }
        }
    }
    async push(task) {
        if (!_util_is__WEBPACK_IMPORTED_MODULE_0__.func(task)) {
            throw new TypeError('task must be a function');
        }
        return new Promise((resolve, reject) => {
            const command = {
                task,
                resolve,
                reject
            };
            this.queue.push(command);
            if (this.queue.length === 1) {
                this.next();
            }
        });
    }
    clear(error) {
        _util_array__WEBPACK_IMPORTED_MODULE_1__.each(this.queue, (command) => {
            command.error = error || new Error('command queue clear');
        });
    }
    get length() {
        return this.queue.length;
    }
}


/***/ }),

/***/ "./src/common/interface/ArrayLike.ts":
/*!*******************************************!*\
  !*** ./src/common/interface/ArrayLike.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ArrayLike)
/* harmony export */ });
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");

class ArrayLike {
    proxy;
    constructor() {
        this.proxy = new Proxy(this, {
            get(target, p, receiver) {
                if (_util_is__WEBPACK_IMPORTED_MODULE_0__.numeric(p)) {
                    return target.getIndexValue(+p);
                }
                else {
                    return target[p];
                }
            },
            set(target, p, newValue, receiver) {
                if (_util_is__WEBPACK_IMPORTED_MODULE_0__.numeric(p)) {
                    target.setIndexValue(+p, newValue);
                }
                else {
                    target[p] = newValue;
                }
                return true;
            }
        });
    }
}


/***/ }),

/***/ "./src/common/io/BitReader.ts":
/*!************************************!*\
  !*** ./src/common/io/BitReader.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BitReader)
/* harmony export */ });
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/common/io/BitReader.ts";

class BitReader {
    buffer;
    pointer;
    bitsLeft;
    size;
    endPointer;
    error;
    onFlush;
    /**
     * @param data 待读取的字节
     * @param bigEndian 是否按大端字节序读取，默认大端字节序（网络字节序）
     */
    constructor(size = 1048576) {
        this.pointer = 0;
        this.bitsLeft = 8;
        this.size = size;
        this.endPointer = 0;
        this.error = 0;
        this.buffer = new Uint8Array(this.size);
    }
    /**
     * 不影响原读取操作的情况下，读取 1 个比特
     */
    peekU1() {
        let result = 0;
        if (this.remainingLength() < 1 || this.remainingLength() === 1 && this.bitsLeft === 0) {
            this.flush();
        }
        let pointer = this.pointer;
        let bitsLeft = this.bitsLeft;
        if (bitsLeft === 0) {
            pointer++;
            bitsLeft = 8;
        }
        result = (this.buffer[pointer] >> (bitsLeft - 1)) & 0x01;
        return result;
    }
    /**
     * 读取 1 个比特
     */
    readU1() {
        let result = 0;
        if (this.remainingLength() < 1 || this.remainingLength() === 1 && this.bitsLeft === 0) {
            this.flush();
        }
        this.bitsLeft--;
        result = (this.buffer[this.pointer] >> this.bitsLeft) & 0x01;
        if (this.bitsLeft === 0) {
            this.pointer++;
            this.bitsLeft = 8;
        }
        return result;
    }
    /**
     * 读取 n 个比特
     *
     * @param n
     */
    readU(n) {
        let result = 0;
        for (let i = 0; i < n; i++) {
            result |= (this.readU1() << (n - i - 1));
        }
        return result;
    }
    /**
     * 获取剩余可读字节数
     *
     * @returns
     */
    remainingLength() {
        return this.endPointer - this.pointer;
    }
    getPos() {
        return this.pointer;
    }
    skip(n) {
        const byte = (n - (n % 8)) / 8;
        this.pointer += byte;
        const bitsLeft = n % 8;
        if (this.bitsLeft <= bitsLeft) {
            this.pointer++;
            this.bitsLeft = 8 - (bitsLeft - this.bitsLeft);
        }
        else {
            this.bitsLeft -= bitsLeft;
        }
    }
    flush() {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOReader error, flush failed because of no flush callback');
        }
        if (this.bitsLeft === 0) {
            this.pointer++;
        }
        if (this.size - this.remainingLength() <= 0) {
            return;
        }
        if (this.pointer < this.endPointer) {
            this.buffer.set(this.buffer.subarray(this.pointer, this.endPointer), 0);
            const len = this.onFlush(this.buffer.subarray(this.endPointer - this.pointer, this.size));
            if (len < 0) {
                this.error = len;
                throw Error('IOReader error, flush failed');
            }
            this.endPointer = this.endPointer - this.pointer + len;
            this.pointer = 0;
        }
        else {
            const len = this.onFlush(this.buffer);
            this.endPointer = len;
            this.pointer = 0;
            this.bitsLeft = 8;
            if (len < 0) {
                this.error = len;
                throw Error('IOReader error, flush failed');
            }
        }
    }
    getBuffer() {
        return this.buffer;
    }
    appendBuffer(buffer) {
        if (this.size - this.endPointer >= buffer.length) {
            this.buffer.set(buffer, this.endPointer);
            this.endPointer += buffer.length;
        }
        else {
            this.buffer.set(this.buffer.subarray(this.pointer, this.endPointer), 0);
            this.endPointer = this.endPointer - this.pointer;
            this.pointer = 0;
            if (this.size - this.endPointer >= buffer.length) {
                this.buffer.set(buffer, this.endPointer);
                this.endPointer += buffer.length;
            }
            else {
                const len = Math.min(this.size - this.endPointer, buffer.length);
                this.buffer.set(buffer.subarray(0, len), this.endPointer);
                this.endPointer += len;
                _util_logger__WEBPACK_IMPORTED_MODULE_0__.warn('BSReader, call appendBuffer but the buffer\'s size is lagger then the remaining size', cheap__fileName__0, 190);
            }
        }
    }
    clear() {
        this.pointer = this.endPointer = 0;
        this.bitsLeft = 8;
        this.error = 0;
    }
    skipPadding() {
        if (this.bitsLeft < 8) {
            this.bitsLeft = 8;
            this.pointer++;
        }
    }
}


/***/ }),

/***/ "./src/common/io/BitWriter.ts":
/*!************************************!*\
  !*** ./src/common/io/BitWriter.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BitWriter)
/* harmony export */ });
/**
 * bit 写存器
 */
/**
 * 写字节流工具
 */
class BitWriter {
    buffer;
    pointer;
    bitPointer;
    size;
    error;
    onFlush;
    /**
     * @param data 待写的 Uint8Array
     */
    constructor(size = 1048576) {
        this.pointer = 0;
        this.bitPointer = 0;
        this.size = size;
        this.error = 0;
        this.buffer = new Uint8Array(this.size);
    }
    /**
     * 写一个 bit
     *
     * @param bit
     */
    writeU1(bit) {
        if (this.remainingLength() < 1 || this.remainingLength() === 1 && this.bitPointer >= 8) {
            this.flush();
        }
        if (bit & 0x01) {
            this.buffer[this.pointer] |= (1 << (7 - this.bitPointer));
        }
        else {
            this.buffer[this.pointer] &= ~(1 << (7 - this.bitPointer));
        }
        this.bitPointer++;
        if (this.bitPointer === 8) {
            this.pointer++;
            this.bitPointer = 0;
        }
    }
    /**
     * 写 n 个比特
     *
     * @param n
     */
    writeU(n, v) {
        for (let i = 0; i < n; i++) {
            this.writeU1(v >> (n - i - 1) & 0x01);
        }
    }
    /**
     * 获取剩余可写节数
     *
     * @returns
     */
    remainingLength() {
        return this.size - this.pointer;
    }
    flush() {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('BSWriter error, flush failed because of no flush callback');
        }
        if (this.pointer) {
            if (this.bitPointer && this.pointer > 1) {
                const ret = this.onFlush(this.buffer.subarray(0, this.pointer - 1));
                if (ret !== 0) {
                    this.error = ret;
                    throw Error('BSWriter error, flush failed');
                }
                this.buffer[0] = this.buffer[this.pointer];
            }
            else if (this.bitPointer === 0) {
                const ret = this.onFlush(this.buffer.subarray(0, this.pointer));
                if (ret !== 0) {
                    this.error = ret;
                    throw Error('BSWriter error, flush failed');
                }
            }
        }
        this.pointer = 0;
    }
    padding() {
        while (this.bitPointer !== 0) {
            this.writeU1(0);
        }
    }
    clear() {
        this.pointer = 0;
        this.bitPointer = 0;
        this.error = 0;
    }
    getBuffer() {
        return this.buffer;
    }
    getPointer() {
        return this.pointer;
    }
}


/***/ }),

/***/ "./src/common/io/BufferReader.ts":
/*!***************************************!*\
  !*** ./src/common/io/BufferReader.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BufferReader)
/* harmony export */ });
/* harmony import */ var _function_concatTypeArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/concatTypeArray */ "./src/common/function/concatTypeArray.ts");
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
/**
 * 读字节流工具
 */


class BufferReader {
    data;
    buffer;
    byteStart;
    pos;
    size;
    littleEndian;
    /**
     * @param data 待读取的字节
     * @param bigEndian 是否按大端字节序读取，默认大端字节序（网络字节序）
     */
    constructor(data, bigEndian = true) {
        this.buffer = data;
        this.data = data instanceof Uint8Array ? new DataView(data.buffer) : data.view;
        this.byteStart = data instanceof Uint8Array ? data.byteOffset : 0;
        this.pos = 0;
        this.size = data.byteLength;
        this.littleEndian = !bigEndian;
    }
    /**
     * 读取 8 位无符号整数
     *
     * @returns
     */
    readUint8() {
        return this.data.getUint8(this.pos++ + this.byteStart);
    }
    /**
     * 读取 16 位无符号整数
     *
     * @returns
     */
    readUint16() {
        const value = this.data.getUint16(this.pos + this.byteStart, this.littleEndian);
        this.pos += 2;
        return value;
    }
    /**
     * 读取 24 位无符号整数
     *
     * @returns
     */
    readUint24() {
        const high = this.readUint16();
        const low = this.readUint8();
        return high << 8 | low;
    }
    /**
     * 读取 32 位无符号整数
     *
     * @returns
     */
    readUint32() {
        const value = this.data.getUint32(this.pos + this.byteStart, this.littleEndian);
        this.pos += 4;
        return value;
    }
    /**
     * 读取 64 位无符号整数
     *
     * @returns
     */
    readUint64() {
        const high = BigInt(this.readUint32());
        const low = BigInt(this.readUint32());
        if (this.littleEndian) {
            return low << BigInt(32) | high;
        }
        else {
            return high << BigInt(32) | low;
        }
    }
    /**
     * 读取 8 位有符号整数
     *
     * @returns
     */
    readInt8() {
        return this.data.getInt8(this.pos++ + this.byteStart);
    }
    /**
     * 读取 16 位有符号整数
     *
     * @returns
     */
    readInt16() {
        const value = this.data.getInt16(this.pos + this.byteStart, this.littleEndian);
        this.pos += 2;
        return value;
    }
    /**
     * 读取 32 位有符号整数
     *
     * @returns
     */
    readInt32() {
        const value = this.data.getInt32(this.pos + this.byteStart, this.littleEndian);
        this.pos += 4;
        return value;
    }
    /**
     * 读取 64 位有符号整数
     *
     * @returns
     */
    readInt64() {
        const high = BigInt(this.readInt32());
        const low = BigInt(this.readInt32());
        if (this.littleEndian) {
            return low << BigInt(32) | high;
        }
        else {
            return high << BigInt(32) | low;
        }
    }
    /**
     * 读取单精度浮点数
     *
     * @returns
     */
    readFloat() {
        const value = this.data.getFloat32(this.pos + this.byteStart, this.littleEndian);
        this.pos += 4;
        return value;
    }
    /**
     * 读取双精度浮点数
     *
     * @returns
     */
    readDouble() {
        const value = this.data.getFloat64(this.pos + this.byteStart, this.littleEndian);
        this.pos += 8;
        return value;
    }
    /**
     * 读取指定长度的字节，并以 16 进制字符串返回
     *
     * @param length 默认 1
     * @returns
     */
    readHex(length = 1) {
        let hexStr = '';
        for (let i = 0; i < length; i++) {
            const hex = this.readUint8().toString(16);
            hexStr += (hex.length === 1 ? '0' + hex : hex);
        }
        return hexStr;
    }
    /**
     * 读取指定长度的字符串
     *
     * @param length 默认 1
     * @returns
     */
    readString(length = 1) {
        let str = '';
        if (length) {
            let start = this.pos;
            for (let i = 0; i < length; i++) {
                if (this.buffer[this.pos + i] === 0) {
                    start++;
                }
                else {
                    break;
                }
            }
            str = _util_text__WEBPACK_IMPORTED_MODULE_0__.decode(this.buffer.subarray(start, start + length));
        }
        this.pos += length;
        return str;
    }
    /**
     * 读取一行字符
     */
    readLine() {
        let str = '';
        for (let i = this.pos; i < this.size; i++) {
            if (this.buffer[i] === 0x0a || this.buffer[i] === 0x0d) {
                str += this.readString(i - this.pos);
                break;
            }
        }
        for (let i = this.pos; i < this.size; i++) {
            if (this.buffer[i] === 0x0a || this.buffer[i] === 0x0d) {
                this.readUint8();
            }
            else {
                break;
            }
        }
        return str;
    }
    /**
     * 获取当前读取指针
     *
     * @returns
     */
    getPos() {
        return BigInt(this.pos);
    }
    /**
     * seek 读取指针
     *
     * @param pos
     */
    seek(pos) {
        if (pos > this.size) {
            pos = this.size;
        }
        this.pos = Math.max(0, pos);
    }
    /**
     * 跳过指定字节长度
     *
     * @param length
     */
    skip(length) {
        this.seek(this.pos + length);
    }
    /**
     * 返回指定字节长度
     *
     * @param length
     */
    back(length) {
        this.seek(this.pos - length);
    }
    /**
     * 获取剩余可读字节数
     *
     * @returns
     */
    remainingSize() {
        return this.size - this.pos;
    }
    /**
     * 读取指定长度的二进制 buffer 数据
     *
     * @param length
     * @returns
     */
    readBuffer(length) {
        length = Math.min(length, this.remainingSize());
        const buffer = this.buffer.slice(this.pos, this.pos + length);
        this.pos += length;
        return buffer;
    }
    /**
     * 追加 buffer
     *
     * @param buffer
     */
    appendBuffer(buffer) {
        this.buffer = (0,_function_concatTypeArray__WEBPACK_IMPORTED_MODULE_1__["default"])(Uint8Array, [
            this.buffer.slice(),
            buffer.slice()
        ]);
        this.data = new DataView(this.buffer.buffer);
        this.size += buffer.byteLength;
        this.byteStart = 0;
    }
    resetBuffer(data, bigEndian = true) {
        this.buffer = data;
        this.data = data instanceof Uint8Array ? new DataView(data.buffer) : data.view;
        this.byteStart = data instanceof Uint8Array ? data.byteOffset : 0;
        this.pos = 0;
        this.size = data.byteLength;
        this.littleEndian = !bigEndian;
    }
}


/***/ }),

/***/ "./src/common/io/BufferWriter.ts":
/*!***************************************!*\
  !*** ./src/common/io/BufferWriter.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BufferWriter)
/* harmony export */ });
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
var cheap__fileName__0 = "src/common/io/BufferWriter.ts";
/**
 * 写字节流工具
 */


class BufferWriter {
    data;
    buffer;
    byteStart;
    pos;
    size;
    littleEndian;
    /**
     * @param data 待写的 Uint8Array
     * @param bigEndian 是否按大端字节序写，默认大端字节序（网络字节序）
     */
    constructor(data, bigEndian = true) {
        this.buffer = data;
        this.data = data instanceof Uint8Array ? new DataView(data.buffer) : data.view;
        this.byteStart = data instanceof Uint8Array ? data.byteOffset : 0;
        this.pos = 0;
        this.size = data.byteLength;
        this.littleEndian = !bigEndian;
    }
    /**
     * 写 8 位无符号整数
     */
    writeUint8(value) {
        this.data.setUint8(this.pos++ + this.byteStart, value);
    }
    /**
     * 读取 16 位无符号整数
     */
    writeUint16(value) {
        this.data.setUint16(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 2;
    }
    /**
     * 写 24 位无符号整数
     */
    writeUint24(value) {
        const high = value & 0xf00;
        const middle = value & 0x0f0;
        const low = value & 0x00f;
        if (this.littleEndian) {
            this.writeUint8(low);
            this.writeUint8(middle);
            this.writeUint8(high);
        }
        else {
            this.writeUint8(high);
            this.writeUint8(middle);
            this.writeUint8(low);
        }
    }
    /**
     * 写 32 位无符号整数
     */
    writeUint32(value) {
        this.data.setUint32(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 4;
    }
    /**
     * 写 64 位无符号整数
     */
    writeUint64(value) {
        const low = value & BigInt(0xffffffff);
        const high = (value & (BigInt(0xffffffff) << BigInt(32))) >> BigInt(32);
        if (this.littleEndian) {
            this.writeUint32(Number(low));
            this.writeUint32(Number(high));
        }
        else {
            this.writeUint32(Number(high));
            this.writeUint32(Number(low));
        }
    }
    /**
     * 写 8 位有符号整数
     *
     * @returns
     */
    writeInt8(value) {
        this.data.setInt8(this.pos++ + this.byteStart, value);
    }
    /**
     * 写 16 位有符号整数
     */
    writeInt16(value) {
        this.data.setInt16(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 2;
    }
    /**
     * 写 32 位有符号整数
     */
    writeInt32(value) {
        this.data.setInt32(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 4;
    }
    /**
     * 写 64 位有符号整数
     */
    writeInt64(value) {
        const low = value & BigInt(0xffffffff);
        const high = (value & (BigInt(0xffffffff) << BigInt(32))) >> BigInt(32);
        if (this.littleEndian) {
            this.writeInt32(Number(low));
            this.writeInt32(Number(high));
        }
        else {
            this.writeInt32(Number(high));
            this.writeInt32(Number(low));
        }
    }
    /**
     * 写单精度浮点数
     *
     * @returns
     */
    writeFloat(value) {
        this.data.setFloat32(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 4;
    }
    /**
     * 写双精度浮点数
     */
    writeDouble(value) {
        this.data.setFloat64(this.pos + this.byteStart, value, this.littleEndian);
        this.pos += 8;
    }
    /**
     * 获取当前写指针
     *
     * @returns
     */
    getPos() {
        return this.pos;
    }
    /**
     * seek 写指针
     *
     * @param pos
     */
    seek(pos) {
        if (pos > this.size) {
            pos = this.size;
        }
        this.pos = Math.max(0, pos);
    }
    /**
     * 跳过指定字节长度
     *
     * @param length
     */
    skip(length) {
        this.seek(this.pos + length);
    }
    /**
     * 返回指定字节长度
     *
     * @param length
     */
    back(length) {
        this.seek(this.pos - length);
    }
    /**
     * 获取剩余可写节数
     *
     * @returns
     */
    remainingSize() {
        return this.size - this.pos;
    }
    /**
     * 写指定长度的二进制 buffer 数据
     *
     * @param length
     * @returns
     */
    writeBuffer(buffer) {
        let length = buffer.length;
        if (this.remainingSize() < length) {
            length = this.remainingSize();
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.warn(`the remaining buffer size is smaller then the wrote buffer, hope set ${buffer.length}, but set ${length}`, cheap__fileName__0, 211);
        }
        this.buffer.set(buffer, this.pos);
        this.pos += buffer.length;
    }
    /**
     * 写一个字符串
     */
    writeString(str) {
        const buffer = _util_text__WEBPACK_IMPORTED_MODULE_1__.encode(str);
        this.writeBuffer(buffer);
        return buffer.length;
    }
    getWroteBuffer() {
        return this.buffer.subarray(0, this.pos);
    }
    resetBuffer(data, bigEndian = true) {
        this.buffer = data;
        this.data = data instanceof Uint8Array ? new DataView(data.buffer) : data.view;
        this.byteStart = data instanceof Uint8Array ? data.byteOffset : 0;
        this.pos = 0;
        this.size = data.byteLength;
        this.littleEndian = !bigEndian;
    }
}


/***/ }),

/***/ "./src/common/io/FileIO.ts":
/*!*********************************!*\
  !*** ./src/common/io/FileIO.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FileIO)
/* harmony export */ });
const RESIZE_CHUNK_SIZE = 5242880;
class FileIO {
    handler;
    file;
    pos;
    writer;
    append;
    reader;
    size;
    blobSlice;
    readied;
    readHold;
    constructor(handler, append = false) {
        this.handler = handler;
        this.append = append;
        this.readied = false;
    }
    async ready() {
        if (this.readied) {
            return;
        }
        this.file = await this.handler.getFile();
        this.writer = await this.handler.createWritable();
        this.pos = this.append ? this.file.size : 0;
        this.size = this.pos;
        this.reader = new FileReader();
        this.blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;
        this.reader.onloadend = (event) => {
            if (this.readHold) {
                this.readHold.resolve(event.target.result);
                this.readHold = null;
            }
        };
        this.readied = true;
    }
    async write_(data) {
        await this.writer.write(data);
        this.pos += data.byteLength;
        if (this.pos > this.size) {
            this.size += data.byteLength;
        }
    }
    async write(data) {
        await this.write_(data);
    }
    async seek_(position) {
        await this.writer.seek(position);
        this.pos = position;
    }
    async seek(position) {
        await this.seek_(position);
    }
    async seekToEnd() {
        await this.seek_(this.size);
    }
    async resize_(size) {
        if (size !== this.file.size) {
            if (size < this.file.size) {
                this.pos = this.file.size;
            }
            await this.writer.truncate(size);
            this.size = size;
        }
    }
    async resize(size) {
        await this.resize_(size);
    }
    async read_(start, end) {
        return new Promise((resolve, reject) => {
            this.readHold = {
                resolve,
                reject
            };
            this.reader.readAsArrayBuffer(this.blobSlice.call(this.file, start, end));
        });
    }
    async read(start, end) {
        return await this.read_(start, end);
    }
    async appendBufferByPosition(buffer, position) {
        await this.writer.close();
        this.file = await this.handler.getFile();
        this.writer = await this.handler.createWritable({
            keepExistingData: true
        });
        const size = this.file.size;
        const length = buffer.byteLength;
        if (position >= this.file.size) {
            await this.resize_(position + length);
            await this.seek_(position);
            await this.write_(buffer);
        }
        else {
            let start = position;
            await this.seek_(position);
            await this.write_(buffer);
            while (start < size) {
                const buffer = await this.read_(start, Math.min(start + RESIZE_CHUNK_SIZE, size));
                await this.write_(buffer);
                start += buffer.byteLength;
            }
        }
    }
    async close_() {
        if (!this.readied) {
            return;
        }
        await this.writer.close();
        this.file = await this.handler.getFile();
        this.readied = false;
    }
    async close() {
        await this.close_();
    }
    getFile() {
        return this.file;
    }
    getHandle() {
        return this.handler;
    }
    getPos() {
        return this.pos;
    }
    getSize() {
        return this.size;
    }
    async destroy() {
        await this.close_();
        this.handler = null;
        this.file = null;
    }
}


/***/ }),

/***/ "./src/common/io/IOReader.ts":
/*!***********************************!*\
  !*** ./src/common/io/IOReader.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOReader)
/* harmony export */ });
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
/* harmony import */ var _timer_Sleep__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../timer/Sleep */ "./src/common/timer/Sleep.ts");
var cheap__fileName__0 = "src/common/io/IOReader.ts";



class IOReader {
    data;
    buffer;
    pointer;
    endPointer;
    pos;
    size;
    littleEndian;
    fileSize_;
    error;
    onFlush;
    onSeek;
    onSize;
    flags;
    /**
     * @param data 待读取的字节
     * @param bigEndian 是否按大端字节序读取，默认大端字节序（网络字节序）
     */
    constructor(size = 1048576, bigEndian = true, map) {
        this.pos = BigInt(0);
        this.pointer = 0;
        this.error = 0;
        this.endPointer = 0;
        this.littleEndian = !bigEndian;
        this.flags = 0;
        if (map && map.view) {
            this.size = map.length;
            this.buffer = map;
            this.data = map.view;
        }
        else if (map && !map.byteOffset) {
            this.size = map.length;
            this.buffer = map;
            this.data = new DataView(this.buffer.buffer);
        }
        else {
            if (map) {
                throw new Error('not support subarray of ArrayBuffer');
            }
            this.size = Math.max(size, 102400);
            this.buffer = new Uint8Array(this.size);
            this.data = new DataView(this.buffer.buffer);
        }
    }
    /**
     * 读取 8 位无符号整数
     *
     * @returns
     */
    async readUint8() {
        if (this.remainingLength() < 1) {
            await this.flush(1);
        }
        const value = this.data.getUint8(this.pointer);
        this.pointer++;
        this.pos++;
        return value;
    }
    async peekUint8() {
        if (this.remainingLength() < 1) {
            await this.flush(1);
        }
        return this.data.getUint8(this.pointer);
    }
    /**
     * 读取 16 位无符号整数
     *
     * @returns
     */
    async readUint16() {
        if (this.remainingLength() < 2) {
            await this.flush(2);
        }
        const value = this.data.getUint16(this.pointer, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
        return value;
    }
    async peekUint16() {
        if (this.remainingLength() < 2) {
            await this.flush(2);
        }
        return this.data.getUint16(this.pointer, this.littleEndian);
    }
    /**
     * 读取 24 位无符号整数
     *
     * @returns
     */
    async readUint24() {
        if (this.remainingLength() < 3) {
            await this.flush(3);
        }
        const high = await this.readUint16();
        const low = await this.readUint8();
        return high << 8 | low;
    }
    async peekUint24() {
        if (this.remainingLength() < 3) {
            await this.flush(3);
        }
        const pointer = this.pointer;
        const pos = this.pos;
        const high = await this.readUint16();
        const low = await this.readUint8();
        const value = high << 8 | low;
        this.pointer = pointer;
        this.pos = pos;
        return value;
    }
    /**
     * 读取 32 位无符号整数
     *
     * @returns
     */
    async readUint32() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        const value = this.data.getUint32(this.pointer, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
        return value;
    }
    async peekUint32() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        return this.data.getUint32(this.pointer, this.littleEndian);
    }
    /**
     * 读取 64 位无符号整数
     *
     * @returns
     */
    async readUint64() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        const value = this.data.getBigUint64(this.pointer, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
        return value;
    }
    async peekUint64() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        return this.data.getBigUint64(this.pointer, this.littleEndian);
    }
    /**
     * 读取 8 位有符号整数
     *
     * @returns
     */
    async readInt8() {
        if (this.remainingLength() < 1) {
            await this.flush(1);
        }
        const value = this.data.getInt8(this.pointer);
        this.pointer++;
        this.pos++;
        return value;
    }
    async peekInt8() {
        if (this.remainingLength() < 1) {
            await this.flush(1);
        }
        return this.data.getInt8(this.pointer);
    }
    /**
     * 读取 16 位有符号整数
     *
     * @returns
     */
    async readInt16() {
        if (this.remainingLength() < 2) {
            await this.flush(2);
        }
        const value = this.data.getInt16(this.pointer, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
        return value;
    }
    async peekInt16() {
        if (this.remainingLength() < 2) {
            await this.flush(2);
        }
        return this.data.getInt16(this.pointer, this.littleEndian);
    }
    /**
     * 读取 32 位有符号整数
     *
     * @returns
     */
    async readInt32() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        const value = this.data.getInt32(this.pointer, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
        return value;
    }
    async peekInt32() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        return this.data.getInt32(this.pointer, this.littleEndian);
    }
    /**
     * 读取 64 位有符号整数
     *
     * @returns
     */
    async readInt64() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        const value = this.data.getBigInt64(this.pointer, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
        return value;
    }
    async peekInt64() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        return this.data.getBigInt64(this.pointer, this.littleEndian);
    }
    /**
     * 读取单精度浮点数
     *
     * @returns
     */
    async readFloat() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        const value = this.data.getFloat32(this.pointer, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
        return value;
    }
    async peekFloat() {
        if (this.remainingLength() < 4) {
            await this.flush(4);
        }
        return this.data.getFloat32(this.pointer, this.littleEndian);
    }
    /**
     * 读取双精度浮点数
     *
     * @returns
     */
    async readDouble() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        const value = this.data.getFloat64(this.pointer, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
        return value;
    }
    async peekDouble() {
        if (this.remainingLength() < 8) {
            await this.flush(8);
        }
        return this.data.getFloat64(this.pointer, this.littleEndian);
    }
    /**
     * 读取指定长度的字节，并以 16 进制字符串返回
     *
     * @param length 默认 1
     * @returns
     */
    async readHex(length = 1) {
        let hexStr = '';
        for (let i = 0; i < length; i++) {
            const hex = (await this.readUint8()).toString(16);
            hexStr += (hex.length === 1 ? '0' + hex : hex);
        }
        return hexStr;
    }
    async peekHex(length = 1) {
        if (length > this.size) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('peekHex, length too large', cheap__fileName__0, 334);
        }
        if (this.remainingLength() < length) {
            await this.flush(length);
        }
        const pointer = this.pointer;
        const pos = this.pos;
        let hexStr = '';
        for (let i = 0; i < length; i++) {
            const hex = (await this.readUint8()).toString(16);
            hexStr += (hex.length === 1 ? '0' + hex : hex);
        }
        this.pointer = pointer;
        this.pos = pos;
        return hexStr;
    }
    async readBuffer(length, buffer) {
        if (!buffer) {
            buffer = new Uint8Array(length);
        }
        if (this.remainingLength() < length) {
            let index = 0;
            if (this.remainingLength() > 0) {
                const len = this.remainingLength();
                buffer.set(this.buffer.subarray(this.pointer, this.pointer + len), index);
                index += len;
                this.pointer += len;
                this.pos += BigInt(len);
                length -= len;
            }
            while (length > 0) {
                await this.flush();
                const len = Math.min(this.endPointer - this.pointer, length);
                buffer.set(this.buffer.subarray(this.pointer, this.pointer + len), index);
                index += len;
                this.pointer += len;
                this.pos += BigInt(len);
                length -= len;
            }
        }
        else {
            buffer.set(this.buffer.subarray(this.pointer, this.pointer + length), 0);
            this.pointer += length;
            this.pos += BigInt(length);
        }
        return buffer;
    }
    async readToBuffer(length, buffer) {
        if (this.remainingLength() < length) {
            let index = 0;
            if (this.remainingLength() > 0) {
                const len = this.remainingLength();
                buffer.set(this.buffer.subarray(this.pointer, this.pointer + len), index);
                index += len;
                this.pointer += len;
                this.pos += BigInt(len);
                length -= len;
            }
            while (length > 0) {
                try {
                    await this.flush();
                }
                catch (error) {
                    if (this.error === -1048576 /* IOError.END */ && index) {
                        return index;
                    }
                    else {
                        throw error;
                    }
                }
                const len = Math.min(this.endPointer - this.pointer, length);
                buffer.set(this.buffer.subarray(this.pointer, this.pointer + len), index);
                index += len;
                this.pointer += len;
                this.pos += BigInt(len);
                length -= len;
            }
            return index;
        }
        else {
            buffer.set(this.buffer.subarray(this.pointer, this.pointer + length), 0);
            this.pointer += length;
            this.pos += BigInt(length);
            return length;
        }
    }
    async peekBuffer(length, buffer) {
        if (length > this.size) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('peekBuffer, length too large', cheap__fileName__0, 455);
        }
        if (this.remainingLength() < length) {
            await this.flush(length);
        }
        if (!buffer) {
            buffer = new Uint8Array(length);
        }
        buffer.set(this.buffer.subarray(this.pointer, this.pointer + length), 0);
        return buffer;
    }
    /**
     * 读取指定长度的字符串
     *
     * @param length 默认 1
     * @returns
     */
    async readString(length = 1) {
        const buffer = await this.readBuffer(length);
        return _util_text__WEBPACK_IMPORTED_MODULE_1__.decode(buffer);
    }
    async peekString(length = 1) {
        const buffer = await this.peekBuffer(length);
        return _util_text__WEBPACK_IMPORTED_MODULE_1__.decode(buffer);
    }
    /**
     * 读取一行字符
     */
    async readLine() {
        let str = '';
        while (true) {
            let got = false;
            for (let i = this.pointer; i < this.endPointer; i++) {
                if (this.buffer[i] === 0x0a || this.buffer[i] === 0x0d) {
                    if (i !== this.pointer) {
                        str += await this.readString(i - this.pointer);
                    }
                    got = true;
                    break;
                }
            }
            if (!got) {
                str += await this.readString(this.remainingLength());
                await this.flush();
            }
            else {
                break;
            }
        }
        while (true) {
            const next = await this.peekUint8();
            if (next === 0x0a || next === 0x0d) {
                await this.readUint8();
            }
            else {
                break;
            }
        }
        return str;
    }
    async peekLine() {
        if (this.remainingLength() < this.size) {
            await this.flush();
        }
        let str = '';
        let got = false;
        for (let i = this.pointer; i < this.endPointer; i++) {
            if (this.buffer[i] === 0x0a || this.buffer[i] === 0x0d) {
                str += await this.peekString(i - this.pointer);
                got = true;
                break;
            }
        }
        if (!got) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('peekLine, out of buffer', cheap__fileName__0, 543);
        }
        return str;
    }
    /**
     * 获取当前读取指针
     *
     * @returns
     */
    getPointer() {
        return this.pointer;
    }
    /**
     * 获取已读字节偏移
     *
     * @returns
     */
    getPos() {
        return this.pos;
    }
    /**
     * 跳过指定字节长度
     *
     * @param length
     */
    async skip(length) {
        const backup = length;
        while (this.remainingLength() < length) {
            length -= this.remainingLength();
            this.pointer = this.endPointer;
            await this.flush();
        }
        if (this.remainingLength() >= length) {
            this.pointer += length;
        }
        this.pos += BigInt(backup);
    }
    /**
     * 获取剩余可读字节数
     *
     * @returns
     */
    remainingLength() {
        return this.endPointer - this.pointer;
    }
    async flush_(buffer) {
        while (true) {
            const len = await this.onFlush(buffer);
            if (len !== -1048575 /* IOError.AGAIN */) {
                return len;
            }
            await new _timer_Sleep__WEBPACK_IMPORTED_MODULE_2__["default"](0);
        }
    }
    async flush(need = 0) {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('IOReader error, flush failed because of no flush callback', cheap__fileName__0, 611);
        }
        if (this.size - this.remainingLength() <= 0) {
            return;
        }
        need = Math.min(need, this.size);
        if (this.pointer < this.endPointer) {
            this.buffer.set(this.buffer.subarray(this.pointer, this.endPointer), 0);
            this.endPointer = this.endPointer - this.pointer;
        }
        else {
            this.endPointer = 0;
        }
        this.pointer = 0;
        if (need) {
            while (this.remainingLength() < need) {
                const len = await this.flush_(this.buffer.subarray(this.endPointer));
                if (len < 0) {
                    this.error = len;
                    throw new Error(`IOReader error, flush ${len === -1048576 /* IOError.END */ ? 'ended' : 'failed'}, ret: ${len}`);
                }
                this.endPointer += len;
            }
        }
        else {
            const len = await this.flush_(this.buffer.subarray(this.endPointer));
            if (len < 0) {
                this.error = len;
                throw new Error(`IOReader error, flush ${len === -1048576 /* IOError.END */ ? 'ended' : 'failed'}, ret: ${len}`);
            }
            this.endPointer += len;
        }
    }
    async seek(pos, force = false, flush = true) {
        if (!force) {
            const len = Number(pos - this.pos);
            // 可以往回 seek
            if (len < 0 && Math.abs(len) < this.pointer) {
                this.pointer += len;
                this.pos = pos;
                return;
            }
            // 可以直接往后 seek
            else if (len > 0 && this.pointer + len < this.endPointer) {
                this.pointer += len;
                this.pos = pos;
                return;
            }
            else if (len === 0) {
                return;
            }
        }
        if (!this.onSeek) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('IOReader error, seek failed because of no seek callback', cheap__fileName__0, 672);
        }
        this.pointer = this.endPointer = 0;
        this.pos = pos;
        const ret = await this.onSeek(pos);
        if (ret !== 0) {
            this.error = ret;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('IOReader error, seek failed', cheap__fileName__0, 681);
        }
        if (flush) {
            await this.flush();
        }
    }
    getBuffer() {
        return this.buffer;
    }
    appendBuffer(buffer) {
        if (this.size - this.endPointer >= buffer.length) {
            this.buffer.set(buffer, this.endPointer);
            this.endPointer += buffer.length;
        }
        else {
            this.buffer.set(this.buffer.subarray(this.pointer, this.endPointer), 0);
            this.endPointer = this.endPointer - this.pointer;
            this.pointer = 0;
            if (this.size - this.endPointer >= buffer.length) {
                this.buffer.set(buffer, this.endPointer);
                this.endPointer += buffer.length;
            }
            else {
                const len = Math.min(this.size - this.endPointer, buffer.length);
                this.buffer.set(buffer.subarray(0, len), this.endPointer);
                this.endPointer += len;
                _util_logger__WEBPACK_IMPORTED_MODULE_0__.warn('IOReader, call appendBuffer but the buffer\'s size is lagger then the remaining size', cheap__fileName__0, 711);
            }
        }
    }
    reset() {
        this.pointer = this.endPointer = 0;
        this.pos = BigInt(0);
        this.error = 0;
    }
    setEndian(bigEndian) {
        this.littleEndian = !bigEndian;
    }
    async fileSize() {
        if (this.fileSize_) {
            return this.fileSize_;
        }
        if (!this.onSize) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            _util_logger__WEBPACK_IMPORTED_MODULE_0__.fatal('IOReader error, fileSize failed because of no onSize callback', cheap__fileName__0, 732);
        }
        this.fileSize_ = await this.onSize();
        return this.fileSize_;
    }
    getBufferSize() {
        return this.size;
    }
    async pipe(ioWriter, length) {
        if (length) {
            if (this.remainingLength() < length) {
                if (this.remainingLength() > 0) {
                    const len = this.remainingLength();
                    await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + len));
                    this.pointer += len;
                    this.pos += BigInt(len);
                    length -= len;
                }
                while (length > 0) {
                    await this.flush();
                    const len = Math.min(this.remainingLength(), length);
                    await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + len));
                    this.pointer += len;
                    this.pos += BigInt(len);
                    length -= len;
                }
            }
            else {
                await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + length));
                this.pointer += length;
                this.pos += BigInt(length);
            }
        }
        else {
            if (this.remainingLength() > 0) {
                const len = this.remainingLength();
                await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + len));
                this.pointer += len;
                this.pos += BigInt(len);
            }
            while (await this.flush_(this.buffer.subarray(0)) > 0) {
                const len = this.remainingLength();
                await ioWriter.writeBuffer(this.buffer.subarray(this.pointer, this.pointer + len));
                this.pointer += len;
                this.pos += BigInt(len);
            }
        }
    }
}


/***/ }),

/***/ "./src/common/io/IOWriter.ts":
/*!***********************************!*\
  !*** ./src/common/io/IOWriter.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOWriter)
/* harmony export */ });
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
/**
 * 写字节流工具
 */

class IOWriter {
    data;
    buffer;
    pointer;
    pos;
    size;
    littleEndian;
    error;
    onFlush;
    onSeek;
    /**
     * @param data 待写的 Uint8Array
     * @param bigEndian 是否按大端字节序写，默认大端字节序（网络字节序）
     */
    constructor(size = 1048576, bigEndian = true, map) {
        this.pointer = 0;
        this.pos = BigInt(0);
        this.size = size;
        this.littleEndian = !bigEndian;
        this.error = 0;
        if (map && map.view) {
            this.size = map.length;
            this.buffer = map;
            this.data = map.view;
        }
        else if (map && !map.byteOffset) {
            this.size = map.length;
            this.buffer = map;
            this.data = new DataView(this.buffer.buffer);
        }
        else {
            if (map) {
                throw new Error('not support subarray of ArrayBuffer');
            }
            this.buffer = new Uint8Array(this.size);
            this.data = new DataView(this.buffer.buffer);
        }
    }
    /**
     * 写 8 位无符号整数
     */
    async writeUint8(value) {
        if (this.remainingLength() < 1) {
            await this.flush();
        }
        this.data.setUint8(this.pointer, value);
        this.pointer++;
        this.pos++;
    }
    /**
     * 读取 16 位无符号整数
     */
    async writeUint16(value) {
        if (this.remainingLength() < 2) {
            await this.flush();
        }
        this.data.setUint16(this.pointer, value, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
    }
    /**
     * 写 24 位无符号整数
     */
    async writeUint24(value) {
        if (this.remainingLength() < 3) {
            await this.flush();
        }
        const high = (value & 0xff0000) >> 16;
        const middle = (value & 0x00ff00) >> 8;
        const low = value & 0x0000ff;
        if (this.littleEndian) {
            await this.writeUint8(low);
            await this.writeUint8(middle);
            await this.writeUint8(high);
        }
        else {
            await this.writeUint8(high);
            await this.writeUint8(middle);
            await this.writeUint8(low);
        }
    }
    /**
     * 写 32 位无符号整数
     */
    async writeUint32(value) {
        if (this.remainingLength() < 4) {
            await this.flush();
        }
        this.data.setUint32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 写 64 位无符号整数
     */
    async writeUint64(value) {
        if (this.remainingLength() < 8) {
            await this.flush();
        }
        this.data.setBigUint64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 写 8 位有符号整数
     *
     * @returns
     */
    async writeInt8(value) {
        if (this.remainingLength() < 1) {
            await this.flush();
        }
        this.data.setInt8(this.pointer, value);
        this.pointer++;
        this.pos++;
    }
    /**
     * 写 16 位有符号整数
     */
    async writeInt16(value) {
        if (this.remainingLength() < 2) {
            await this.flush();
        }
        this.data.setInt16(this.pointer, value, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
    }
    /**
     * 写 32 位有符号整数
     */
    async writeInt32(value) {
        if (this.remainingLength() < 4) {
            await this.flush();
        }
        this.data.setInt32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 写 64 位有符号整数
     */
    async writeInt64(value) {
        if (this.remainingLength() < 8) {
            await this.flush();
        }
        this.data.setBigInt64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 写单精度浮点数
     *
     * @returns
     */
    async writeFloat(value) {
        if (this.remainingLength() < 4) {
            await this.flush();
        }
        this.data.setFloat32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 写双精度浮点数
     */
    async writeDouble(value) {
        if (this.remainingLength() < 8) {
            await this.flush();
        }
        this.data.setFloat64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 获取当前写指针
     *
     * @returns
     */
    getPointer() {
        return this.pointer;
    }
    getPos() {
        return this.pos;
    }
    /**
     * 获取剩余可写节数
     *
     * @returns
     */
    remainingLength() {
        return this.size - this.pointer;
    }
    /**
     * 写指定长度的二进制 buffer 数据
     *
     * @param length
     * @returns
     */
    async writeBuffer(buffer) {
        if (!buffer.length) {
            return;
        }
        let length = buffer.length;
        if (this.remainingLength() < length) {
            let index = 0;
            while (length > 0) {
                await this.flush();
                const len = Math.min(this.size, length);
                this.buffer.set(buffer.subarray(index, index + len), this.pointer);
                this.pointer += len;
                this.pos += BigInt(len);
                index += len;
                length -= len;
            }
        }
        else {
            this.buffer.set(buffer, this.pointer);
            this.pointer += length;
            this.pos += BigInt(length);
        }
    }
    /**
     * 写一个字符串
     */
    async writeString(str) {
        const buffer = _util_text__WEBPACK_IMPORTED_MODULE_0__.encode(str);
        await this.writeBuffer(buffer);
        return buffer.length;
    }
    encodeString(str) {
        return _util_text__WEBPACK_IMPORTED_MODULE_0__.encode(str);
    }
    async flush() {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, flush failed because of no flush callback');
        }
        if (this.pointer) {
            const ret = await this.onFlush(this.buffer.subarray(0, this.pointer));
            if (ret !== 0) {
                this.error = ret;
                throw Error('IOWriter error, flush failed');
            }
        }
        this.pointer = 0;
    }
    async flushToPos(pos) {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, flush failed because of no flush callback');
        }
        if (this.pointer) {
            const ret = await this.onFlush(this.buffer.subarray(0, this.pointer), pos);
            if (ret !== 0) {
                this.error = ret;
                throw Error('IOWriter error, flush failed');
            }
        }
        this.pointer = 0;
    }
    async seek(pos) {
        if (!this.onSeek) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, seek failed because of no seek callback');
        }
        await this.flush();
        const ret = await this.onSeek(pos);
        if (ret !== 0) {
            this.error = ret;
            throw Error('IOWriter error, seek failed');
        }
        this.pos = pos;
    }
    seekInline(pos) {
        const pointer = this.pointer;
        this.pointer = Math.max(0, Math.min(this.size, pos));
        this.pos += BigInt(this.pointer - pointer);
    }
    skip(length) {
        const pointer = this.pointer;
        this.pointer = Math.min(this.size, this.pointer + length);
        this.pos += BigInt(this.pointer - pointer);
    }
    back(length) {
        const pointer = this.pointer;
        this.pointer = Math.max(0, this.pointer - length);
        this.pos += BigInt(this.pointer - pointer);
    }
    getBuffer() {
        return this.buffer.subarray(0, this.pointer);
    }
    setEndian(bigEndian) {
        this.littleEndian = !bigEndian;
    }
    reset() {
        this.pointer = 0;
        this.pos = BigInt(0);
        this.error = 0;
    }
    getBufferSize() {
        return this.size;
    }
}


/***/ }),

/***/ "./src/common/io/IOWriterSync.ts":
/*!***************************************!*\
  !*** ./src/common/io/IOWriterSync.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ IOWriterSync)
/* harmony export */ });
/* harmony import */ var _util_text__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/text */ "./src/common/util/text.ts");
/**
 * 写字节流工具
 */

class IOWriterSync {
    data;
    buffer;
    pointer;
    pos;
    size;
    littleEndian;
    error;
    onFlush;
    onSeek;
    /**
     * @param data 待写的 Uint8Array
     * @param bigEndian 是否按大端字节序写，默认大端字节序（网络字节序）
     */
    constructor(size = 1048576, bigEndian = true, map) {
        this.pointer = 0;
        this.pos = BigInt(0);
        this.size = size;
        this.littleEndian = !bigEndian;
        this.error = 0;
        if (map && map.view) {
            this.size = map.length;
            this.buffer = map;
            this.data = map.view;
        }
        else if (map && !map.byteOffset) {
            this.size = map.length;
            this.buffer = map;
            this.data = new DataView(this.buffer.buffer);
        }
        else {
            if (map) {
                throw new Error('not support subarray of ArrayBuffer');
            }
            this.buffer = new Uint8Array(this.size);
            this.data = new DataView(this.buffer.buffer);
        }
    }
    /**
     * 写 8 位无符号整数
     */
    writeUint8(value) {
        if (this.remainingLength() < 1) {
            this.flush();
        }
        this.data.setUint8(this.pointer, value);
        this.pointer++;
        this.pos++;
    }
    /**
     * 读取 16 位无符号整数
     */
    writeUint16(value) {
        if (this.remainingLength() < 2) {
            this.flush();
        }
        this.data.setUint16(this.pointer, value, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
    }
    /**
     * 写 24 位无符号整数
     */
    writeUint24(value) {
        if (this.remainingLength() < 3) {
            this.flush();
        }
        const high = (value & 0xff0000) >> 16;
        const middle = (value & 0x00ff00) >> 8;
        const low = value & 0x0000ff;
        if (this.littleEndian) {
            this.writeUint8(low);
            this.writeUint8(middle);
            this.writeUint8(high);
        }
        else {
            this.writeUint8(high);
            this.writeUint8(middle);
            this.writeUint8(low);
        }
    }
    /**
     * 写 32 位无符号整数
     */
    writeUint32(value) {
        if (this.remainingLength() < 4) {
            this.flush();
        }
        this.data.setUint32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 写 64 位无符号整数
     */
    writeUint64(value) {
        if (this.remainingLength() < 8) {
            this.flush();
        }
        this.data.setBigUint64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 写 8 位有符号整数
     *
     * @returns
     */
    writeInt8(value) {
        if (this.remainingLength() < 1) {
            this.flush();
        }
        this.data.setInt8(this.pointer, value);
        this.pointer++;
        this.pos++;
    }
    /**
     * 写 16 位有符号整数
     */
    writeInt16(value) {
        if (this.remainingLength() < 2) {
            this.flush();
        }
        this.data.setInt16(this.pointer, value, this.littleEndian);
        this.pointer += 2;
        this.pos += BigInt(2);
    }
    /**
     * 写 32 位有符号整数
     */
    writeInt32(value) {
        if (this.remainingLength() < 4) {
            this.flush();
        }
        this.data.setInt32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 写 64 位有符号整数
     */
    writeInt64(value) {
        if (this.remainingLength() < 8) {
            this.flush();
        }
        this.data.setBigInt64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 写单精度浮点数
     *
     * @returns
     */
    writeFloat(value) {
        if (this.remainingLength() < 4) {
            this.flush();
        }
        this.data.setFloat32(this.pointer, value, this.littleEndian);
        this.pointer += 4;
        this.pos += BigInt(4);
    }
    /**
     * 写双精度浮点数
     */
    writeDouble(value) {
        if (this.remainingLength() < 8) {
            this.flush();
        }
        this.data.setFloat64(this.pointer, value, this.littleEndian);
        this.pointer += 8;
        this.pos += BigInt(8);
    }
    /**
     * 获取当前写指针
     *
     * @returns
     */
    getPointer() {
        return this.pointer;
    }
    getPos() {
        return this.pos;
    }
    /**
     * 获取剩余可写节数
     *
     * @returns
     */
    remainingLength() {
        return this.size - this.pointer;
    }
    /**
     * 写指定长度的二进制 buffer 数据
     *
     * @param length
     * @returns
     */
    writeBuffer(buffer) {
        if (!buffer.length) {
            return;
        }
        let length = buffer.length;
        if (this.remainingLength() < length) {
            let index = 0;
            while (length > 0) {
                this.flush();
                const len = Math.min(this.size, length);
                this.buffer.set(buffer.subarray(index, index + len), this.pointer);
                this.pointer += len;
                this.pos += BigInt(len);
                index += len;
                length -= len;
            }
        }
        else {
            this.buffer.set(buffer, this.pointer);
            this.pointer += length;
            this.pos += BigInt(length);
        }
    }
    /**
     * 写一个字符串
     */
    writeString(str) {
        const buffer = _util_text__WEBPACK_IMPORTED_MODULE_0__.encode(str);
        this.writeBuffer(buffer);
        return buffer.length;
    }
    encodeString(str) {
        return _util_text__WEBPACK_IMPORTED_MODULE_0__.encode(str);
    }
    flush() {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, flush failed because of no flush callback');
        }
        if (this.pointer) {
            const ret = this.onFlush(this.buffer.subarray(0, this.pointer));
            if (ret !== 0) {
                this.error = ret;
                throw Error('IOWriter error, flush failed');
            }
        }
        this.pointer = 0;
    }
    flushToPos(pos) {
        if (!this.onFlush) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, flush failed because of no flush callback');
        }
        if (this.pointer) {
            const ret = this.onFlush(this.buffer.subarray(0, this.pointer), pos);
            if (ret !== 0) {
                this.error = ret;
                throw Error('IOWriter error, flush failed');
            }
        }
        this.pointer = 0;
    }
    seek(pos) {
        if (!this.onSeek) {
            this.error = -1048574 /* IOError.INVALID_OPERATION */;
            throw Error('IOWriter error, seek failed because of no seek callback');
        }
        this.flush();
        const ret = this.onSeek(pos);
        if (ret !== 0) {
            this.error = ret;
            throw Error('IOWriter error, seek failed');
        }
        this.pos = pos;
    }
    seekInline(pos) {
        const pointer = this.pointer;
        this.pointer = Math.max(0, Math.min(this.size, pos));
        this.pos += BigInt(this.pointer - pointer);
    }
    skip(length) {
        const pointer = this.pointer;
        this.pointer = Math.min(this.size, this.pointer + length);
        this.pos += BigInt(this.pointer - pointer);
    }
    back(length) {
        const pointer = this.pointer;
        this.pointer = Math.max(0, this.pointer - length);
        this.pos += BigInt(this.pointer - pointer);
    }
    getBuffer() {
        return this.buffer.subarray(0, this.pointer);
    }
    setEndian(bigEndian) {
        this.littleEndian = !bigEndian;
    }
    reset() {
        this.pointer = 0;
        this.pos = BigInt(0);
        this.error = 0;
    }
    getBufferSize() {
        return this.size;
    }
}


/***/ }),

/***/ "./src/common/io/SafeFileIO.ts":
/*!*************************************!*\
  !*** ./src/common/io/SafeFileIO.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SafeFileIO)
/* harmony export */ });
/* harmony import */ var _FileIO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FileIO */ "./src/common/io/FileIO.ts");
/* harmony import */ var _helper_CommandQueue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper/CommandQueue */ "./src/common/helper/CommandQueue.ts");


class SafeFileIO extends _FileIO__WEBPACK_IMPORTED_MODULE_0__["default"] {
    commandQueue;
    constructor(handler, append = false) {
        super(handler, append);
        this.commandQueue = new _helper_CommandQueue__WEBPACK_IMPORTED_MODULE_1__["default"]();
    }
    async write(data) {
        return this.commandQueue.push(async () => {
            return super.write(data);
        });
    }
    async seek(position) {
        return this.commandQueue.push(async () => {
            return super.seek(position);
        });
    }
    async seekToEnd() {
        return this.commandQueue.push(async () => {
            return super.seekToEnd();
        });
    }
    async resize(size) {
        return this.commandQueue.push(async () => {
            return super.resize(size);
        });
    }
    async read(start, end) {
        return this.commandQueue.push(async () => {
            return super.read(start, end);
        });
    }
    async appendBufferByPosition(buffer, position) {
        return this.commandQueue.push(async () => {
            return super.appendBufferByPosition(buffer, position);
        });
    }
    async close() {
        return this.commandQueue.push(async () => {
            return super.close();
        });
    }
    async destroy() {
        await super.destroy();
        this.commandQueue.clear();
        this.commandQueue = null;
    }
    get writeQueueSize() {
        return this.commandQueue.length;
    }
}


/***/ }),

/***/ "./src/common/math/gcd.ts":
/*!********************************!*\
  !*** ./src/common/math/gcd.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ gcd)
/* harmony export */ });
/**
 * // 计算最大公约数（GCD）
 *
 * @param a
 * @param b
 * @returns
 */
function gcd(a, b) {
    while (b !== 0) {
        [a, b] = [b, a % b];
    }
    return a;
}


/***/ }),

/***/ "./src/common/network/FakeMessageChannel.ts":
/*!**************************************************!*\
  !*** ./src/common/network/FakeMessageChannel.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FakeMessageChannel)
/* harmony export */ });
class FakeMessageChannelPort extends EventTarget {
    peer;
    postMessage(message, transfer) {
        if (this.peer?.onmessage) {
            this.peer.onmessage({
                data: message
            });
        }
    }
    onmessage;
    onmessageerror;
    close() {
        this.peer = null;
    }
    start() {
    }
}
class FakeMessageChannel {
    port1;
    port2;
    constructor() {
        this.port1 = new FakeMessageChannelPort();
        this.port2 = new FakeMessageChannelPort();
        this.port1.peer = this.port2;
        this.port2.peer = this.port1;
    }
}


/***/ }),

/***/ "./src/common/network/IPCPort.ts":
/*!***************************************!*\
  !*** ./src/common/network/IPCPort.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NOTIFY: () => (/* binding */ NOTIFY),
/* harmony export */   REQUEST: () => (/* binding */ REQUEST),
/* harmony export */   "default": () => (/* binding */ IPCPort)
/* harmony export */ });
/* harmony import */ var _event_Emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../event/Emitter */ "./src/common/event/Emitter.ts");
/* harmony import */ var _function_isDef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/isDef */ "./src/common/function/isDef.ts");


const NOTIFY = 'notify';
const REQUEST = 'request';
class IPCPort extends _event_Emitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
    port;
    requestMap;
    seq;
    closed;
    constructor(port) {
        super(true);
        this.port = port;
        this.port.onmessage = this.handle.bind(this);
        this.seq = 0;
        this.requestMap = new Map();
        this.port.start();
        this.closed = false;
    }
    handle(event) {
        const origin = event.data;
        const type = origin.type;
        const data = origin.data;
        if (type === 'notify') {
            this.fire(NOTIFY, data);
        }
        else if (type === 'reply') {
            const request = this.requestMap.get(data.seq);
            if (request) {
                if ((0,_function_isDef__WEBPACK_IMPORTED_MODULE_1__["default"])(data.result)) {
                    request.resolve(data.result);
                }
                else if (data.error) {
                    request.reject(data.error);
                }
                else {
                    request.resolve(undefined);
                }
                this.requestMap.delete(data.seq);
            }
        }
        else if (type === 'request') {
            this.fire(REQUEST, data);
        }
    }
    notify(method, params = {}, transfer = []) {
        this.port.postMessage({
            type: 'notify',
            data: {
                method,
                params
            }
        }, transfer);
    }
    async request(method, params = {}, transfer = []) {
        return new Promise((resolve, reject) => {
            const id = this.seq++;
            this.requestMap.set(id, {
                resolve,
                reject
            });
            this.port.postMessage({
                type: 'request',
                data: {
                    seq: id,
                    method,
                    params
                }
            }, transfer);
        });
    }
    reply(request, result, error, transfer = []) {
        const data = {
            seq: request.seq
        };
        if ((0,_function_isDef__WEBPACK_IMPORTED_MODULE_1__["default"])(result)) {
            data.result = result;
        }
        else if (error) {
            data.error = error;
        }
        if (transfer?.length) {
            this.port.postMessage({
                type: 'reply',
                data
            }, transfer);
        }
        else {
            this.port.postMessage({
                type: 'reply',
                data
            });
        }
    }
    getPort() {
        return this.port;
    }
    destroy() {
        if (this.requestMap.size) {
            this.requestMap.forEach((req) => {
                req.reject('ipc port close');
            });
            this.requestMap.clear();
        }
        if (this.port) {
            this.port.close();
            this.port = null;
        }
        this.closed = true;
    }
}


/***/ }),

/***/ "./src/common/timer/Clock.ts":
/*!***********************************!*\
  !*** ./src/common/timer/Clock.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Clock)
/* harmony export */ });
/* harmony import */ var _function_isWorker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/isWorker */ "./src/common/function/isWorker.ts");
/* harmony import */ var _function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/* harmony import */ var _WorkerSetTimeout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WorkerSetTimeout */ "./src/common/timer/WorkerSetTimeout.ts");
/* harmony import */ var _function_debounce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../function/debounce */ "./src/common/function/debounce.ts");




let workerSetTimeout;
let workerSetTimeoutCounter = 0;
function createWorkerSetTimeout() {
    if (workerSetTimeout) {
        workerSetTimeoutCounter++;
        return workerSetTimeout;
    }
    workerSetTimeout = new _WorkerSetTimeout__WEBPACK_IMPORTED_MODULE_0__["default"]();
    workerSetTimeoutCounter = 1;
    return workerSetTimeout;
}
function deleteWorkerSetTimeout() {
    if (workerSetTimeoutCounter === 0) {
        return;
    }
    workerSetTimeoutCounter--;
    if (workerSetTimeoutCounter === 0) {
        workerSetTimeout.destroy();
        workerSetTimeout = null;
    }
}
class Clock {
    messageChannel;
    interval;
    started;
    timer;
    workerTimer;
    workerSetTimeout;
    onClock;
    nextTick;
    /**
     * messageChannel 执行间隔，默认 0.2
     */
    a;
    /**
     * setTimeout 最小执行间隔，默认 4
     */
    b;
    /**
     * 50 毫秒内  messageChannel 执行次数
     */
    beta;
    /**
     * 50 毫秒内  setTimeout 执行次数
     */
    alpha;
    count;
    /**
     * 等效时间
     */
    equivalent;
    timestamp;
    onVisibilityChange;
    timeoutNext;
    running;
    highPerformance;
    constructor(interval, highPerformance = true) {
        this.started = false;
        this.interval = interval;
        this.highPerformance = highPerformance;
        this.a = 0.2;
        this.b = 4;
        this.equivalent = 50;
        this.timestamp = 0;
        this.nextTick = () => {
            if (!this.started || this.running) {
                return;
            }
            this.running = true;
            if (this.interval >= 4 || !this.highPerformance) {
                this.timeoutTick();
            }
            else if (this.interval <= 0) {
                this.messageChannel.port1.postMessage(null);
            }
            else {
                const now = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
                if (now - this.timestamp > this.equivalent) {
                    this.count = 0;
                    this.timestamp = now;
                }
                if (this.count < this.beta) {
                    this.messageChannel.port1.postMessage(null);
                }
                else {
                    this.timeoutTick();
                }
            }
        };
        this.compute();
        this.messageChannel = new MessageChannel();
        this.handleEvent();
        this.timeoutNext = (worker) => {
            if (worker) {
                this.workerTimer = null;
            }
            else {
                this.timer = null;
            }
            this.running = false;
            this.count++;
            if (this.onClock) {
                this.onClock(this.nextTick);
            }
            else {
                this.nextTick();
            }
        };
        if (!(0,_function_isWorker__WEBPACK_IMPORTED_MODULE_2__["default"])() && document.visibilityState === 'hidden') {
            this.workerSetTimeout = createWorkerSetTimeout();
        }
        this.running = false;
    }
    compute(clear = true) {
        if (this.interval > 0) {
            this.beta = Math.ceil(this.equivalent * (1 - this.b / this.interval) / (this.a - this.b));
            this.alpha = Math.floor(this.equivalent / this.interval - this.beta);
            if (clear) {
                this.count = 0;
            }
        }
    }
    timeoutTick() {
        if (this.workerSetTimeout
            && document.visibilityState === 'hidden'
            && this.interval < 1000) {
            this.workerTimer = this.workerSetTimeout.setTimeout(this.timeoutNext, this.interval);
        }
        else {
            this.timer = setTimeout(this.timeoutNext, this.interval);
        }
    }
    start() {
        if (this.started) {
            return;
        }
        this.started = true;
        this.timestamp = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
        this.nextTick();
    }
    stop() {
        this.started = false;
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
        if (this.workerTimer && this.workerSetTimeout) {
            this.workerSetTimeout.clearTimeout(this.workerTimer);
        }
        this.running = false;
    }
    isStarted() {
        return this.started;
    }
    setInterval(interval) {
        this.interval = Math.max(interval, 0);
        this.compute();
    }
    getInterval() {
        return this.interval;
    }
    isZeroTimeout() {
        return this.interval < 4;
    }
    destroy() {
        this.stop();
        if (this.workerSetTimeout) {
            deleteWorkerSetTimeout();
            this.workerSetTimeout = null;
        }
        if (this.onVisibilityChange) {
            document.removeEventListener('visibilitychange', this.onVisibilityChange);
            this.onVisibilityChange = null;
        }
    }
    handleEvent() {
        this.messageChannel.port2.onmessage = () => {
            if (!this.started) {
                return;
            }
            this.running = false;
            this.count++;
            if (this.onClock) {
                this.onClock(this.nextTick);
            }
            else {
                this.nextTick();
            }
        };
        if (!(0,_function_isWorker__WEBPACK_IMPORTED_MODULE_2__["default"])()) {
            this.onVisibilityChange = (0,_function_debounce__WEBPACK_IMPORTED_MODULE_3__["default"])((event) => {
                if (document.visibilityState === 'hidden') {
                    this.workerSetTimeout = createWorkerSetTimeout();
                    if (this.timer) {
                        clearTimeout(this.timer);
                        this.timer = null;
                        this.running = false;
                    }
                    this.nextTick();
                }
                else {
                    if (this.workerTimer) {
                        this.workerSetTimeout.clearTimeout(this.workerTimer);
                        this.workerTimer = null;
                        this.running = false;
                    }
                    if (this.timer) {
                        clearTimeout(this.timer);
                        this.timer = null;
                        this.running = false;
                    }
                    deleteWorkerSetTimeout();
                    this.workerSetTimeout = null;
                    this.nextTick();
                }
            }, 20);
            document.addEventListener('visibilitychange', this.onVisibilityChange);
        }
    }
}


/***/ }),

/***/ "./src/common/timer/LoopTask.ts":
/*!**************************************!*\
  !*** ./src/common/timer/LoopTask.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LoopTask)
/* harmony export */ });
/* harmony import */ var _Clock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Clock */ "./src/common/timer/Clock.ts");
/* harmony import */ var _function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/getTimestamp */ "./src/common/function/getTimestamp.ts");
/**
 * @file 可伸缩循环任务队列
 */


class LoopTask {
    task;
    count;
    emptyCount;
    started;
    clock;
    timestamp;
    timeout;
    interval;
    startTimer;
    autoInterval;
    sync;
    tickAfter;
    processing;
    constructor(task, timeout = 0, interval = 0, autoInterval = true, sync = true) {
        this.task = task;
        this.timeout = timeout;
        this.interval = interval;
        this.autoInterval = autoInterval;
        this.sync = sync;
        this.count = 0;
        this.emptyCount = 0;
        this.timestamp = 0;
        this.started = false;
        this.processing = false;
        this.clock = new _Clock__WEBPACK_IMPORTED_MODULE_0__["default"](this.interval);
        this.clock.onClock = (next) => {
            if (!this.started) {
                return;
            }
            this.count++;
            if (this.sync) {
                if (this.tickAfter) {
                    this.tickAfter();
                    this.tickAfter = null;
                }
                if (this.task() === false) {
                    this.stop();
                }
                else {
                    this.next(next);
                }
            }
            else {
                if (this.processing) {
                    return;
                }
                this.processing = true;
                this.task().then((result) => {
                    this.processing = false;
                    if (this.tickAfter) {
                        this.tickAfter();
                        this.tickAfter = null;
                    }
                    if (result === false) {
                        this.stop();
                    }
                    else {
                        this.next(next);
                    }
                });
            }
        };
    }
    next(next) {
        if (!this.started) {
            return;
        }
        const now = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
        if (this.autoInterval && now - this.timestamp > 50) {
            const load = this.emptyCount / this.count;
            /**
             * 1000 毫秒被空闲任务调用超过 10%，将间隔减一
             * 没有空闲任务，将间隔重新置为 0
             */
            if (this.emptyCount === 0) {
                this.clock.setInterval(Math.max(this.clock.getInterval() >> 1, this.interval));
            }
            else if (load < 0.1) {
                this.clock.setInterval(this.clock.getInterval() - 1);
            }
            else if (load > 0.2) {
                this.clock.setInterval(Math.min(this.clock.getInterval() + 1, 20));
            }
            else if (load > 0.5) {
                this.clock.setInterval(this.clock.getInterval() << 1);
            }
            this.count = 0;
            this.emptyCount = 0;
            this.timestamp = now;
        }
        next();
    }
    start() {
        this.started = true;
        if (this.timeout) {
            this.startTimer = setTimeout(() => {
                this.count = 0;
                this.emptyCount = 0;
                this.timestamp = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
                this.clock.start();
                this.startTimer = null;
            }, this.timeout);
        }
        else {
            this.count = 0;
            this.emptyCount = 0;
            this.timestamp = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
            this.clock.start();
        }
    }
    stop() {
        this.started = false;
        this.processing = false;
        if (this.startTimer) {
            clearTimeout(this.startTimer);
            this.startTimer = null;
        }
        this.clock.stop();
    }
    async stopBeforeNextTick() {
        if (this.startTimer) {
            clearTimeout(this.startTimer);
            this.startTimer = null;
        }
        if (!this.clock.isStarted()) {
            return;
        }
        if (this.sync) {
            this.started = false;
            this.processing = false;
            this.clock.stop();
        }
        else {
            return new Promise((resolve) => {
                this.tickAfter = () => {
                    this.started = false;
                    this.processing = false;
                    this.clock.stop();
                    resolve();
                };
            });
        }
    }
    isStarted() {
        return this.started;
    }
    emptyTask() {
        this.emptyCount++;
    }
    isZeroTimeout() {
        return this.clock?.isZeroTimeout();
    }
    restart() {
        if (this.clock) {
            this.stop();
            this.clock.setInterval(this.interval);
            this.start();
        }
    }
    resetInterval() {
        this.clock.setInterval(Math.max(this.clock.getInterval() >> 1, this.interval));
        this.emptyCount = 0;
        this.count = 0;
        this.timestamp = (0,_function_getTimestamp__WEBPACK_IMPORTED_MODULE_1__["default"])();
    }
    destroy() {
        this.stop();
        this.task = null;
        this.timeout = null;
        this.interval = null;
    }
}


/***/ }),

/***/ "./src/common/timer/Sleep.ts":
/*!***********************************!*\
  !*** ./src/common/timer/Sleep.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Sleep)
/* harmony export */ });
/**
 * @file sleep
 */
class Sleep {
    timeout;
    timer;
    resolve;
    reject;
    startTime;
    /**
     *
     * @param timeout 时间（秒）
     */
    constructor(timeout) {
        this.timeout = timeout;
    }
    then(res, rej) {
        this.resolve = res;
        this.reject = rej;
        this.startTime = Date.now();
        this.timer = setTimeout(() => {
            this.resolve(Date.now() - this.startTime);
            this.timer = null;
        }, this.timeout * 1000);
    }
    stop(resolve = true) {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
            if (this.resolve && resolve) {
                this.resolve(Date.now() - this.startTime);
            }
            else if (this.reject && !resolve) {
                this.reject(Date.now() - this.startTime);
            }
        }
    }
    reset(timeout) {
        if (timeout) {
            this.timeout = timeout;
        }
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = setTimeout(() => {
                this.resolve(Date.now() - this.startTime);
                this.timer = null;
            }, this.timeout * 1000);
        }
    }
}


/***/ }),

/***/ "./src/common/timer/Timer.ts":
/*!***********************************!*\
  !*** ./src/common/timer/Timer.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Timer)
/* harmony export */ });
/**
 * @file 定时任务
 */
class Timer {
    task;
    timeout;
    interval;
    timer;
    /**
     *
     * @param task 定时任务
     * @param timeout 多久之后开始
     * @param interval 执行间隔
     */
    constructor(task, timeout, interval) {
        this.task = task;
        this.timeout = timeout;
        this.interval = interval;
    }
    /**
     * 开始执行
     */
    start() {
        const me = this;
        me.stop();
        let timeout = me.timeout;
        const interval = me.interval;
        const next = function () {
            if (me.task() !== false
                && me.timer) {
                me.timer = setTimeout(next, me.interval);
            }
            else {
                me.stop();
            }
        };
        if (timeout == null) {
            timeout = interval;
        }
        me.timer = setTimeout(next, timeout);
    }
    /**
     * 停止执行
     */
    stop() {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
    }
    updateInterval(interval) {
        this.interval = interval;
    }
    /**
     * 是否正在执行
     */
    isStarted() {
        return !!this.timer;
    }
    /**
     * 销毁定时任务
     */
    destroy() {
        this.stop();
        this.task = this.timeout = this.interval = null;
    }
}


/***/ }),

/***/ "./src/common/timer/WorkerSetTimeout.ts":
/*!**********************************************!*\
  !*** ./src/common/timer/WorkerSetTimeout.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WorkerSetTimeout)
/* harmony export */ });
/* harmony import */ var _function_sourceLoad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function/sourceLoad */ "./src/common/function/sourceLoad.ts");

__webpack_require__(/*! ./workerSetTimeoutTask */ "./src/common/timer/workerSetTimeoutTask.ts");
class WorkerSetTimeout {
    worker;
    workerUrl;
    taskMap;
    id;
    constructor() {
        this.id = 0;
        this.taskMap = new Map();
        const workerSource = `
      ${(0,_function_sourceLoad__WEBPACK_IMPORTED_MODULE_0__["default"])(/*require.resolve*/(/*! ./workerSetTimeoutTask */ "./src/common/timer/workerSetTimeoutTask.ts"), { varName: 'workerSetTimeoutTask' })}
      workerSetTimeoutTask.default(self)
    `;
        const blob = new Blob([workerSource], { type: 'text/javascript' });
        this.workerUrl = URL.createObjectURL(blob);
        this.worker = new Worker(this.workerUrl);
        this.worker.addEventListener('message', (message) => {
            const origin = message.data;
            const type = origin.type;
            const id = origin.id;
            switch (type) {
                case 'pong':
                    const task = this.taskMap.get(id);
                    if (task) {
                        task(true);
                    }
                    break;
            }
        });
    }
    setTimeout(task, timeout = 0) {
        const id = this.id++;
        this.taskMap.set(id, task);
        this.worker.postMessage({
            type: 'ping',
            data: {
                timeout,
                id
            }
        });
        return id;
    }
    clearTimeout(id) {
        this.taskMap.delete(id);
    }
    destroy() {
        if (this.worker) {
            this.worker.terminate();
            this.worker = null;
        }
        if (this.workerUrl) {
            URL.revokeObjectURL(this.workerUrl);
            this.workerUrl = null;
        }
        if (this.taskMap) {
            this.taskMap.clear();
            this.taskMap = null;
        }
    }
}


/***/ }),

/***/ "./src/common/timer/workerSetTimeoutTask.ts":
/*!**************************************************!*\
  !*** ./src/common/timer/workerSetTimeoutTask.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ run)
/* harmony export */ });
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/common/timer/workerSetTimeoutTask.ts";

class WorkerSetTimeout {
    worker;
    constructor(self) {
        this.worker = self;
        this.handleEvents();
    }
    handleEvents() {
        this.worker.addEventListener('message', (message) => {
            const origin = message.data;
            let data = origin.data;
            setTimeout(() => {
                this.worker.postMessage({
                    type: 'pong',
                    id: data.id
                });
            }, Math.max(data.timeout ?? 0, 4));
        });
    }
}
function run(self) {
    try {
        new WorkerSetTimeout(self);
    }
    catch (error) {
        _util_logger__WEBPACK_IMPORTED_MODULE_0__.error('new WorkerSetTimeout failed', cheap__fileName__0, 32);
    }
}


/***/ }),

/***/ "./src/common/util/array.ts":
/*!**********************************!*\
  !*** ./src/common/util/array.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   binarySearch: () => (/* binding */ binarySearch),
/* harmony export */   each: () => (/* binding */ each),
/* harmony export */   has: () => (/* binding */ has),
/* harmony export */   push: () => (/* binding */ push),
/* harmony export */   remove: () => (/* binding */ remove),
/* harmony export */   toArray: () => (/* binding */ toArray)
/* harmony export */ });
/* unused harmony exports unshift, indexOf, last, pop, toObject, join, falsy, exclude */
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is */ "./src/common/util/is.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/* harmony import */ var _function_execute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/execute */ "./src/common/function/execute.ts");
/**
 * @file 数组操作
 */



/**
 * 遍历数组
 *
 * @param array
 * @param callback 返回 false 可停止遍历
 * @param reversed 是否逆序遍历
 */
function each(array, callback, reversed) {
    if (!array) {
        return;
    }
    const { length } = array;
    if (length) {
        if (reversed) {
            for (let i = length - 1; i >= 0; i--) {
                if (callback(array[i], i) === _constant__WEBPACK_IMPORTED_MODULE_0__.FALSE) {
                    break;
                }
            }
        }
        else {
            for (let i = 0; i < length; i++) {
                if (callback(array[i], i) === _constant__WEBPACK_IMPORTED_MODULE_0__.FALSE) {
                    break;
                }
            }
        }
    }
}
function nativePush(array, item) {
    array[array.length] = item;
}
function nativeUnshift(array, item) {
    array.unshift(item);
}
/**
 * 添加
 *
 * @param array
 * @param value
 * @param action
 */
function addItem(array, value, action) {
    if (_is__WEBPACK_IMPORTED_MODULE_1__.array(value)) {
        each(value, function (item) {
            action(array, item);
        });
    }
    else {
        action(array, value);
    }
}
/**
 * 往后加
 *
 * @param array
 * @param target
 */
function push(array, target) {
    addItem(array, target, nativePush);
}
/**
 * 往前加
 *
 * @param array
 * @param target
 */
function unshift(array, target) {
    addItem(array, target, nativeUnshift);
}
/**
 * 数组项在数组中的位置
 *
 * @param array 数组
 * @param target 数组项
 * @param strict 是否全等判断，默认是全等
 * @return 如果未找到，返回 -1
 */
function indexOf(array, target, strict) {
    let result = _constant__WEBPACK_IMPORTED_MODULE_0__.MINUS_ONE;
    each(array, function (item, index) {
        if (strict === _constant__WEBPACK_IMPORTED_MODULE_0__.FALSE ? item == target : item === target) {
            result = index;
            return _constant__WEBPACK_IMPORTED_MODULE_0__.FALSE;
        }
    });
    return result;
}
/**
 * 获取数组最后一项
 *
 * @param array 数组
 * @return
 */
function last(array) {
    const { length } = array;
    if (length > 0) {
        return array[length - 1];
    }
}
/**
 * 弹出数组最后一项
 *
 * 项目里用的太多，仅用于节省字符
 *
 * @param array 数组
 * @return 弹出的数组项
 */
function pop(array) {
    const { length } = array;
    if (length > 0) {
        return array.pop();
    }
}
/**
 * 删除数组项
 *
 * @param array 数组
 * @param item 待删除项
 * @param strict 是否全等判断，默认是全等
 * @return 删除的数量
 */
function remove(array, target, strict) {
    let result = 0;
    each(array, function (item, index) {
        if (strict === _constant__WEBPACK_IMPORTED_MODULE_0__.FALSE ? item == target : item === target) {
            array.splice(index, 1);
            result++;
        }
    }, _constant__WEBPACK_IMPORTED_MODULE_0__.TRUE);
    return result;
}
/**
 * 数组是否包含 item
 *
 * @param array 数组
 * @param target 可能包含的数组项
 * @param strict 是否全等判断，默认是全等
 * @return
 */
function has(array, target, strict) {
    return indexOf(array, target, strict) >= 0;
}
/**
 * 把类数组转成数组
 *
 * @param array 类数组
 * @return
 */
function toArray(array) {
    return _is__WEBPACK_IMPORTED_MODULE_1__.array(array)
        ? array
        : (0,_function_execute__WEBPACK_IMPORTED_MODULE_2__["default"])(_constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ARRAY.slice, array);
}
/**
 * 把数组转成对象
 *
 * @param array 数组
 * @param key 数组项包含的字段名称，如果数组项是基本类型，可不传
 * @param value
 * @return
 */
function toObject(array, key, value) {
    let result = {};
    each(array, function (item) {
        result[key ? item[key] : item] = value || item;
    });
    return result;
}
/**
 * 把数组合并成字符串
 *
 * @param array
 * @param separator
 * @return
 */
function join(array, separator) {
    return array.join(separator);
}
/**
 * 用于判断长度大于 0 的数组
 *
 * @param array
 * @return
 */
function falsy(array) {
    return !_is__WEBPACK_IMPORTED_MODULE_1__.array(array) || !array.length;
}
/**
 * 排除数组元素返回新数组
 *
 * @param source
 * @param exc
 * @returns
 */
function exclude(source, exc) {
    const items = [];
    each(source, (item, index) => {
        if (!has(exc, item)) {
            items.push(item);
        }
    });
    return items;
}
/**
 * 二分查找
 *
 * @param array
 * @param callback 相等返回 0， 往左边查返回 -1， 往右边查返回 1
 * @returns
 */
function binarySearch(array, callback) {
    let left = 0;
    let right = array.length - 1;
    let index = -1;
    while (left <= right) {
        let mid = ((left + right) / 2) >>> 0;
        const ret = callback(array[mid]);
        if (ret === 0) {
            index = mid;
            break;
        }
        else if (ret === 1) {
            left = mid + 1;
        }
        else {
            right = mid - 1;
            index = mid;
        }
    }
    return index;
}


/***/ }),

/***/ "./src/common/util/base32.ts":
/*!***********************************!*\
  !*** ./src/common/util/base32.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   encode: () => (/* binding */ encode)
/* harmony export */ });
/* unused harmony export decode */
const base32 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
/**
 * base32 解密
 */
function decode(text) {
    text = text.toUpperCase().replace(/=+$/, '');
    let bits = 0;
    let value = 0;
    let index = 0;
    const output = new Uint8Array(((text.length * 5) / 8) | 0);
    for (let i = 0; i < length; i++) {
        value = (value << 5) | base32.indexOf(text[i]);
        bits += 5;
        if (bits >= 8) {
            output[index++] = (value >>> (bits - 8)) & 255;
            bits -= 8;
        }
    }
    return output;
}
/**
 * base32 加密
 */
function encode(buffer, padding = true) {
    const length = buffer.length;
    let bits = 0;
    let value = 0;
    let output = '';
    for (let i = 0; i < length; i++) {
        value = (value << 8) | buffer[i];
        bits += 8;
        while (bits >= 5) {
            output += base32[(value >>> (bits - 5)) & 31];
            bits -= 5;
        }
    }
    if (bits > 0) {
        output += base32[(value << (5 - bits)) & 31];
    }
    if (padding) {
        while (output.length % 8 !== 0) {
            output += '=';
        }
    }
    return output;
}


/***/ }),

/***/ "./src/common/util/base64.ts":
/*!***********************************!*\
  !*** ./src/common/util/base64.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base64ToUint8Array: () => (/* binding */ base64ToUint8Array)
/* harmony export */ });
/* unused harmony exports base64Decode, list, map */
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./src/common/util/array.ts");

const base64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
/**
 * utf8 编码
 * @param text
 */
function utf8Decode(text) {
    let string = '', i = 0, c = 0, c1 = 0, c2 = 0, c3 = 0;
    while (i < text.length) {
        c = text.charCodeAt(i);
        if (c < 128) {
            string += String.fromCharCode(c);
            i++;
        }
        else if ((c > 191) && (c < 224)) {
            c2 = text.charCodeAt(i + 1);
            string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
            i += 2;
        }
        else {
            c2 = text.charCodeAt(i + 1);
            c3 = text.charCodeAt(i + 2);
            string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
            i += 3;
        }
    }
    return string;
}
/**
 * base64 解密
 */
function base64Decode(text) {
    let output = '';
    let chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0;
    text = text.replace(/[^A-Za-z0-9\+\/\=]/g, '');
    // 不是 4 的倍数补齐 =
    while (text.length % 4) {
        text += '=';
    }
    while (i < text.length) {
        enc1 = base64.indexOf(text.charAt(i++));
        enc2 = base64.indexOf(text.charAt(i++));
        enc3 = base64.indexOf(text.charAt(i++));
        enc4 = base64.indexOf(text.charAt(i++));
        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;
        output += String.fromCharCode(chr1);
        if (enc3 !== 64) {
            output += String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
            output += String.fromCharCode(chr3);
        }
    }
    return utf8Decode(output);
}
function atobCustom(encodedString) {
    function decodeBase64(char) {
        const index = base64.indexOf(char);
        return index === -1 ? 0 : index;
    }
    let decodedString = '';
    for (let i = 0; i < encodedString.length;) {
        const enc1 = decodeBase64(encodedString[i++]);
        const enc2 = decodeBase64(encodedString[i++]);
        const enc3 = decodeBase64(encodedString[i++]);
        const enc4 = decodeBase64(encodedString[i++]);
        const chr1 = (enc1 << 2) | (enc2 >> 4);
        const chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        const chr3 = ((enc3 & 3) << 6) | enc4;
        decodedString += String.fromCharCode(chr1);
        if (enc3 !== 64) {
            decodedString += String.fromCharCode(chr2);
        }
        if (enc4 !== 64) {
            decodedString += String.fromCharCode(chr3);
        }
    }
    return decodedString;
}
function base64ToUint8Array(string) {
    const binaryData = typeof atob === 'function' ? atob(string) : atobCustom(string);
    const uint8Array = new Uint8Array(binaryData.length);
    for (let i = 0; i < binaryData.length; i++) {
        uint8Array[i] = binaryData.charCodeAt(i);
    }
    return uint8Array;
}
const list = [
    'A', 'B', 'C', 'D', 'E', 'F',
    'G', 'H', 'I', 'J', 'K', 'L',
    'M', 'N', 'O', 'P', 'Q', 'R',
    'S', 'T', 'U', 'V', 'W', 'X',
    'Y', 'Z', 'a', 'b', 'c', 'd',
    'e', 'f', 'g', 'h', 'i', 'j',
    'k', 'l', 'm', 'n', 'o', 'p',
    'q', 'r', 's', 't', 'u', 'v',
    'w', 'x', 'y', 'z', '0', '1',
    '2', '3', '4', '5', '6', '7',
    '8', '9', '+', '/'
];
const _map = {};
_array__WEBPACK_IMPORTED_MODULE_0__.each(list, (char, index) => {
    _map[char] = index;
});
const map = _map;


/***/ }),

/***/ "./src/common/util/bigint.ts":
/*!***********************************!*\
  !*** ./src/common/util/bigint.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min)
/* harmony export */ });
function abs(a) {
    return a > 0 ? a : -a;
}
function max(a, b) {
    return a > b ? a : b;
}
function min(a, b) {
    return a > b ? b : a;
}


/***/ }),

/***/ "./src/common/util/browser.ts":
/*!************************************!*\
  !*** ./src/common/util/browser.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is */ "./src/common/util/is.ts");
/* harmony import */ var _function_checkVersion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/checkVersion */ "./src/common/function/checkVersion.ts");
/**
 * @file browser
 */



function getMajorVersion(version) {
    if (!_is__WEBPACK_IMPORTED_MODULE_0__.string(version)) {
        return '';
    }
    return version.split('.').shift() || '';
}
/**
 * UA 检测浏览器
 *
 * 返回结果如下：
 *
 * {
 *    name: 'ie',     // 判断多个浏览器时，便于用 name 去 switch
 *    ie: true,       // 判断某一个浏览器时，便于 if (ie) { ... }
 *    version: '8.0'  // 版本号，string 类型
 * }
 *
 */
// http://www.fynas.com/ua/search
const list = [
    ["alipay" /* BrowserType.ALIPAY */, /alipay/],
    ["wechat" /* BrowserType.WECHAT */, /micromessenger/],
    ["dingtalk" /* BrowserType.DING_TALK */, /dingtalk[ \/]([\d_.]+)/],
    ["baiduApp" /* BrowserType.BAIDU_APP */, /baiduboxapp/],
    ["baidu" /* BrowserType.BAIDU */, /baidubrowser/],
    ["baidu" /* BrowserType.BAIDU */, /bdbrowser/],
    ["uc" /* BrowserType.UC */, /ucbrowser/],
    ["uc" /* BrowserType.UC */, /ucweb/],
    ["qq" /* BrowserType.QQ */, /qqbrowser/],
    ["qqApp" /* BrowserType.QQ_APP */, /qq/],
    ["ie" /* BrowserType.IE */, /iemobile[ \/]([\d_.]+)/],
    // IE10- 所有版本都有的信息是 MSIE x.0
    ["ie" /* BrowserType.IE */, /msie[ \/]([\d_.]+)/],
    ["ie" /* BrowserType.IE */, /trident[ \/]([\d_.]+)/, 4],
    ["edge" /* BrowserType.EDGE */, /edge[ \/]([\d_.]+)/],
    ["newEdge" /* BrowserType.NEW_EDGE */, /edg[ \/]([\d_.]+)/],
    ["chrome" /* BrowserType.CHROME */, /chrome[ \/]([\d_.]+)/],
    ["firefox" /* BrowserType.FIREFOX */, /firefox[ \/]([\d_.]+)/],
    ["opera" /* BrowserType.OPERA */, /opera(?:.*version)?[ \/]([\d_.]+)/],
    ["safari" /* BrowserType.SAFARI */, /version[ \/]([\d_.]+) safari/],
    // 新版 Safari UA
    ["safari" /* BrowserType.SAFARI */, /version[ \/]([\d_.]+) \S* safari/],
    ["safari" /* BrowserType.SAFARI */, /safari/]
];
const getMajorVersionMap = {};
const checkVersionMap = {};
/**
 * 获取 UA 的结构化信息
 *
 * @inner
 * @param {string} ua
 * @return {Object}
 */
function parseUA(ua) {
    let name;
    let version;
    (0,_util_array__WEBPACK_IMPORTED_MODULE_1__.each)(list, (item) => {
        let match = item[1].exec(ua);
        if (match) {
            name = item[0];
            version = match[1];
            if (version) {
                version = version.replace(/_/g, '.');
                if (item[2]) {
                    version = (parseInt(version, 10) + item[2]) + '.0';
                }
            }
            return false;
        }
    });
    return {
        name: name || '',
        version: version || '',
        majorVersion: (getMajorVersionMap[name] || getMajorVersion)(version),
        checkVersion: checkVersionMap[name] || _function_checkVersion__WEBPACK_IMPORTED_MODULE_2__["default"]
    };
}
const browser = parseUA((typeof navigator === 'object' && navigator.userAgent || '').toLowerCase());
if (browser.name) {
    browser[browser.name] = true;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (browser);


/***/ }),

/***/ "./src/common/util/constant.ts":
/*!*************************************!*\
  !*** ./src/common/util/constant.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY_ARRAY: () => (/* binding */ EMPTY_ARRAY),
/* harmony export */   EMPTY_FUNCTION: () => (/* binding */ EMPTY_FUNCTION),
/* harmony export */   EMPTY_STRING: () => (/* binding */ EMPTY_STRING),
/* harmony export */   FALSE: () => (/* binding */ FALSE),
/* harmony export */   GLOBAL: () => (/* binding */ GLOBAL),
/* harmony export */   MINUS_ONE: () => (/* binding */ MINUS_ONE),
/* harmony export */   NULL: () => (/* binding */ NULL),
/* harmony export */   RAW_DOT: () => (/* binding */ RAW_DOT),
/* harmony export */   RAW_FUNCTION: () => (/* binding */ RAW_FUNCTION),
/* harmony export */   RAW_UNDEFINED: () => (/* binding */ RAW_UNDEFINED),
/* harmony export */   RAW_WILDCARD: () => (/* binding */ RAW_WILDCARD),
/* harmony export */   SELF: () => (/* binding */ SELF),
/* harmony export */   TRUE: () => (/* binding */ TRUE),
/* harmony export */   UNDEFINED: () => (/* binding */ UNDEFINED),
/* harmony export */   WINDOW: () => (/* binding */ WINDOW)
/* harmony export */ });
/* unused harmony exports RAW_TRUE, RAW_FALSE, RAW_NULL, RAW_THIS, RAW_VALUE, RAW_LENGTH, RAW_SLASH, RAW_TAG, KEYPATH_PARENT, KEYPATH_CURRENT, DOCUMENT, EMPTY_OBJECT */
/**
 * @file 为了压缩，定义的常量
 */
const TRUE = true;
const FALSE = false;
const NULL = null;
const UNDEFINED = void 0;
const MINUS_ONE = -1;
const RAW_TRUE = 'true';
const RAW_FALSE = 'false';
const RAW_NULL = 'null';
const RAW_UNDEFINED = 'undefined';
const RAW_THIS = 'this';
const RAW_VALUE = 'value';
const RAW_LENGTH = 'length';
const RAW_FUNCTION = 'function';
const RAW_WILDCARD = '*';
const RAW_DOT = '.';
const RAW_SLASH = '/';
const RAW_TAG = 'tag';
const KEYPATH_PARENT = '..';
const KEYPATH_CURRENT = RAW_THIS;
/**
 * Single instance for window in browser
 */
const WINDOW = typeof window !== RAW_UNDEFINED ? window : UNDEFINED;
/**
 * Single instance for document in browser
 */
const DOCUMENT = typeof document !== RAW_UNDEFINED ? document : UNDEFINED;
/**
 * Single instance for global in nodejs or browser
 */
// @ts-ignore
const GLOBAL = typeof globalThis !== RAW_UNDEFINED ? globalThis : (typeof __webpack_require__.g !== RAW_UNDEFINED ? __webpack_require__.g : WINDOW);
/**
 * Single instance for self in nodejs or browser
 */
// @ts-ignore
const SELF = typeof self !== RAW_UNDEFINED ? self : GLOBAL;
/**
 * Single instance for noop function
 */
const EMPTY_FUNCTION = function () {
    /** common */
};
/**
 * 空对象，很多地方会用到，比如 `a || EMPTY_OBJECT` 确保是个对象
 */
const EMPTY_OBJECT = Object.freeze({});
/**
 * 空数组
 */
const EMPTY_ARRAY = Object.freeze([]);
/**
 * 空字符串
 */
const EMPTY_STRING = '';


/***/ }),

/***/ "./src/common/util/is.ts":
/*!*******************************!*\
  !*** ./src/common/util/is.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   array: () => (/* binding */ array),
/* harmony export */   arrayBuffer: () => (/* binding */ arrayBuffer),
/* harmony export */   bigint: () => (/* binding */ bigint),
/* harmony export */   boolean: () => (/* binding */ boolean),
/* harmony export */   func: () => (/* binding */ func),
/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),
/* harmony export */   number: () => (/* binding */ number),
/* harmony export */   numeric: () => (/* binding */ numeric),
/* harmony export */   object: () => (/* binding */ object),
/* harmony export */   string: () => (/* binding */ string)
/* harmony export */ });
/* unused harmony export range */
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/**
 * @file 判断
 */

/**
 * Check if value is a function.
 *
 * @param value
 * @return
 */
function func(value) {
    return typeof value === _constant__WEBPACK_IMPORTED_MODULE_0__.RAW_FUNCTION;
}
/**
 * Check if value is an array.
 *
 * @param value
 * @return
 */
function array(value) {
    return Array.isArray(value);
}
/**
 * Check if value is an object.
 *
 * @param value
 * @return
 */
function object(value) {
    // 低版本 IE 会把 null 当作 object
    return value !== _constant__WEBPACK_IMPORTED_MODULE_0__.NULL && typeof value === 'object';
}
/**
 * Check if value is a string.
 *
 * @param value
 * @return
 */
function string(value) {
    return typeof value === 'string';
}
/**
 * Check if value is a number.
 *
 * @param value
 * @return
 */
function number(value) {
    return typeof value === 'number' && !isNaN(value);
}
/**
 * Check if value is a bigint.
 *
 * @param value
 * @return
 */
function bigint(value) {
    return typeof value === 'bigint';
}
/**
 * Check if value is boolean.
 *
 * @param value
 * @return
 */
function boolean(value) {
    return typeof value === 'boolean';
}
/**
 * Check if value is numeric.
 *
 * @param value
 * @return
 */
function numeric(value) {
    return number(value)
        || (string(value) && !isNaN(parseFloat(value)) && isFinite(+value));
}
const hasOwn = {}.hasOwnProperty;
/**
 * 判断是不是普通字面量对象
 *
 * @param {*} target
 * @return {boolean}
 */
function isPlainObject(target) {
    if (!object(target) || target.nodeType || target === target.window) {
        return false;
    }
    if (target.constructor
        && !hasOwn.call(target, 'constructor')
        && !hasOwn.call(target.constructor.prototype || {}, 'isPrototypeOf')) {
        return false;
    }
    let key;
    for (key in target) {
        /* empty */
    }
    return key === undefined || hasOwn.call(target, key);
}
/**
 * 判断 value 是否在指定范围中
 *
 * @param value 待判断值
 * @param min 范围左区间
 * @param max 范围右区间
 */
function range(value, min, max) {
    return value >= min && value <= max;
}
/**
 * Check if value is ArrayBuffer.
 *
 * @param value
 * @returns
 */
function arrayBuffer(value) {
    return value instanceof ArrayBuffer;
}


/***/ }),

/***/ "./src/common/util/keypath.ts":
/*!************************************!*\
  !*** ./src/common/util/keypath.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   each: () => (/* binding */ each)
/* harmony export */ });
/* unused harmony exports match, join, isFuzzy, matchFuzzy, rootPath */
/* harmony import */ var _string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string */ "./src/common/util/string.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/**
 * @file 路径操作
 */


const dotPattern = /\./g, asteriskPattern = /\*/g, doubleAsteriskPattern = /\*\*/g, splitCache = {}, patternCache = {};
/**
 * 判断 keypath 是否以 prefix 开头，如果是，返回匹配上的前缀长度，否则返回 -1
 *
 * @param keypath
 * @param prefix
 * @return
 */
function match(keypath, prefix) {
    if (keypath === prefix) {
        return prefix.length;
    }
    prefix += _constant__WEBPACK_IMPORTED_MODULE_0__.RAW_DOT;
    return _string__WEBPACK_IMPORTED_MODULE_1__.startsWith(keypath, prefix)
        ? prefix.length
        : _constant__WEBPACK_IMPORTED_MODULE_0__.MINUS_ONE;
}
/**
 * 遍历 keypath 的每个部分
 *
 * @param keypath
 * @param callback 返回 false 可中断遍历
 */
function each(keypath, callback) {
    /*
     * 如果 keypath 是 toString 之类的原型字段
     * splitCache[keypath] 会取到原型链上的对象
     */
    const list = splitCache.hasOwnProperty(keypath)
        ? splitCache[keypath]
        : (splitCache[keypath] = keypath.split(_constant__WEBPACK_IMPORTED_MODULE_0__.RAW_DOT));
    for (let i = 0, lastIndex = list.length - 1; i <= lastIndex; i++) {
        if (callback(list[i], i === lastIndex) === _constant__WEBPACK_IMPORTED_MODULE_0__.FALSE) {
            break;
        }
    }
}
/**
 * 路径组合
 *
 * @param keypath1
 * @param keypath2
 */
function join(keypath1, keypath2) {
    return keypath1 && keypath2
        ? keypath1 + _constant__WEBPACK_IMPORTED_MODULE_0__.RAW_DOT + keypath2
        : keypath1 || keypath2;
}
/**
 * 是否是模糊匹配
 *
 * @param keypath
 */
function isFuzzy(keypath) {
    return _string__WEBPACK_IMPORTED_MODULE_1__.has(keypath, _constant__WEBPACK_IMPORTED_MODULE_0__.RAW_WILDCARD);
}
/**
 * 模糊匹配 keypath
 *
 * @param keypath 待匹配路径
 * @param pattern 匹配规则
 */
function matchFuzzy(keypath, pattern) {
    let cache = patternCache[pattern];
    if (!cache) {
        const str = pattern
            .replace(dotPattern, '\\.')
            .replace(asteriskPattern, '(\\w+)')
            .replace(doubleAsteriskPattern, '([\.\\w]+?)');
        cache = patternCache[pattern] = new RegExp(`^${str}$`);
    }
    const result = keypath.match(cache);
    if (result) {
        return result[1];
    }
}
/**
 * 返回 keypath 的根路径
 *
 * @param keypath
 */
function rootPath(keypath) {
    return keypath && keypath.split(_constant__WEBPACK_IMPORTED_MODULE_0__.RAW_DOT).shift();
}


/***/ }),

/***/ "./src/common/util/logger.ts":
/*!***********************************!*\
  !*** ./src/common/util/logger.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   INFO: () => (/* binding */ INFO),
/* harmony export */   debug: () => (/* binding */ debug),
/* harmony export */   error: () => (/* binding */ error),
/* harmony export */   fatal: () => (/* binding */ fatal),
/* harmony export */   info: () => (/* binding */ info),
/* harmony export */   setLevel: () => (/* binding */ setLevel),
/* harmony export */   warn: () => (/* binding */ warn)
/* harmony export */ });
/* unused harmony exports TRACE, DEBUG, WARN, ERROR, FATAL, trace, log, enableUploadLog, disableUploadLog, canUploadLog, setUploadLevel, getUploadLevel */
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/* harmony import */ var _function_toString__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../function/toString */ "./src/common/function/toString.ts");
/**
 * @file 日志
 */


const TRACE = 0;
const DEBUG = 1;
const INFO = 2;
const WARN = 3;
const ERROR = 4;
const FATAL = 5;
const nativeConsole = typeof console !== _constant__WEBPACK_IMPORTED_MODULE_0__.RAW_UNDEFINED ? console : _constant__WEBPACK_IMPORTED_MODULE_0__.NULL, 
/**
 * 当前是否是源码调试，如果开启了代码压缩，empty function 里的注释会被干掉
 */
defaultLogLevel = /common/.test((0,_function_toString__WEBPACK_IMPORTED_MODULE_1__["default"])(_constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_FUNCTION)) ? INFO : WARN, 
/**
 * console 样式前缀
 * ie 和 edge 不支持 console.log 样式
 */
stylePrefix = _constant__WEBPACK_IMPORTED_MODULE_0__.WINDOW && /edge|msie|trident/i.test(_constant__WEBPACK_IMPORTED_MODULE_0__.WINDOW.navigator.userAgent) || true
    ? _constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_STRING
    : 0, 
/**
 * 日志打印函数
 */
printLog = nativeConsole
    ? stylePrefix
        ? function (tag, msg, style) {
            nativeConsole.log(stylePrefix + tag, style, msg);
        }
        : function (tag, msg) {
            nativeConsole.log(tag, msg);
        }
    : _constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_FUNCTION;
/**
 * 全局调试开关
 */
function getLogLevel() {
    if (_constant__WEBPACK_IMPORTED_MODULE_0__.GLOBAL) {
        const logLevel = _constant__WEBPACK_IMPORTED_MODULE_0__.SELF['COMMON_LOG_LEVEL'];
        if (logLevel >= TRACE && logLevel <= FATAL) {
            return logLevel;
        }
    }
    return defaultLogLevel;
}
/**
 * 设置日志输出级别
 *
 * @param level 日志输出级别
 */
function setLevel(level) {
    _constant__WEBPACK_IMPORTED_MODULE_0__.SELF['COMMON_LOG_LEVEL'] = level;
}
function getStyle(backgroundColor) {
    return `background-color:${backgroundColor};border-radius:12px;color:#fff;font-size:10px;padding:3px 6px;`;
}
function trace(msg, file, line) {
    if (getLogLevel() <= TRACE) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [trace]`, msg, getStyle('#999'));
    }
}
function debug(msg, file, line) {
    if (getLogLevel() <= DEBUG) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [debug]`, msg, getStyle('#999'));
    }
}
function info(msg, file, line) {
    if (getLogLevel() <= INFO) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [info]`, msg, getStyle('#2db7f5'));
    }
}
function warn(msg, file, line) {
    if (getLogLevel() <= WARN) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [warn]`, msg, getStyle('#f90'));
    }
}
function error(msg, file, line) {
    if (getLogLevel() <= ERROR) {
        printLog(`[${arguments[1]}][line ${arguments[2]}] [error]`, msg, getStyle('#ed4014'));
    }
}
function fatal(msg, file, line) {
    if (getLogLevel() <= FATAL) {
        error(msg, file, line);
        throw new Error(`[${arguments[1]}][line ${arguments[2]}] [fatal]: ${msg}`);
    }
}
function log(level, msg, file, line) {
    if (level === TRACE) {
        trace(msg, arguments[2], arguments[3]);
    }
    else if (level === DEBUG) {
        debug(msg, arguments[2], arguments[3]);
    }
    else if (level === INFO) {
        info(msg, arguments[2], arguments[3]);
    }
    else if (level === WARN) {
        warn(msg, arguments[2], arguments[3]);
    }
    else if (level === ERROR) {
        error(msg, arguments[2], arguments[3]);
    }
    else if (level === FATAL) {
        fatal(msg, arguments[2], arguments[3]);
    }
}
/**
 * @internal
 * 是否上传，全局配置
 */
let enableUpload = true;
/**
 * @internal
 * 日志上传等级，全局配置
 */
let uploadLevel = WARN;
/**
 * 打开日志上传
 *
 */
function enableUploadLog() {
    enableUpload = true;
}
/**
 * 关闭日志上传
 */
function disableUploadLog() {
    enableUpload = false;
}
/**
 * 是否可以上传日志
 */
function canUploadLog() {
    return enableUpload;
}
/**
 * 设置日志上传等级
 */
function setUploadLevel(level) {
    uploadLevel = level;
}
/**
 * 获取日志上传等级
 */
function getUploadLevel() {
    return uploadLevel;
}


/***/ }),

/***/ "./src/common/util/object.ts":
/*!***********************************!*\
  !*** ./src/common/util/object.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   each: () => (/* binding */ each),
/* harmony export */   extend: () => (/* binding */ extend),
/* harmony export */   has: () => (/* binding */ has),
/* harmony export */   param: () => (/* binding */ param)
/* harmony export */ });
/* unused harmony exports keys, sort, clear, merge, get, set, falsy, diff, toArray, update */
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is */ "./src/common/util/is.ts");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./array */ "./src/common/util/array.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/* harmony import */ var _keypath__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keypath */ "./src/common/util/keypath.ts");
/* harmony import */ var _function_isDef__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../function/isDef */ "./src/common/function/isDef.ts");
/**
 * @file 对象操作
 */





/**
 * 获取对象的 key 的数组
 *
 * @param object
 * @return
 */
function keys(object) {
    if (!(0,_function_isDef__WEBPACK_IMPORTED_MODULE_0__["default"])(object)) {
        return [];
    }
    return Object.keys(object);
}
function sortKeyByAsc(a, b) {
    return a.length - b.length;
}
function sortKeyByDesc(a, b) {
    return b.length - a.length;
}
/**
 * 排序对象的 key
 *
 * @param object
 * @param desc 是否逆序，默认从小到大排序
 * @return
 */
function sort(object, desc) {
    return keys(object).sort(desc ? sortKeyByDesc : sortKeyByAsc);
}
/**
 * 遍历对象
 *
 * @param object
 * @param callback 返回 false 可停止遍历
 */
function each(object, callback) {
    for (let key in object) {
        if (callback(object[key], key) === _constant__WEBPACK_IMPORTED_MODULE_1__.FALSE) {
            break;
        }
    }
}
/**
 * 清空对象所有的键值对
 *
 * @param object
 */
function clear(object) {
    each(object, function (_, key) {
        delete object[key];
    });
}
function _extend(original, object) {
    if (!_is__WEBPACK_IMPORTED_MODULE_2__.object(original)) {
        return object;
    }
    else if (!_is__WEBPACK_IMPORTED_MODULE_2__.object(object)) {
        return original;
    }
    each(object, function (value, key) {
        original[key] = value;
    });
    return original;
}
/**
 * 扩展对象
 *
 * @return
 */
function extend(original, object, object2) {
    return _extend(_extend(original, object), object2);
}
/**
 * 合并对象
 *
 * @return
 */
function merge(object1, object2) {
    return object1 && object2
        ? extend(extend({}, object1), object2)
        : object1 || object2;
}
/**
 * 拷贝对象
 *
 * @param object
 * @param deep 是否需要深拷贝
 * @return
 */
function copy(object, deep) {
    let result = object;
    if (_is__WEBPACK_IMPORTED_MODULE_2__.array(object)) {
        if (deep) {
            result = [];
            _array__WEBPACK_IMPORTED_MODULE_3__.each(object, function (item, index) {
                result[index] = copy(item, deep);
            });
        }
        else {
            result = object.slice();
        }
    }
    else if (_is__WEBPACK_IMPORTED_MODULE_2__.object(object)) {
        result = {};
        each(object, function (value, key) {
            result[key] = deep ? copy(value, deep) : value;
        });
    }
    return result;
}
/**
 * 从对象中查找一个 keypath
 *
 * 返回值是空时，表示没找到值
 *
 * @param object
 * @param keypath
 * @return
 */
function get(object, keypath, defaultValue) {
    let result;
    _keypath__WEBPACK_IMPORTED_MODULE_4__.each(keypath, function (key, isLast) {
        if (object != _constant__WEBPACK_IMPORTED_MODULE_1__.NULL) {
            // 先直接取值
            let value = object[key], 
            // 紧接着判断值是否存在
            hasValue = value !== _constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED;
            if (isLast) {
                if (hasValue) {
                    result = value;
                }
                else {
                    result = _constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED;
                }
            }
            else {
                object = value;
            }
        }
        else {
            result = _constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED;
            return _constant__WEBPACK_IMPORTED_MODULE_1__.FALSE;
        }
    });
    // 没找到使用默认值
    if (result === _constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED) {
        result = defaultValue;
    }
    return result;
}
/**
 * 为对象设置一个键值对
 *
 * @param object
 * @param keypath
 * @param value
 * @param autofill 是否自动填充不存在的对象，默认自动填充
 */
function set(object, keypath, value, autofill) {
    _keypath__WEBPACK_IMPORTED_MODULE_4__.each(keypath, function (key, isLast) {
        if (isLast) {
            object[key] = value;
        }
        else if (object[key]) {
            object = object[key];
        }
        else if (autofill) {
            object = object[key] = {};
        }
        else {
            return _constant__WEBPACK_IMPORTED_MODULE_1__.FALSE;
        }
    });
}
/**
 * 对象是否包含某个 key
 *
 * @param object
 * @param key
 * @return
 */
function has(object, key) {
    // 不用 hasOwnProperty，性能差
    return object[key] !== _constant__WEBPACK_IMPORTED_MODULE_1__.UNDEFINED;
}
/**
 * 是否是空对象
 *
 * @param object
 * @return
 */
function falsy(object) {
    return !_is__WEBPACK_IMPORTED_MODULE_2__.object(object)
        || _is__WEBPACK_IMPORTED_MODULE_2__.array(object)
        || !keys(object).length;
}
/**
 * 获取两个对象的 value 不同的 key
 *
 * @param obj1
 * @param obj2
 */
function diff(obj1, obj2) {
    let differences = [];
    each(obj1, (value, key) => {
        if (_is__WEBPACK_IMPORTED_MODULE_2__.array(value) || _is__WEBPACK_IMPORTED_MODULE_2__.isPlainObject(value)) {
            if (obj2[key] == null || diff(value, obj2[key]).length > 0) {
                differences.push(key);
            }
        }
        else if (value !== obj2[key]) {
            differences.push(key);
        }
    });
    return differences;
}
/**
 * 序列化对象
 *
 * @param data
 */
function param(data) {
    let result = [];
    const add = (key, value) => {
        value = _is__WEBPACK_IMPORTED_MODULE_2__.func(value) ? value() : (value == null ? '' : value);
        result[result.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
    };
    if (_is__WEBPACK_IMPORTED_MODULE_2__.array(data) || _is__WEBPACK_IMPORTED_MODULE_2__.isPlainObject(data)) {
        if (_is__WEBPACK_IMPORTED_MODULE_2__.array(data)) {
            _array__WEBPACK_IMPORTED_MODULE_3__.each(data, (value, key) => {
                add(key, value);
            });
        }
        else {
            each(data, (value, key) => {
                add(key, value);
            });
        }
    }
    return result.join('&').replace(/%20/g, '+');
}
/**
 * 将 object 的 value 变成数组
 */
function toArray(data) {
    const result = [];
    each(data, (value) => {
        result.push(value);
    });
    return result;
}
/**
 *
 * 更新两个同一类型的对象
 *
 * @param obj1
 * @param obj2
 * @returns
 */
function update(obj1, obj2) {
    if (!_is__WEBPACK_IMPORTED_MODULE_2__.object(obj1) || !_is__WEBPACK_IMPORTED_MODULE_2__.object(obj2)) {
        return;
    }
    each(obj2, (value, key) => {
        if (_is__WEBPACK_IMPORTED_MODULE_2__.object(value) && _is__WEBPACK_IMPORTED_MODULE_2__.object(obj1[key])) {
            update(obj1[key], value);
        }
        else {
            obj1[key] = obj2[key];
        }
    });
    return obj1;
}


/***/ }),

/***/ "./src/common/util/string.ts":
/*!***********************************!*\
  !*** ./src/common/util/string.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   has: () => (/* binding */ has),
/* harmony export */   indexOf: () => (/* binding */ indexOf),
/* harmony export */   slice: () => (/* binding */ slice),
/* harmony export */   startsWith: () => (/* binding */ startsWith)
/* harmony export */ });
/* unused harmony exports capitalize, trim, lastIndexOf, endsWith, charAt, codeAt, upper, lower, falsy */
/* harmony import */ var _is__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is */ "./src/common/util/is.ts");
/* harmony import */ var _constant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant */ "./src/common/util/constant.ts");
/* harmony import */ var _function_toString__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/toString */ "./src/common/function/toString.ts");
/**
 * @file string 操作
 */



const capitalizePattern = /^[a-z]/, capitalizeCache = {};
/**
 * 首字母大写
 *
 * @param str
 * @return
 */
function capitalize(str) {
    if (!capitalizeCache[str]) {
        capitalizeCache[str] = str.replace(capitalizePattern, upper);
    }
    return capitalizeCache[str];
}
/**
 * 清除两侧空白符
 *
 * @param str
 * @return 清除两侧空白符的字符串
 */
function trim(str) {
    return falsy(str)
        ? _constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_STRING
        : str.trim();
}
/**
 * 截取字符串
 *
 * @param str
 * @param start
 * @param end
 * @return
 */
function slice(str, start, end) {
    return _is__WEBPACK_IMPORTED_MODULE_1__.number(end)
        ? start === end
            ? _constant__WEBPACK_IMPORTED_MODULE_0__.EMPTY_STRING
            : str.slice(start, end)
        : str.slice(start);
}
/**
 * 获取子串的起始位置
 *
 * @param str
 * @param part
 * @param start
 * @return
 */
function indexOf(str, part, start) {
    return str.indexOf(part, start !== _constant__WEBPACK_IMPORTED_MODULE_0__.UNDEFINED ? start : 0);
}
/**
 * 获取子串的起始位置
 *
 * @param str
 * @param part
 * @param end
 * @return
 */
function lastIndexOf(str, part, end) {
    return str.lastIndexOf(part, end !== _constant__WEBPACK_IMPORTED_MODULE_0__.UNDEFINED ? end : str.length);
}
/**
 * str 是否以 part 开头
 *
 * @param str
 * @param part
 * @return
 */
function startsWith(str, part) {
    return indexOf(str, part) === 0;
}
/**
 * str 是否以 part 结束
 *
 * @param str
 * @param part
 * @return
 */
function endsWith(str, part) {
    const offset = str.length - part.length;
    return offset >= 0 && lastIndexOf(str, part) === offset;
}
/**
 * 获取某个位置的字符
 */
function charAt(str, index) {
    return str.charAt(index || 0);
}
/**
 * 获取某个位置的字符编码
 */
function codeAt(str, index) {
    return str.charCodeAt(index || 0);
}
/**
 * 大写格式
 */
function upper(str) {
    return str.toUpperCase();
}
/**
 * 小写格式
 */
function lower(str) {
    return str.toLowerCase();
}
/**
 * str 是否包含 part
 *
 * @param str
 * @param part
 * @return 是否包含
 */
function has(str, part) {
    return indexOf(str, part) >= 0;
}
/**
 * 判断长度大于 0 的字符串
 *
 * @param str
 * @return
 */
function falsy(str) {
    return !_is__WEBPACK_IMPORTED_MODULE_1__.string(str) || !str.length;
}
/**
 * 格式化输出
 *
 * @param string
 * @param args
 * @returns
 */
function format(string, ...args) {
    let i = 0;
    const length = args.length;
    return string.replace(/(%[sdvx%])|(%0(\d)+[dx])/g, (str) => {
        if (i >= length) {
            // missing argument
            return str;
        }
        const arg = args[i++];
        if (/%0(\d)+[dx]/g.test(str)) {
            const length = parseInt(str.substring(1));
            let result = str[str.length - 1] === 'd' ? (0,_function_toString__WEBPACK_IMPORTED_MODULE_2__["default"])(Number(arg)) : Number(arg).toString(16);
            if (length > result.length) {
                result = new Array(length - result.length).fill('0').join('') + result;
            }
            return result;
        }
        switch (str) {
            case '%%':
                return '%';
            case '%s':
                return String(arg);
            case '%d':
                return (0,_function_toString__WEBPACK_IMPORTED_MODULE_2__["default"])(Number(arg));
            case '%v':
                return '';
            case '%x':
                return Number(arg).toString(16);
        }
        return str;
    });
}


/***/ }),

/***/ "./src/common/util/support.ts":
/*!************************************!*\
  !*** ./src/common/util/support.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browser */ "./src/common/util/browser.ts");

function supportedFeatures() {
    let blob = typeof Blob === 'function';
    let wasm = typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function';
    let fetchSupported = typeof fetch === 'function';
    let documentSupport = typeof document === 'object';
    let canvas = documentSupport && document.createElement('canvas');
    let webgl = canvas && !!canvas.getContext('webgl');
    let offscreenCanvas = typeof OffscreenCanvas === 'function';
    let worker = typeof Worker === 'function';
    let arrayBuffer = typeof ArrayBuffer === 'function';
    let atomics = typeof Atomics === 'object';
    let audioContext = typeof AudioContext === 'function' || typeof webkitAudioContext === 'function';
    let audioWorklet = typeof AudioWorklet === 'function';
    let videoDecoder = typeof VideoDecoder === 'function';
    let videoEncoder = typeof VideoEncoder === 'function';
    let audioDecoder = typeof AudioDecoder === 'function';
    let audioEncoder = typeof AudioEncoder === 'function';
    let shareArrayBuffer = typeof SharedArrayBuffer === 'function';
    let mse = typeof MediaSource == 'function' || typeof ManagedMediaSource === 'function';
    let proxy = typeof Proxy === 'function';
    let thread = worker && shareArrayBuffer && atomics && proxy;
    // safari 低于 11 不支持
    if (_browser__WEBPACK_IMPORTED_MODULE_0__["default"].safari && !_browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '11', true)) {
        wasm = false;
    }
    // chrome 94 以上才支持 webcodec
    if (_browser__WEBPACK_IMPORTED_MODULE_0__["default"].chrome && !_browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '94', true)) {
        videoDecoder = false;
        audioDecoder = false;
    }
    // safari 17 之前渲染 VideoFrame 有问题
    if (_browser__WEBPACK_IMPORTED_MODULE_0__["default"].safari && !_browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '17', true)) {
        videoDecoder = false;
    }
    let webgpu = typeof navigator === 'object' && typeof navigator.gpu === 'object';
    let workerMSE = typeof MediaSourceHandle === 'function';
    let webAssemblyGlobal = wasm && typeof WebAssembly.Global === 'function';
    return {
        browser: _browser__WEBPACK_IMPORTED_MODULE_0__["default"],
        blob,
        wasm,
        fetch: fetchSupported,
        webgl,
        worker,
        mse,
        arrayBuffer,
        audioContext,
        audioWorklet,
        videoDecoder,
        videoEncoder,
        audioDecoder,
        audioEncoder,
        atomics,
        shareArrayBuffer,
        thread,
        webgpu,
        offscreenCanvas,
        workerMSE,
        webAssemblyGlobal,
        proxy,
        simd: (_browser__WEBPACK_IMPORTED_MODULE_0__["default"].chrome || _browser__WEBPACK_IMPORTED_MODULE_0__["default"].newEdge) && _browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '91', true)
            || _browser__WEBPACK_IMPORTED_MODULE_0__["default"].firefox && _browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_0__["default"].majorVersion, '89', true)
            || _browser__WEBPACK_IMPORTED_MODULE_0__["default"].safari && _browser__WEBPACK_IMPORTED_MODULE_0__["default"].checkVersion(_browser__WEBPACK_IMPORTED_MODULE_0__["default"].version, '16.4', true),
        wasmBaseSupported: fetchSupported && wasm && webgl && audioContext && arrayBuffer && webAssemblyGlobal
    };
}
const support = supportedFeatures();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (support);


/***/ }),

/***/ "./src/common/util/text.ts":
/*!*********************************!*\
  !*** ./src/common/util/text.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   encode: () => (/* binding */ encode)
/* harmony export */ });
const encoder = typeof TextEncoder === 'function' ? new TextEncoder() : null;
const decoder = typeof TextDecoder === 'function' ? new TextDecoder() : null;
function encode(data) {
    if (encoder) {
        return encoder.encode(data);
    }
    const array = [];
    for (let i = 0; i < data.length; ++i) {
        let u = data.charCodeAt(i);
        if (u >= 55296 && u <= 57343) {
            let u1 = data.charCodeAt(++i);
            u = 65536 + ((u & 1023) << 10) | u1 & 1023;
        }
        if (u <= 127) {
            array.push(u);
        }
        else if (u <= 2047) {
            array.push(192 | u >> 6);
            array.push(128 | u & 63);
        }
        else if (u <= 65535) {
            array.push(224 | u >> 12);
            array.push(128 | u >> 6 & 63);
            array.push(128 | u & 63);
        }
        else {
            array.push(240 | u >> 18);
            array.push(128 | u >> 12 & 63);
            array.push(128 | u >> 6 & 63);
            array.push(128 | u & 63);
        }
    }
    return new Uint8Array(array);
}
function decode(data) {
    if (data instanceof Uint8Array && decoder && !(typeof SharedArrayBuffer === 'function' && data.buffer instanceof SharedArrayBuffer)) {
        return decoder.decode(data);
    }
    let result = '';
    for (let i = 0; i < data.length;) {
        let u0 = data[i++ >>> 0];
        if (!(u0 & 128)) {
            result += String.fromCharCode(u0);
            continue;
        }
        let u1 = data[i++ >>> 0] & 63;
        if ((u0 & 224) == 192) {
            result += String.fromCharCode((u0 & 31) << 6 | u1);
            continue;
        }
        let u2 = data[i++ >>> 0] & 63;
        if ((u0 & 240) == 224) {
            u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        }
        else {
            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | data[i++ >>> 0] & 63;
        }
        if (u0 < 65536) {
            result += String.fromCharCode(u0);
        }
        else {
            let ch = u0 - 65536;
            result += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
    }
    return result;
}


/***/ }),

/***/ "./src/common/util/url.ts":
/*!********************************!*\
  !*** ./src/common/util/url.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildAbsoluteURL: () => (/* binding */ buildAbsoluteURL),
/* harmony export */   parse: () => (/* binding */ parse)
/* harmony export */ });
/* unused harmony exports parseQuery, stringifyQuery, mixin, normalizePath */
/* harmony import */ var _util_is__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/is */ "./src/common/util/is.ts");
/* harmony import */ var _function_split__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../function/split */ "./src/common/function/split.ts");
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/array */ "./src/common/util/array.ts");
/* harmony import */ var _util_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util/object */ "./src/common/util/object.ts");
/**
 * @file url 操作
 */




/**
 * 把查询字符串解析成对象
 * @param queryStr
 */
function parseQuery(queryStr, separator = '&') {
    const result = {};
    if (_util_is__WEBPACK_IMPORTED_MODULE_0__.string(queryStr) && queryStr.indexOf('=') >= 0) {
        let firstChar = queryStr.charAt(0);
        let startIndex = (firstChar === '?' || firstChar === '#') ? 1 : 0;
        if (startIndex > 0) {
            queryStr = queryStr.substr(startIndex);
        }
        _util_array__WEBPACK_IMPORTED_MODULE_1__.each((0,_function_split__WEBPACK_IMPORTED_MODULE_2__["default"])(queryStr, separator), (item) => {
            let terms = item.split('=');
            if (terms.length === 2) {
                let key = terms[0]?.trim();
                if (key) {
                    result[key] = decodeURIComponent(terms[1]);
                }
            }
        });
    }
    return result;
}
/**
 * 把对象序列化成查询字符串
 *
 * @param query
 * @return
 */
function stringifyQuery(query, separator = '&') {
    const result = [];
    if (_util_is__WEBPACK_IMPORTED_MODULE_0__.isPlainObject(query)) {
        _util_object__WEBPACK_IMPORTED_MODULE_3__.each(query, (value, key) => {
            result.push(key + '=' + encodeURIComponent(_util_is__WEBPACK_IMPORTED_MODULE_0__.object(value) ? JSON.stringify(value) : value));
        });
    }
    return result.join(separator);
}
/**
 * 解析 url，返回格式遵循 location 属性的命名
 *
 * @param url 如果不传，使用当前地址
 */
function parse(url) {
    const key = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];
    const parser = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
    const result = {};
    const m = parser.exec(url);
    let i = 14;
    while (i--) {
        result[key[i]] = m[i] ?? '';
    }
    return {
        protocol: result.protocol,
        file: result.file,
        host: result.host,
        port: result.port,
        user: result.user,
        password: result.password,
        origin: `${result.protocol}://${result.authority}`,
        pathname: result.path,
        search: `?${result.query}`,
        hash: result.anchor ? `#${result.anchor}` : ''
    };
}
/**
 * 把参数混入一个 url
 *
 * @param query
 * @param url
 * @param applyHash
 */
function mixin(query, applyHash, url) {
    if (url == null) {
        url = document.URL;
    }
    let scheme = parse(url);
    let params = parseQuery(applyHash ? scheme.hash : scheme.search);
    _util_object__WEBPACK_IMPORTED_MODULE_3__.extend(params, query);
    params = _util_object__WEBPACK_IMPORTED_MODULE_3__.param(params);
    url = scheme.origin + scheme.pathname;
    if (applyHash) {
        url += scheme.search;
    }
    else if (params) {
        url += '?' + params;
    }
    if (!applyHash) {
        url += scheme.hash;
    }
    else if (params) {
        url += '#' + params;
    }
    return url;
}
const SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
const SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
const FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
const URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
function buildURLFromParts(parts) {
    return (parts.scheme +
        parts.netLoc +
        parts.path +
        parts.params +
        parts.query +
        parts.fragment);
}
function parseURL(url) {
    const parts = URL_REGEX.exec(url);
    if (!parts) {
        return null;
    }
    return {
        scheme: parts[1] || '',
        netLoc: parts[2] || '',
        path: parts[3] || '',
        params: parts[4] || '',
        query: parts[5] || '',
        fragment: parts[6] || ''
    };
}
function normalizePath(path) {
    // The following operations are
    // then applied, in order, to the new path:
    // 6a) All occurrences of "./", where "." is a complete path
    // segment, are removed.
    // 6b) If the path ends with "." as a complete path segment,
    // that "." is removed.
    path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');
    // 6c) All occurrences of "<segment>/../", where <segment> is a
    // complete path segment not equal to "..", are removed.
    // Removal of these path segments is performed iteratively,
    // removing the leftmost matching pattern on each iteration,
    // until no matching pattern remains.
    // 6d) If the path ends with "<segment>/..", where <segment> is a
    // complete path segment not equal to "..", that
    // "<segment>/.." is removed.
    while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length) { }
    return path.split('').reverse().join('');
}
/**
 * from https://github.com/tjenkinson/url-toolkit
 *
 */
function buildAbsoluteURL(baseURL, relativeURL, opts) {
    opts = opts || {};
    // remove any remaining space and CRLF
    baseURL = baseURL.trim();
    relativeURL = relativeURL.trim();
    if (!relativeURL) {
        // 2a) If the embedded URL is entirely empty, it inherits the
        // entire base URL (i.e., is set equal to the base URL)
        // and we are done.
        if (!opts.alwaysNormalize) {
            return baseURL;
        }
        let basePartsForNormalize = parseURL(baseURL);
        if (!basePartsForNormalize) {
            throw new Error('Error trying to parse base URL.');
        }
        basePartsForNormalize.path = normalizePath(basePartsForNormalize.path);
        return buildURLFromParts(basePartsForNormalize);
    }
    let relativeParts = parseURL(relativeURL);
    if (!relativeParts) {
        throw new Error('Error trying to parse relative URL.');
    }
    if (relativeParts.scheme) {
        // 2b) If the embedded URL starts with a scheme name, it is
        // interpreted as an absolute URL and we are done.
        if (!opts.alwaysNormalize) {
            return relativeURL;
        }
        relativeParts.path = normalizePath(relativeParts.path);
        return buildURLFromParts(relativeParts);
    }
    let baseParts = parseURL(baseURL);
    if (!baseParts) {
        throw new Error('Error trying to parse base URL.');
    }
    if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {
        // If netLoc missing and path doesn't start with '/', assume everything before the first '/' is the netLoc
        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'
        let pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
        baseParts.netLoc = pathParts[1];
        baseParts.path = pathParts[2];
    }
    if (baseParts.netLoc && !baseParts.path) {
        baseParts.path = '/';
    }
    const builtParts = {
        // 2c) Otherwise, the embedded URL inherits the scheme of
        // the base URL.
        scheme: baseParts.scheme,
        netLoc: relativeParts.netLoc,
        path: null,
        params: relativeParts.params,
        query: relativeParts.query,
        fragment: relativeParts.fragment,
    };
    if (!relativeParts.netLoc) {
        // 3) If the embedded URL's <net_loc> is non-empty, we skip to
        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>
        // (if any) of the base URL.
        builtParts.netLoc = baseParts.netLoc;
        // 4) If the embedded URL path is preceded by a slash "/", the
        // path is not relative and we skip to Step 7.
        if (relativeParts.path[0] !== '/') {
            if (!relativeParts.path) {
                // 5) If the embedded URL path is empty (and not preceded by a
                // slash), then the embedded URL inherits the base URL path
                builtParts.path = baseParts.path;
                // 5a) if the embedded URL's <params> is non-empty, we skip to
                // step 7; otherwise, it inherits the <params> of the base
                // URL (if any) and
                if (!relativeParts.params) {
                    builtParts.params = baseParts.params;
                    // 5b) if the embedded URL's <query> is non-empty, we skip to
                    // step 7; otherwise, it inherits the <query> of the base
                    // URL (if any) and we skip to step 7.
                    if (!relativeParts.query) {
                        builtParts.query = baseParts.query;
                    }
                }
            }
            else {
                // 6) The last segment of the base URL's path (anything
                // following the rightmost slash "/", or the entire path if no
                // slash is present) is removed and the embedded URL's path is
                // appended in its place.
                let baseURLPath = baseParts.path;
                let newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +
                    relativeParts.path;
                builtParts.path = normalizePath(newPath);
            }
        }
    }
    if (builtParts.path === null) {
        builtParts.path = opts.alwaysNormalize
            ? normalizePath(relativeParts.path)
            : relativeParts.path;
    }
    return buildURLFromParts(builtParts);
}


/***/ }),

/***/ "./src/common/util/wasm.ts":
/*!*********************************!*\
  !*** ./src/common/util/wasm.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readSLeb128Async: () => (/* binding */ readSLeb128Async),
/* harmony export */   readULeb128Async: () => (/* binding */ readULeb128Async),
/* harmony export */   setMemoryShared: () => (/* binding */ setMemoryShared),
/* harmony export */   writeSleb128Async: () => (/* binding */ writeSleb128Async),
/* harmony export */   writeUleb128Async: () => (/* binding */ writeUleb128Async)
/* harmony export */ });
/* unused harmony exports readULeb128, readSLeb128, writeSleb128, writeUleb128 */
/* harmony import */ var _io_BufferReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../io/BufferReader */ "./src/common/io/BufferReader.ts");

function readULeb128(reader) {
    let result = 0;
    let shift = 0;
    while (true) {
        const byte = reader.readUint8();
        result |= (byte & 0x7f) << shift;
        shift += 7;
        if (!(byte & 0x80)) {
            break;
        }
    }
    return result;
}
async function readULeb128Async(reader) {
    let result = 0;
    let shift = 0;
    while (true) {
        const byte = await reader.readUint8();
        result |= (byte & 0x7f) << shift;
        shift += 7;
        if (!(byte & 0x80)) {
            break;
        }
    }
    return result;
}
function readSLeb128(reader) {
    let result = 0;
    let shift = 0;
    let byte;
    while (true) {
        byte = reader.readUint8();
        result |= (byte & 0x7f) << shift;
        shift += 7;
        if (!(byte & 0x80)) {
            break;
        }
    }
    // 符号扩展，将最高有效位的符号位扩展到高位
    if (byte & 0x40) {
        // 如果最高有效位是 1（负数），则将高位全部置为 1
        result |= (~0 << shift);
    }
    return result;
}
async function readSLeb128Async(reader) {
    let result = 0;
    let shift = 0;
    let byte;
    while (true) {
        byte = await reader.readUint8();
        result |= (byte & 0x7f) << shift;
        shift += 7;
        if (!(byte & 0x80)) {
            break;
        }
    }
    // 符号扩展，将最高有效位的符号位扩展到高位
    if (byte & 0x40) {
        // 如果最高有效位是 1（负数），则将高位全部置为 1
        result |= (~0 << shift);
    }
    return result;
}
function writeSleb128(writer, value) {
    let more = true;
    while (more) {
        let byte = value & 0x7f;
        value >>= 7;
        // 如果还有未编码的位，设置高位为 1
        if ((value === 0 && (byte & 0x40) === 0) || (value === -1 && (byte & 0x40) !== 0)) {
            more = false;
        }
        else {
            byte |= 0x80;
        }
        writer.writeUint8(byte);
    }
}
async function writeSleb128Async(writer, value) {
    let more = true;
    while (more) {
        let byte = value & 0x7f;
        value >>= 7;
        // 如果还有未编码的位，设置高位为 1
        if ((value === 0 && (byte & 0x40) === 0) || (value === -1 && (byte & 0x40) !== 0)) {
            more = false;
        }
        else {
            byte |= 0x80;
        }
        await writer.writeUint8(byte);
    }
}
function writeUleb128(writer, value) {
    do {
        let byte = value & 0x7f;
        value >>= 7;
        // 如果还有未编码的位，设置高位为 1
        if (value !== 0) {
            byte |= 0x80;
        }
        writer.writeUint8(byte);
    } while (value !== 0);
}
async function writeUleb128Async(writer, value) {
    do {
        let byte = value & 0x7f;
        value >>= 7;
        // 如果还有未编码的位，设置高位为 1
        if (value !== 0) {
            byte |= 0x80;
        }
        await writer.writeUint8(byte);
    } while (value !== 0);
}
function setMemoryShared(wasm, shared) {
    const reader = new _io_BufferReader__WEBPACK_IMPORTED_MODULE_0__["default"](wasm, true);
    reader.skip(8);
    while (reader.remainingSize()) {
        const sectionId = reader.readUint8();
        const size = readULeb128(reader);
        if (sectionId === 2 /* SectionId.Import */) {
            let count = readULeb128(reader);
            while (count--) {
                const moduleLen = readULeb128(reader);
                reader.skip(moduleLen);
                const fieldLen = readULeb128(reader);
                reader.skip(fieldLen);
                const externalKind = reader.readUint8();
                switch (externalKind) {
                    case 0 /* ExternalKind.Function */: {
                        // type index of the function signature
                        readULeb128(reader);
                        break;
                    }
                    case 3 /* ExternalKind.Global */: {
                        // content_type
                        readSLeb128(reader);
                        // mutability
                        readULeb128(reader);
                        break;
                    }
                    case 2 /* ExternalKind.Memory */: {
                        const pos = Number(reader.getPos());
                        if (shared) {
                            wasm[pos] = wasm[pos] | 2;
                        }
                        else {
                            wasm[pos] = wasm[pos] & ~2;
                        }
                        return;
                    }
                    case 1 /* ExternalKind.Table */: {
                        // elem_type
                        readSLeb128(reader);
                        const flags = readULeb128(reader);
                        readULeb128(reader);
                        if (flags & 0x01) {
                            // maximum
                            readULeb128(reader);
                        }
                        break;
                    }
                }
            }
            return;
        }
        else {
            reader.skip(size);
        }
    }
}


/***/ }),

/***/ "./src/videoscale/VideoScaler.ts":
/*!***************************************!*\
  !*** ./src/videoscale/VideoScaler.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VideoScaler)
/* harmony export */ });
/* harmony import */ var cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cheap/webassembly/WebAssemblyRunner */ "./src/cheap/webassembly/WebAssemblyRunner.ts");
/* harmony import */ var common_util_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! common/util/logger */ "./src/common/util/logger.ts");
var cheap__fileName__0 = "src/videoscale/VideoScaler.ts";


class VideoScaler {
    scaler;
    options;
    inputParameters;
    outputParameters;
    constructor(options) {
        this.options = options;
        this.scaler = new cheap_webassembly_WebAssemblyRunner__WEBPACK_IMPORTED_MODULE_0__["default"](this.options.resource);
    }
    async open(input, output, algorithm = 2 /* ScaleAlgorithm.BILINEAR */) {
        this.inputParameters = input;
        this.outputParameters = output;
        await this.scaler.run();
        this.scaler.call('scale_set_input_parameters', input.width, input.height, input.format);
        this.scaler.call('scale_set_output_parameters', output.width, output.height, output.format);
        let ret = this.scaler.call('scale_init', algorithm);
        if (ret < 0) {
            common_util_logger__WEBPACK_IMPORTED_MODULE_1__.fatal(`open scaler failed, ret: ${ret}`, cheap__fileName__0, 92);
        }
    }
    scale(src, dst) {
        return this.scaler.call('scale_process', src, dst);
    }
    close() {
        this.scaler.call('scale_destroy');
        this.scaler.destroy();
        this.scaler = null;
    }
    getInputScaleParameters() {
        return this.inputParameters;
    }
    getOutputScaleParameters() {
        return this.outputParameters;
    }
}


/***/ }),

/***/ "./src/cheap/asm/memory.asm":
/*!**********************************!*\
  !*** ./src/cheap/asm/memory.asm ***!
  \**********************************/
/***/ ((module) => {

module.exports = "AGFzbQEAAAABKQhgAn9/AGACf34AYAJ/fQBgAn98AGABfwF/YAF/AX5gAX8BfWABfwF8AhIBA2VudgZtZW1vcnkCAwGAgAIDDw4AAAABAgMEBAQEBAUGBweIAQ4Gd3JpdGU4AAAHd3JpdGUxNgABB3dyaXRlMzIAAgd3cml0ZTY0AAMId3JpdGVmMzIABAh3cml0ZWY2NAAFBXJlYWQ4AAYGcmVhZFU4AAcGcmVhZDE2AAgHcmVhZFUxNgAJBnJlYWQzMgAKBnJlYWQ2NAALB3JlYWRmMzIADAdyZWFkZjY0AA0KfQ4JACAAIAE6AAALCQAgACABOwEACwkAIAAgATYCAAsJACAAIAE3AwALCQAgACABOAIACwkAIAAgATkDAAsHACAALAAACwcAIAAtAAALBwAgAC4BAAsHACAALwEACwcAIAAoAgALBwAgACkDAAsHACAAKgIACwcAIAArAwAL";

/***/ }),

/***/ "./src/cheap/thread/asm/atomics.asm":
/*!******************************************!*\
  !*** ./src/cheap/thread/asm/atomics.asm ***!
  \******************************************/
/***/ ((module) => {

module.exports = "AGFzbQEAAAABLAdgAX8Bf2ABfwF+YAJ/fwF/YAJ/fgF+YAN/f38Bf2ADf35+AX5gA39/fgF/AhIBA2VudgZtZW1vcnkCAwGAgAIDKCcAAAABAgICAwICAgMCAgIDAgICAwICAgMCAgIDAgICAwQEBAUCAgYHhgMnBWxvYWQ4AAAGbG9hZDE2AAEGbG9hZDMyAAIGbG9hZDY0AAMGc3RvcmU4AAQHc3RvcmUxNgAFB3N0b3JlMzIABgdzdG9yZTY0AAcEYWRkOAAIBWFkZDE2AAkFYWRkMzIACgVhZGQ2NAALBHN1YjgADAVzdWIxNgANBXN1YjMyAA4Fc3ViNjQADwRhbmQ4ABAFYW5kMTYAEQVhbmQzMgASBWFuZDY0ABMDb3I4ABQEb3IxNgAVBG9yMzIAFgRvcjY0ABcEeG9yOAAYBXhvcjE2ABkFeG9yMzIAGgV4b3I2NAAbCWV4Y2hhbmdlOAAcCmV4Y2hhbmdlMTYAHQpleGNoYW5nZTMyAB4KZXhjaGFuZ2U2NAAfEWNvbXBhcmVfZXhjaGFuZ2U4ACASY29tcGFyZV9leGNoYW5nZTE2ACESY29tcGFyZV9leGNoYW5nZTMyACISY29tcGFyZV9leGNoYW5nZTY0ACMGbm90aWZ5ACQEd2FpdAAlC3dhaXRUaW1lb3V0ACYKugMnCAAgAP4SAAALCAAgAP4TAQALCAAgAP4QAgALCAAgAP4RAwALDAAgACAB/hkAACABCwwAIAAgAf4aAQAgAQsMACAAIAH+FwIAIAELDAAgACAB/hgDACABCwoAIAAgAf4gAAALCgAgACAB/iEBAAsKACAAIAH+HgIACwoAIAAgAf4fAwALCgAgACAB/icAAAsKACAAIAH+KAEACwoAIAAgAf4lAgALCgAgACAB/iYDAAsKACAAIAH+LgAACwoAIAAgAf4vAQALCgAgACAB/iwCAAsKACAAIAH+LQMACwoAIAAgAf41AAALCgAgACAB/jYBAAsKACAAIAH+MwIACwoAIAAgAf40AwALCgAgACAB/jwAAAsKACAAIAH+PQEACwoAIAAgAf46AgALCgAgACAB/jsDAAsKACAAIAH+QwAACwoAIAAgAf5EAQALCgAgACAB/kECAAsKACAAIAH+QgMACwwAIAAgASAC/koAAAsMACAAIAEgAv5LAQALDAAgACABIAL+SAIACwwAIAAgASAC/kkDAAsKACAAIAH+AAIACwwAIAAgAUJ//gECAAsMACAAIAEgAv4BAgAL";

/***/ }),

/***/ "./src/cheap/webassembly/runtime/asm/thread.asm":
/*!******************************************************!*\
  !*** ./src/cheap/webassembly/runtime/asm/thread.asm ***!
  \******************************************************/
/***/ ((module) => {

module.exports = "AGFzbQEAAAABEwNgAX8Bf2ACf38Bf2ADf39/AX8CEgEDZW52Bm1lbW9yeQIDAYCAAgMHBgAAAQIAAAc5BgRsb2NrAAAGdW5sb2NrAAEEd2FpdAACCXRpbWVkd2FpdAADBnNpZ25hbAAECWJyb2FkY2FzdAAFCvYBBlYBAX8gAEEAQQH+SAIAIQEgAUEARwRAA0AgAUECRgR/QQEFIABBAUEC/kgCAEEARwsEQCAAQQJCf/4BAgAaCyAAQQBBAv5IAgAhASABQQBHDQALC0EACyMAIABBAf4lAgBBAUcEQCAAQQD+FwIAIABBAf4AAgAaC0EACx0AIAAgAP4QAgAgARABGkJ//gECABogARAAGkEACykAIAAgAP4QAgAgARABGiACKQMA/gECACABEAAaQQJGBH9B8AAFQQALCxYAIABBAf4eAgAaIABBAf4AAgAaQQALGgAgAEEB/h4CABogAEGAgICABP4AAgAaQQAL";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".avtranscoder.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "AVTranscoder:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkAVTranscoder"] = self["webpackChunkAVTranscoder"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module factories are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("./src/avtranscoder/AVTranscoder.ts");
/******/ 	__webpack_exports__ = __webpack_exports__["default"];
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=avtranscoder.js.map